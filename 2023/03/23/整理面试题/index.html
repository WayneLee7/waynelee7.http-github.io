<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="李凤伟的小站" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

  <meta name="description" content="整理tcp与udp的区别tcp：面向连接，三次握手建立连接，四次挥手解除连接udp：无连接，发送数据之前不需要建立连接，会带来高效的传输效率，也导致无法确保数据发送成功tcp：可靠通信方式，通过tcp连接发送的数据支持超时重传，数据校验，确保数据无差错，不丢失，不重复，按序到达udp：由于无需连接，将会以最大速度传输，但不保证可靠交付，会出现丢失，重复问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="李凤伟的小站">
<meta property="og:url" content="http://yoursite.com/2023/03/23/整理面试题/index.html">
<meta property="og:site_name" content="李凤伟的小站">
<meta property="og:description" content="整理tcp与udp的区别tcp：面向连接，三次握手建立连接，四次挥手解除连接udp：无连接，发送数据之前不需要建立连接，会带来高效的传输效率，也导致无法确保数据发送成功tcp：可靠通信方式，通过tcp连接发送的数据支持超时重传，数据校验，确保数据无差错，不丢失，不重复，按序到达udp：由于无需连接，将会以最大速度传输，但不保证可靠交付，会出现丢失，重复问题。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1ccbdee4f468444dae832fb574ec733d.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:updated_time" content="2023-03-23T11:07:52.413Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李凤伟的小站">
<meta name="twitter:description" content="整理tcp与udp的区别tcp：面向连接，三次握手建立连接，四次挥手解除连接udp：无连接，发送数据之前不需要建立连接，会带来高效的传输效率，也导致无法确保数据发送成功tcp：可靠通信方式，通过tcp连接发送的数据支持超时重传，数据校验，确保数据无差错，不丢失，不重复，按序到达udp：由于无需连接，将会以最大速度传输，但不保证可靠交付，会出现丢失，重复问题。">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/1ccbdee4f468444dae832fb574ec733d.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="http://yoursite.com/2023/03/23/整理面试题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title> | 李凤伟的小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>
<!-- 添加动态线条背景 -->

<script type="text/javascript" color="0,0,0" opacity='1.0'  src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
   <a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李凤伟的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/03/23/整理面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WayneLee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李凤伟的小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-23 19:10:43 / 修改时间：19:07:52" itemprop="dateCreated datePublished" datetime="2023-03-23T19:10:43+08:00">2023-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><h2 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h2><p>tcp：面向连接，三次握手建立连接，四次挥手解除连接</p><p>udp：无连接，发送数据之前不需要建立连接，会带来高效的传输效率，也导致无法确保数据发送成功</p><p>tcp：可靠通信方式，通过tcp连接发送的数据支持超时重传，数据校验，确保数据无差错，不丢失，不重复，按序到达</p><p>udp：由于无需连接，将会以最大速度传输，但不保证可靠交付，会出现丢失，重复问题。</p><a id="more"></a>



<p>tcp：面向字节流，tcp把数据看成一连串的无结构字节流，由于连接的问题，网络出现波动，连接可能出现响应的问题</p>
<p>udp：面向报文，udp没有拥塞控制，因此网络出现拥塞，不会使源主机的发送速率降低</p>
<p>每一条tcp只能是点到点</p>
<p>udp不建立连接，所以可以支持一对一，一对多，多对一，多对多的交互通信，可以同时接受多个人的包</p>
<p>tcp需要建立连接，首部开销20字节比udp的8个字节大</p>
<p>tcp逻辑通信信道是全双工的可靠信道</p>
<p>udp是不可靠信道</p>
<h2 id="for-in-—–-for-of"><a href="#for-in-—–-for-of" class="headerlink" title="for in —– for of"></a>for in —– for of</h2><p>循环数组 ：forin是每一项的下标  forof是每一项的值</p>
<p>循环对象：for in可以遍历对象  forof不行  没有iterator接口</p>
<h2 id="foreach-—–map"><a href="#foreach-—–map" class="headerlink" title="foreach —–map"></a>foreach —–map</h2><p>foreach无返回值  map返回一个新数组并和与其他方法连接在一起</p>
<p>foreach回调里面可以修改原数组</p>
<p>foreach执行速度快于map（foreach函数签名中包含了参数和上下文，map会返回新数组，数组创建和赋值会导致分配内存空间，因此带来性能开销）</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝基本类型就复制值，引用类型只复制某个对象的指针（内存地址），新旧对象共享一块内存，其中一个改变就会影响到另一个</p>
<p>深拷贝复制创建一个一模一样的对象，不会拷贝引用</p>
<p>浅拷贝：object.asssign()方法，数组splice、concat方法，…扩展运算符</p>
<p>深拷贝：lodash的cloneDeep方法，JSON.parse和stringify转换</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>可以用for循环或者foreach遍历数组  定义一个新数组 然后用新数组加上indexof方法来查找每一项 如果等于-1 则表示新数组里面没有一样的 就把这个push进新数组里面（也可以用数组的includes方法判断新数组是否包含了原数组的某个元素 包含返回true 不包含返回false false的时候push进去）</p>
<p>再就是用…new Set(arr)来判断</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>声明局部变量供外部使用，防止变量污染全局，通过某种方式获取函数内部变量暴露给函数外部，声明在一个函数中的函数，叫闭包函数。（函数外部无法读取函数内部的局部变量，只有函数内部的子函数可以读取局部变量。又需要使用函数内部的局部变量）、</p>
<p>让变量始终保持在内存中，不会在调用后清除</p>
<p>由于闭包会是函数中的变量被常驻在内存中，内存消耗极大，所有不能滥用闭包，否则会造成性能问题，ie会内存泄露</p>
<p>退出函数之前，将不使用的局部变量删除</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如果存在大量未被释放的内存（堆栈上下文）页面性能会变得很慢，当某些代码操作不能被合理释放，会造成内存泄露，计量减少闭包使用</p>
<p>js具有垃圾回收机制，垃圾收集器定期（周期性）找出那些不在继续使用的变量，然后释放内存、</p>
<p>标记清除：当变量进入执行环境，标记为进入环境，离开执行环境，标记为离开环境 ，会销毁那些带标记的值，并回收他们所占有的内存空间。</p>
<p>引用计数：内存被占用一次，计数累加一次，移除占用就减一，减到0就回收。</p>
<p>应该手动释放取消内存的占用</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>程序运行需要内存，对于持续运行的服务进程，必须及时释放不再用到的内存，否则占用越来越高，影响系统性能，导致进程崩溃，</p>
<p>由于使用未声明的变量，而意外的创建了一个全局变量，是变量一直留在内存中无法被回收。</p>
<p>设置定时器 忘记取消，循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中。</p>
<p>获取一个dom元素的引用，后面如果元素被删除，由于一直保留了对这个元素的引用，所以也无法被回收</p>
<p>不合理的使用闭包</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>class继承</p>
<p>原型链继承：父类的实例作为子类的原型</p>
<p>构造函数继承： 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类  call调用父类</p>
<p>组合继承：前两种组合</p>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>作为普通函数被调用 this指向window （严格模式指向underfind）</p>
<p>函数作为对象的方法被调用 this指向该对象</p>
<p>构造器调用 this指向返回的这个对象实例</p>
<p>箭头函数自身不绑定this 在作用域链上一层继承this 绑定到最近的一层对象</p>
<p>apply bind call都可以指定调用函数的this指向</p>
<p>call：（要改变的this指向，参数1，参数2，……..）</p>
<p>apply：（要改变的this指向，[参数1，参数2，…….]）</p>
<p>bind：方法返回一个函数，有需要在调用执行，也是参数列表的形式传递参数。</p>
<h2 id="eventLoop"><a href="#eventLoop" class="headerlink" title="eventLoop"></a>eventLoop</h2><p>遇到异步事件不会一直等待其返回结果，而是将事件挂起，继续执行执行栈的其他任务，异步任务会进入Event Table并注册回调函数，等到指定的事件完成并返回结果加入到另一个事件队列（将回调函数移入到Event Queue），加入事件队列不会立即执行其回调，而是等待当前执行栈中的所有任务执行完毕，主线程闲置的时候再去查找事件队列中是否有任务，先看微任务队列，有任务就将微任务队列中所有任务依次执行。直到微任务为空，之后再检查宏任务队列，如果有任务取出第一个宏任务加入到执行栈中执行清空，  从里面取出排在第一个的事件，把这个事件对应的回调放入执行栈中，执行，再去执行微任务，然后在取宏任务清微任务，如此反复循环。</p>
<p>微任务有：promise回调，node中的process.nexttick，对DOM监听的MutationObserver</p>
<p>宏任务包括 script全部代码，setTimeout，setIntervel，I/O操作，UI渲染</p>
<p>同一次事件循环中 微任务永远在宏任务之前执行 因为宏任务队列执行时间较长 所以微任务优于宏任务队列</p>
<h2 id="为什么js设计为单线程"><a href="#为什么js设计为单线程" class="headerlink" title="为什么js设计为单线程"></a>为什么js设计为单线程</h2><p>浏览器中需要进行各种各样的DOM操作</p>
<p>如果设计为多线程，两个线程同时对DOM进行不一样的操作的时候，那应该如何处理？所以选择只用一个线程来执行代码，保证程序执行的一致性。</p>
<p>web workers 可以让js成为一门多线程语言</p>
<p>但是所有新线程都受到主线程完全控制，不能独立执行，线程实际上应属于主线程的子线程，子线程没有执行I/O操作的操作权限，只能为主线程分担一些诸如计算等任务，严格来讲这些线程并没有完整功能，并未改变js单线程的本质。</p>
<h2 id="输入URL到页面加载的过程"><a href="#输入URL到页面加载的过程" class="headerlink" title="输入URL到页面加载的过程"></a>输入URL到页面加载的过程</h2><h2 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h2><p>get在浏览器回退不会再次请求，post会再次请求</p>
<p>get请求参数会被浏览器主动缓存，post不会除非主动设置</p>
<p>get请求参数会被完整保留在浏览器历史记录里，post中的参数不会被保留</p>
<p>get请求在url中传送的参数是有长度限制的受限于url长度，post没有限制</p>
<p>get参数通过url传递，post放在request body请求体中</p>
<p>get参数暴露在地址栏不安全，post放在报文内部更安全</p>
<p>get产生一个tcp数据包，post产生两个</p>
<p>get一般用于查询信息，post用于提交某种信息进行某些修改操作·</p>
<p>get传送数据量较小，不能大于2kb，post较大一般不受限制</p>
<p>—post发送两次请求</p>
<p>跨域校验 options请求 服务器返回204 （表示请求执行成功但是没有数据，浏览器不用刷新页面，也不用导向新的页面）然后才会发送post请求</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p><strong>1开头的 信息类</strong></p>
<p>100接受的请求正在处理</p>
<p><strong>2开头 成功</strong></p>
<p>200 请求成功 ok</p>
<p>202 请求但是尚未处理</p>
<p><strong>3开头 重定向表示要完成请求需要进一步操作</strong></p>
<p>301 永久重定向 资源已经被分配到了新URL</p>
<p>302 临时重定向</p>
<p>303 资源存在另一个URL，用GET方法获取</p>
<p>304 未修改 自从上次请求后未修改过</p>
<p><strong>4开头 客户端错误</strong></p>
<p>400 请求错误   语法</p>
<p>401 需要http认证</p>
<p>403 表示访问拒绝 超出访问权限</p>
<p>404 服务器找不到请求的内容</p>
<p><strong>5开头 服务器错误</strong></p>
<p>500 服务器遇到错误 无法完成请求</p>
<p>503 后端维护服务器</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>一个事件触发会在子元素和父元素之间传播，分成三个阶段</p>
<p>目标阶段：在目标节点上触发，</p>
<p>事件冒泡：事件会从最内层的目标元素开始发生，一直向上传播，直到document对象（文档根节点），从下向上</p>
<p>事件捕获： 与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。 </p>
<p> event.stopPropagation(); 可以阻止事件捕获和事件冒泡的发生 </p>
<p> event.preventDefault();  阻止默认事件</p>
<p><strong>事件代理</strong></p>
<p>就是把元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过<a href="https://so.csdn.net/so/search?q=事件冒泡&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">事件冒泡</a>机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。 </p>
<p>给外层加事件 等点击里面的具体元素的时候，都会冒泡到外层执行，</p>
<p>绑定大量的实践，对于内存消耗是非常大，绑定到父层，执行的时候再去判断目标元素，可以减少大量的内存消耗。</p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>防抖：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算事件（多次执行变成最后一次执行）第一次触发事件不立即执行，给出期限值，如果这个期限值内没有在此触发，那就执行函数。期限值内如果在此触发事件，当时计时重新计时，短时间大量触发同一事件，只会执行一次。</p>
<p>节流：高频事件触发，但在n秒内只会执行一次，节流会稀释函数的执行频率（多次执行变成每隔一段时间执行）在限定时间段，不断触发事件，（闲着无聊按住滚动条滚来滚去）希望即使不断拖放滚动条，也能在某个时间间隔给反馈，让函数执行一次，在某个时间段内暂时失效，过段时间后重新激活，短时间大量触发同一事件，执行一次后，指定时间期限不工作，直到过了这段时间。</p>
<p>都是为了节省程序性能（防止高频函数调用），提高性能避免资源浪费</p>
<p>进行窗口大小调整，滚动页面或输入框搜索联想词都会频繁触发事件处理函数，耗性能页面卡顿</p>
<p>防抖：即时搜索输入过快，前一次结果出现在后一次的后面（信息有误）表单元素校验手机号邮箱用户名、部分搜索功能联想结果、防止多次提交按钮，只执行最后提交的一次。</p>
<p>节流：鼠标跟随动画，scroll，resize，touchmove，mousemove等极易持续性触发事件，防止表单重复点击，提交一次，窗口调整，页面滚动，滚动加载，加载更多，搜索联想</p>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>每个函数都有一个prototype属性 指向函数的原型对象</p>
<p>每个对象（引用类型）都有一个<em>_proto</em>_（隐式原型）属性</p>
<p>引用类型的<em>_proto</em>_属性指向它的构造函数的prototype</p>
<p>每个原型对象都有一个constructor属性 指向构造函数</p>
<p>object.getprototype()可以获取对象的原型</p>
<p>原型链：读取实例的属性，如果找不到就会查找与对象关联的原型中的属性，如果还查不到 因为原型也是个对象也有它自己的原型对象，就在它的<em>proto</em>中去找原型的原型，一直找到最顶层。这样的链条就构成了原型链</p>
<p> <img src="https://img-blog.csdnimg.cn/1ccbdee4f468444dae832fb574ec733d.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"> </p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>将一个很大的程序文件，拆分为许多个小的文件，然后将多个小文件组合起来</p>
<p>  ①阻止命名冲突； ② 代码复用； ③ 高维护性 </p>
<p><strong>commonJS</strong></p>
<p>暴露模块用module.exports=value  、export.xxx=value</p>
<p>引入模块require(xxx) 第三方模块-&gt;模块名    自定义模块-&gt;模块路径</p>
<p>AMD、CMD。。。。</p>
<p>es6在语言标准上实现了模块功能，思想是尽量静态化，使得编辑时就能确定模块的依赖关系，以及输入输出变量，commonjs和amd都只能在运行时确定。</p>
<p>export分别暴露  引入时需要用对象来引入</p>
<p>统一暴露 export{xxx，xxx}</p>
<p>默认暴露 export default </p>
<p>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD、CMD解决方案。</p>
<h2 id="存储的方式"><a href="#存储的方式" class="headerlink" title="存储的方式"></a>存储的方式</h2><p>localstorage：永久保存，关闭页面或浏览器里面的数据也不会消失，除非主动删除数据，否则数据永远不会消失。</p>
<p>sessionstorate：数据在当前浏览器窗口关闭后自动删除，仅在当前会话下有效。</p>
<p>cookie：在设置的过期时间之前一直有效，即使窗口或浏览器关闭，大小不能超过4k，不能储存大数据，不易读取。另外两个大多了，可以达到5m，cookie数据自动传递到服务器，另外两个本地。由于服务器指定cookie以后浏览器的每次请求都会携带cookie数据，会带来额外的性能负担。</p>
<p>cookie用在  会话状态管理（用户登录状态、购物车）</p>
<p>用户自定义个性化设置，浏览器行为跟踪。</p>
<h2 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h2><p>语法上，Generator 函数是一个状态机，封装了多个内部状态。<br>形式上，Generator是一个函数。不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。<br>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器，异步操作需要暂停的地方，都用yield语句。</p>
<ol>
<li>function 关键字和函数之间有一个星号(*),且内部使用yield表达式，定义不同的内部状态。</li>
<li><p>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。</p>
<p>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。即：每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。 </p>
<p>Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 </p>
</li>
</ol>
<h2 id="vue基本原理"><a href="#vue基本原理" class="headerlink" title="vue基本原理"></a>vue基本原理</h2><p>当 一 个Vue 实 例 创 建 时，Vue会遍历data中的属性，用Object.defineProperty （ vue3.0 使 用 proxy ） 将它们转为getter/setter，实现数据劫持，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 vue的指令编译器（compiler）对元素节点的各个指令进行解析，初始化视图。并订阅watcher来更新视图，watcher会将自己添加到消息订阅器dep中去。每个组件实例都有相应的 watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，立即调用dep.notify方法，dep这个数组开始遍历所有订阅者并调用其update方法，vue内部通过diff算法，patch相应的更新完成对订阅者视图改变。会通知watcher重新计算，从而致使它关联的组件得以更新</p>
<h2 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h2><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 </p>
<p>Object.defineProperty()来劫持各个属性的 setter，getter，在数 据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤： </p>
<p>1.需要 <strong>observer</strong>（数据监听器） 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter 这样的话，每当数据变动就会触发setter，这时候observer就要通知订阅者watcher</p>
<p>2.<strong>compile</strong>（指令解析器）主要做的就是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 </p>
<p>3.<strong>Watcher</strong>（订阅者）是 Observer 和 Compile 之间通信的桥梁，数据更新使关联视图重新渲染（更新dom）主要做的事情是: </p>
<p>①在自身实例化时往属性订阅器(dep)里面添加自己 </p>
<p>② 自身必须有一个 update()方法 </p>
<p>③待属性变动 dep.notice()通知时， 能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功 成身退。 </p>
<p>4.MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果</p>
<h2 id="mvvm和mvc、mvp区别"><a href="#mvvm和mvc、mvp区别" class="headerlink" title="mvvm和mvc、mvp区别"></a>mvvm和mvc、mvp区别</h2><p>是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>
<p>mvc：通过分离model、view和controller的方式来组织代码结构，其中view负责页面的显示逻辑，model负责存储页面的业务数据，以及对先相应数据的操作，并且view和model应用了观察者模式，当model层发生改变的时候会通知有关的view层更新页面，controller层是view和model层的纽带，负责用户与应用的响应操作，当用户与界面产生交互的时候，controller中的事件触发器就开始工作了，通过调用model层，来完成对model的修改，然后model层再去通知view层更新。</p>
<p>view-&gt;动作指令—-controller-&gt;选择模型—model-&gt;驱动视图—view</p>
<p>mvvm：分为model、view、viewmodel</p>
<p>model表示数据模型，数据和业务逻辑都在model层定义</p>
<p>view代表UI视图，负责数据的展示</p>
<p>viewmodel负责监听model中数据的改变并且控制视图的更新，处理用户交互操作</p>
<p>view和model并无直接关联，而是通过viewmodel来进行联系，model和viewmodel之间有着双向数据绑定的关系。因此当model中的数据改变时会触发view层的刷新，view中由于用户交互操作而改变的数据也会在model中同步。</p>
<p>实现了model和view的数据自动同步，因此开发者只需要专注于数据的操作维护即可，而不需要自己操作DOM。</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>等待下一次DOM更新刷新的工具方法（就是在$nexttick中的操作不会立即执行，而是等数据更新、Dom更新完成之后在执行，这样拿到的肯定就是最新的）</p>
<p>vue中dom更新时异步执行的，修改数据视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的数据变化完成之后，在统一进行视图更新。</p>
<p>vue如果数据变化，不会立即更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新，这一策略导致我们对数据的修改不会立即体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick。</p>
<p>场景：created中想要获取dom、响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度</p>
<p>用于处理数据动态变化后，dom还未及时更新的问题，nexttick可以获取数据更新后最新的dom变化。</p>
<p>原理：之所以可以看到dom更新后的结果，是因为传入的回调会被添加到队列刷新函数的后面，这样等队列内部的更新函数都执行完毕，所有dom操作也就结束了，回调自然能够获取到最新的dom值。</p>
<p>引入异步更新队列机制的原因：如果是同步，则每次对一个或多个属性赋值，会频繁触发ui/dom的渲染，可以减少一些无用的渲染。</p>
<h2 id="单页应用和多页应用理解"><a href="#单页应用和多页应用理解" class="headerlink" title="单页应用和多页应用理解"></a>单页应用和多页应用理解</h2><p>spa单页面应用，一个主页面+许多模块的组件，指只有一个主页面的应用，一开始只需要加载一次jscss等相关资源，所有内容都包含在主页面，对每一个功能模块 组件化，单页应用跳转，就是切换相关组件，仅仅刷新局部资源。不利于seo</p>
<p>mpa多页面：有多个独立页面的应用，多页应用跳转，需要整页资源刷新。</p>
<h2 id="vue中封装的数组方法，如何实现页面更新"><a href="#vue中封装的数组方法，如何实现页面更新" class="headerlink" title="vue中封装的数组方法，如何实现页面更新"></a>vue中封装的数组方法，如何实现页面更新</h2><p>简单来说，重写了数组的那些原生方法，首先获取到这个数组的 <em>__ob</em>__，也就是它的observer对象，如果有新的值，就调用oberverArray继续对新的值观察变化（就是通过target proto ==arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
<h2 id="某一个属性的值发生改变后，视图会立即同步执行渲染吗"><a href="#某一个属性的值发生改变后，视图会立即同步执行渲染吗" class="headerlink" title="某一个属性的值发生改变后，视图会立即同步执行渲染吗"></a>某一个属性的值发生改变后，视图会立即同步执行渲染吗</h2><p>不会，vue实现响应式并不是数据发生变化之后dom立即变化，而是按一定的策略进行dom的更新。vue在更新dom时是异步执行的，只要侦听到数据变化，vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次，这种在缓冲时去除重复数据对于避免不必要的计算和dom操作是非常重要的，然后在下一个的事件循环tick中，vue刷新队列并执行实际（已去重的）工作。</p>
<h2 id="子组件改变父组件的数据"><a href="#子组件改变父组件的数据" class="headerlink" title="子组件改变父组件的数据"></a>子组件改变父组件的数据</h2><p>子组件不可以直接改变父组件的数据，这样做是为了维护父子组件的单向数据流，每次父组件发生更新时，子组件中所有的prop都将会刷新为最新的值，如果这样做了，vue会在浏览器的控制台中发出警告。</p>
<p>vue提倡单向数据流，即父级props的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱，如果破坏了单向数据流。当应用复杂时，debug的成本会非常高。</p>
<p>只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h2 id="React和Vue的理解"><a href="#React和Vue的理解" class="headerlink" title="React和Vue的理解"></a>React和Vue的理解</h2><p>相似之处：都将注意力保持在核心库，而将其他功能如路由和全局状态管理交给其他的库。</p>
<p>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板，都使用了虚拟DOM提高重绘性能；都有props的概念，允许组件间的数据传递。都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</p>
<p>不同之处：vue默认支持数据双向绑定，react一直提倡单向数据流。vue鼓励写近似常规HTML的模板，写起来很接近标准html元素，只是多了一些属性，react推荐所有的模板用jsx</p>
<p>书写。vue通过getter/setter以及一些函数的劫持，能精确的知道数据变化，不需要特别的优化就能达到很好的性能。react默认是通过比较引用的方式进行的，如果不优化可能会导致大量不必要的vdom重新渲染。</p>
<h2 id="vue模板编译原理"><a href="#vue模板编译原理" class="headerlink" title="vue模板编译原理"></a>vue模板编译原理</h2><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的html语法，所以需要将template转化成一个js函数，这样浏览器就可以执行这一函数并渲染出对应的html元素，就可以让视图跑起来了。这一个转化的过程，就称为模板编译。分为三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<p>解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST</p>
<p>优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。用来做虚拟dom渲染优化。</p>
<p>生成阶段：将最终的ast转化为render函数字符串。</p>
<h2 id="mvvm优缺点"><a href="#mvvm优缺点" class="headerlink" title="mvvm优缺点"></a>mvvm优缺点</h2><p>分离视图和模型，降低代码耦合，提高视图或者逻辑的重用性：一个viewmodel可以绑定不同的view上，把一些视图逻辑放在一个viewmodel里面，让很多view重用这段视图逻辑。自动更新dom：利用双向绑定，数据更新后视图自动更新，让开发者从繁琐的手动dom中解放。</p>
<p>缺点：bug难调试，因为双向绑定，当看到界面异常，可能是view代码有bug，也可能是model代码有问题。定位原始出问题的地方就变得不那么容易，数据绑定的声明是指令式的写在view模板，无法打断点debug。模块大的话model也会很大，虽然保证了数据一致性，长期不释放内存造成花费更多内存，视图状态较多，viewmodel的构建和维护的成本比较高。</p>
<h2 id="v-if、v-for"><a href="#v-if、v-for" class="headerlink" title="v-if、v-for"></a>v-if、v-for</h2><p>v-for优于v-if被解析，如果同时出现，每次渲染都会先执行循环。无论如何循环都不可避免，浪费了性能。</p>
<p>避免出现就在外层嵌套template，在这一层进行v-if判断。然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉不需要显示的项。</p>
<h2 id="组件化理解"><a href="#组件化理解" class="headerlink" title="组件化理解"></a>组件化理解</h2><p>组件是独立和可复用的代码组织单元，核心特性，使开发者使用小型独立和通常可复用的组件构建大型应用。</p>
<p>提高应用开发效率，测试性，复用性等</p>
<p>分类：页面组件，业务组件，通用组件</p>
<p>应该高内聚，低耦合</p>
<h2 id="路由的hash和history"><a href="#路由的hash和history" class="headerlink" title="路由的hash和history"></a>路由的hash和history</h2><p>hash：它的url带着一个#，hash虽然出现在url中，但不会包含在http请求中，对后端完全没有影响，因此改变hash不会重新加载页面。对浏览器的支持度很好，低版本的ie也支持。hash改变会触发hashchange事件，事件只能改变#后面的url片段，改变#后面的路径本质是更换当前页面锚点，所以不会刷新页面。就可以监听浏览器onhashchange事件变化，查找对应的路由规则。hash值变化对应的url都会被浏览器记录下来，这样·浏览器就能实现页面的前进和后退。</p>
<p>history：用户输入一个url，服务器接收请求并解析这个url做出对应的逻辑处理。传统的路由分发模式。需要后台配置路由处理支持，如果后台没有正确配置访问时会返回404。利用h5 history新增pushstate、replacestate和onpopstate监听url变化。</p>
<p>相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发。</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>状态管理模式，每一个vuex应用的核心就是store仓库，store就是一个容器，保存着应用大部分的state状态。</p>
<p>改变store中的状态的唯一途径就是提交commit（mutation）。方便跟踪每一个状态的变化。</p>
<p>组件会触发（dispatch）一些事件或动作，组件发出的动作，获取或者改变数据，需要提交到mutation中来修改state的数据。</p>
<h2 id="defineproperty和proxy区别"><a href="#defineproperty和proxy区别" class="headerlink" title="defineproperty和proxy区别"></a>defineproperty和proxy区别</h2><p>完美监听到任何方式数据改变</p>
<p>vue在实例初始化时遍历data中的所有属性，并使用object.defineproperty把这些属性全部转为getter/setter。这样当追踪数据发生变化时，setter会被自动调用。添加或删除对象的属性时vue检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能劫持对象的属性，因此需要对每个对象的每个属性进行遍历，vue2通过递归+遍历data对象来实现对数据的监控，如果属性值也是对象，那么需要深度遍历，只能通过 $set来调用object.defineproperty处理。无法监控到数组下标和长度的变化，导致直接通过数组下标给数组设置值，不能实时响应。vue3使用proxy来监控数据的变化，proxy是es6提供，用来定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）proxy直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化。proxy可以监听数组变化。</p>
<p>proxy劫持整个对象，返回一个新对象，多种劫持操作。</p>
<p>vuex提供state数据，来驱动视图，视图通过dispatch派发action，在action中可以进一步做一些异步的操作。</p>
<h2 id="虚拟DOM、diff算法"><a href="#虚拟DOM、diff算法" class="headerlink" title="虚拟DOM、diff算法"></a>虚拟DOM、diff算法</h2><p>首先对将要插入到文档中的dom树结构进行分析，使用js对象将其表示出来，然后将整个js对象树保存下来，最后将dom片段插入到文档中。当页面的状态发生改变，需要对页面的dom结构进行调整的时候，首先根据变更的状态，重新构建一颗对象树，然后将这棵新的对象树与旧的对象树进行比较，记录下两棵树的差异。最后将记录的有差异的地方应用到真正的dom树中，这样视图就更新了。</p>
<p>diff：首先对比节点本身，判断是否为同一节点，如果不为相同节点则删除该节点重新创建节点进行替换。如果为相同节点，就进行pathVnode，判断如何对该节点的子节点进行处理，先判断如果新的children没有子节点，将旧的子节点移除。如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作。</p>
<h2 id="key作用"><a href="#key作用" class="headerlink" title="key作用"></a>key作用</h2><p>用于管理可复用的元素，会尽可能高效渲染元素，key是给每一个vnode的唯一id，也是diff的一种优化策略，根据key更准确更快的找到对应的vnode节点，更高效对比虚拟dom中每个节点是否是相同节点，相同就复用，不同就删除旧的创建新的。</p>
<h2 id="route和router区别"><a href="#route和router区别" class="headerlink" title="route和router区别"></a>route和router区别</h2><p>route：路由信息对象，包括path，params、hash、query、fullpath等路由信息参数，相当于当前正在跳转的路由对象。</p>
<p>router：路由实例对象，包括路由跳转方法（push、go）钩子等，为vuerouter实例，相当于全局路由器对象，有很多属性和子对象，this.$router.push</p>
<h2 id="scoped原理"><a href="#scoped原理" class="headerlink" title="scoped原理"></a>scoped原理</h2><p>scoped通过在dom结构以及css样式上添加唯一不重复的标记，data-v-hash的方式，以保证唯一（通过postcss转译）达到样式私有模块化的目的。给html的dom节点加一个不重复的data属性，表示唯一性。每句css选择器末尾（编译后生成的css语句）加一个当前组件的data属性选择器私有化样式。</p>
<h2 id="项目中图片优化"><a href="#项目中图片优化" class="headerlink" title="项目中图片优化"></a>项目中图片优化</h2><p>小图使用base64，多个图标文件整合到一张图片中、对于能够显示webP格式的浏览器尽量使用webp格式。因为具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点兼容性不好</p>
<h2 id="webpack优化性能"><a href="#webpack优化性能" class="headerlink" title="webpack优化性能"></a>webpack优化性能</h2><p>压缩代码：删除多余的代码、注释、简化代码的写法。利用uglifyJsPlugin和parallelUglifyPlugin来压缩js文件，利用cssnano（css-loader minimize）来压缩css</p>
<p>利用cdn加速，构建过程中，将引用的静态资源路径修改为cdn上对应的路径</p>
<p>将代码中永远不会走到的片段删除掉，通过在启动webpack时追加参数–optimize-minimize来实现</p>
<p>CodeSplitting:将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存<br>提取公共第三⽅库:SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</p>
<p>babel-loader用include和exclude来避免不必要的转译（node-modules）</p>
<p>缓存当前转译的js文件，设置loader：babal-loader?cacheDirectory=true</p>
<h2 id="常用loader"><a href="#常用loader" class="headerlink" title="常用loader"></a>常用loader</h2><p>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对URL </p>
<p>去引⽤输出的⽂件 </p>
<p>url-loader：和file-loader类似，但是能在⽂件很⼩的情况下以</p>
<p>base64的⽅式把⽂件内容注⼊到代码中去 </p>
<p>source-map-loader：加载额外的SourceMap⽂件，以⽅便断点调</p>
<p>试 </p>
<p>image-loader：加载并且压缩图⽚⽂件 </p>
<p>babel-loader：把ES6转换成ES5 </p>
<p>css-loader：加载CSS，⽀持模块化、压缩、⽂件导⼊等特性 </p>
<p>style-loader：把CSS代码注⼊到JavaScript中，通过DOM操作</p>
<p>去加载CSS。 </p>
<p>eslint-loader：通过ESLint检查JavaScript代码 </p>
<p>注意：在Webpack中，loader的执行顺序是从右向左执行的。因为</p>
<p>webpack选择了compose这样的函数式编程方式，这种方式的表达式</p>
<p>执行是从右向左的。</p>
<h2 id="常见plugin"><a href="#常见plugin" class="headerlink" title="常见plugin"></a>常见plugin</h2><p>define-plugin：定义环境变量 </p>
<p>html-webpack-plugin：简化html⽂件创建</p>
<p>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 </p>
<p>webpack-parallel-uglify-plugin:多核压缩，提⾼压缩速度 </p>
<p>webpack-bundle-analyzer:可视化webpack输出⽂件的体积 </p>
<p>mini-css-extract-plugin:CSS提取到单独的⽂件中，⽀持按需加</p>
<p>载</p>
<h2 id="Loader和Plugin的不同？"><a href="#Loader和Plugin的不同？" class="headerlink" title="Loader和Plugin的不同？"></a><strong>Loader和Plugin的不同？</strong></h2><p>不同的作⽤:Loader直译为”加载器”。Webpack将⼀切⽂件视为模块，但是webpack原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到loader。所以Loader的作⽤是让webpack拥有了加载和解析⾮JavaScript⽂件的能⼒。 </p>
<p>Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack 具有更多的灵活性。在Webpack运⾏的⽣命周期中会⼴播出许多事件，Plugin可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果。 不同的⽤法:Loader在module.rules中配置，也就是说他作为模块的解析规则⽽存在。类型为数组，每⼀项都是⼀个Object，⾥⾯描述了对于什么类型的⽂件（test），使⽤什么加载(loader)和使⽤的参数（options） Plugin在plugins中单独配置。类型为数组，每⼀项是⼀个plugin 的实例，参数都通过构造函数传⼊。</p>
<h2 id="前端优化性能方法"><a href="#前端优化性能方法" class="headerlink" title="前端优化性能方法"></a>前端优化性能方法</h2><p>减少http请求数</p>
<p>从设计层面简化页面</p>
<p>合理设置http缓存</p>
<p>资源合并与压缩</p>
<p>合并css图片</p>
<p>多图片网页使用图片懒加载</p>
<p>js减少闭包使用</p>
<p>尽量合并css和js文件</p>
<p>尽量使用字体图标或者svg，代替png等格式</p>
<p>减少对dom的操作</p>
<p>尽可能使用事件委托来处理事件绑定的操作</p>
<p>防抖与节流的使用</p>
<p>资源懒加载、预加载</p>
<p>开启nginx gzip压缩</p>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2022/09/11/nodejs/" rel="next" title="nodejs">
                  <i class="fa fa-chevron-left"></i> nodejs
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2023/03/23/react复习笔记/" rel="prev" title="面试题整理">
                  面试题整理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#整理"><span class="nav-number">1.</span> <span class="nav-text">整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp与udp的区别"><span class="nav-number">1.1.</span> <span class="nav-text">tcp与udp的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-in-—–-for-of"><span class="nav-number">1.2.</span> <span class="nav-text">for in —– for of</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#foreach-—–map"><span class="nav-number">1.3.</span> <span class="nav-text">foreach —–map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深浅拷贝"><span class="nav-number">1.4.</span> <span class="nav-text">深浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组去重"><span class="nav-number">1.5.</span> <span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">1.6.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-number">1.7.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露"><span class="nav-number">1.7.1.</span> <span class="nav-text">内存泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.8.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指向"><span class="nav-number">1.9.</span> <span class="nav-text">this指向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eventLoop"><span class="nav-number">1.10.</span> <span class="nav-text">eventLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么js设计为单线程"><span class="nav-number">1.11.</span> <span class="nav-text">为什么js设计为单线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入URL到页面加载的过程"><span class="nav-number">1.12.</span> <span class="nav-text">输入URL到页面加载的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get和post区别"><span class="nav-number">1.13.</span> <span class="nav-text">get和post区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP状态码"><span class="nav-number">1.14.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件流"><span class="nav-number">1.15.</span> <span class="nav-text">事件流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#防抖和节流"><span class="nav-number">1.16.</span> <span class="nav-text">防抖和节流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型和原型链"><span class="nav-number">1.17.</span> <span class="nav-text">原型和原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块化"><span class="nav-number">1.18.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储的方式"><span class="nav-number">1.19.</span> <span class="nav-text">存储的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generator函数"><span class="nav-number">1.20.</span> <span class="nav-text">generator函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue基本原理"><span class="nav-number">1.21.</span> <span class="nav-text">vue基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向数据绑定原理"><span class="nav-number">1.22.</span> <span class="nav-text">双向数据绑定原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mvvm和mvc、mvp区别"><span class="nav-number">1.23.</span> <span class="nav-text">mvvm和mvc、mvp区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick"><span class="nav-number">1.24.</span> <span class="nav-text">nextTick</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单页应用和多页应用理解"><span class="nav-number">1.25.</span> <span class="nav-text">单页应用和多页应用理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue中封装的数组方法，如何实现页面更新"><span class="nav-number">1.26.</span> <span class="nav-text">vue中封装的数组方法，如何实现页面更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#某一个属性的值发生改变后，视图会立即同步执行渲染吗"><span class="nav-number">1.27.</span> <span class="nav-text">某一个属性的值发生改变后，视图会立即同步执行渲染吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件改变父组件的数据"><span class="nav-number">1.28.</span> <span class="nav-text">子组件改变父组件的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React和Vue的理解"><span class="nav-number">1.29.</span> <span class="nav-text">React和Vue的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue模板编译原理"><span class="nav-number">1.30.</span> <span class="nav-text">vue模板编译原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mvvm优缺点"><span class="nav-number">1.31.</span> <span class="nav-text">mvvm优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if、v-for"><span class="nav-number">1.32.</span> <span class="nav-text">v-if、v-for</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件化理解"><span class="nav-number">1.33.</span> <span class="nav-text">组件化理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由的hash和history"><span class="nav-number">1.34.</span> <span class="nav-text">路由的hash和history</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex"><span class="nav-number">1.35.</span> <span class="nav-text">vuex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defineproperty和proxy区别"><span class="nav-number">1.36.</span> <span class="nav-text">defineproperty和proxy区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟DOM、diff算法"><span class="nav-number">1.37.</span> <span class="nav-text">虚拟DOM、diff算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key作用"><span class="nav-number">1.38.</span> <span class="nav-text">key作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#route和router区别"><span class="nav-number">1.39.</span> <span class="nav-text">route和router区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scoped原理"><span class="nav-number">1.40.</span> <span class="nav-text">scoped原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目中图片优化"><span class="nav-number">1.41.</span> <span class="nav-text">项目中图片优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack优化性能"><span class="nav-number">1.42.</span> <span class="nav-text">webpack优化性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用loader"><span class="nav-number">1.43.</span> <span class="nav-text">常用loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见plugin"><span class="nav-number">1.44.</span> <span class="nav-text">常见plugin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader和Plugin的不同？"><span class="nav-number">1.45.</span> <span class="nav-text">Loader和Plugin的不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端优化性能方法"><span class="nav-number">1.46.</span> <span class="nav-text">前端优化性能方法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="WayneLee"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">WayneLee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/waynelee7" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;waynelee7" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail &amp;rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WayneLee</span>
</div>
  <!--<div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  -->
<!--
  <span class="post-meta-divider">|</span>
-->
  <!-- <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div> 
  -->
<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("10/11/2018 00:00:00");//
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "网站已运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>


        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":250,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
