<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="李凤伟的小站" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

  <meta name="description" content="HTML+CSS弹性布局12345678910111213141516171819202122232425262728属性:属性值justify-content	flex-start（默认值）：左对齐    flex-end：右对齐    center： 居中    space-between：两端对齐，项目之间的间隔都相等。    space-around：每个项目两侧的间隔相等。所以，项目之间">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://yoursite.com/2022/09/19/前端面试题/index.html">
<meta property="og:site_name" content="李凤伟的小站">
<meta property="og:description" content="HTML+CSS弹性布局12345678910111213141516171819202122232425262728属性:属性值justify-content	flex-start（默认值）：左对齐    flex-end：右对齐    center： 居中    space-between：两端对齐，项目之间的间隔都相等。    space-around：每个项目两侧的间隔相等。所以，项目之间">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img.jbzj.com/file_images/article/202003/20200304101814144.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20211009154113599.png">
<meta property="og:image" content="c:/Users/Administrator/Desktop/1034346-20170329150734545-432760222.jpg">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20211012133533831.png">
<meta property="og:updated_time" content="2022-09-19T14:46:58.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试题">
<meta name="twitter:description" content="HTML+CSS弹性布局12345678910111213141516171819202122232425262728属性:属性值justify-content	flex-start（默认值）：左对齐    flex-end：右对齐    center： 居中    space-between：两端对齐，项目之间的间隔都相等。    space-around：每个项目两侧的间隔相等。所以，项目之间">
<meta name="twitter:image" content="https://img.jbzj.com/file_images/article/202003/20200304101814144.png">

<link rel="canonical" href="http://yoursite.com/2022/09/19/前端面试题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>前端面试题 | 李凤伟的小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>
<!-- 添加动态线条背景 -->

<script type="text/javascript" color="0,0,0" opacity='1.0'  src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
   <a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李凤伟的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/19/前端面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WayneLee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李凤伟的小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 21:39:21 / 修改时间：22:46:58" itemprop="dateCreated datePublished" datetime="2022-09-19T21:39:21+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h1><h2 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">属性:属性值</span><br><span class="line">justify-content</span><br><span class="line">	flex-start（默认值）：左对齐</span><br><span class="line">    flex-end：右对齐</span><br><span class="line">    center： 居中</span><br><span class="line">    space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br><span class="line">    </span><br><span class="line">align-items</span><br><span class="line">	flex-start：交叉轴的起点对齐。</span><br><span class="line">    flex-end：交叉轴的终点对齐。</span><br><span class="line">    center：交叉轴的中点对齐。</span><br><span class="line">    baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br><span class="line">    </span><br><span class="line">flex-direction</span><br><span class="line">	row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">    row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">    column：主轴为垂直方向，起点在上沿。</span><br><span class="line">    column-reverse：主轴为垂直方向，起点在下沿。</span><br><span class="line">    </span><br><span class="line">flex-wrap</span><br><span class="line">	nowrap（默认）：不换行。</span><br><span class="line">	wrap：换行，第一行在上方。</span><br><span class="line">	wrap-reverse：换行，第一行在下方。</span><br><span class="line">	</span><br><span class="line">flex-flow</span><br><span class="line">	flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span><br></pre></td></tr></table></figure><a id="more"></a>
<h2 id="1-块元素垂直居中"><a href="#1-块元素垂直居中" class="headerlink" title="1  块元素垂直居中"></a>1  块元素垂直居中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  弹性布局</span><br><span class="line">display:flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2  定位</span><br><span class="line">position: absolute;</span><br><span class="line">left:50%;</span><br><span class="line">top:50%;</span><br><span class="line">transform:translate(-50%,-50%)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3  定位</span><br><span class="line">position:absolute;</span><br><span class="line">left:0;right:0;</span><br><span class="line">top:0;bottom:0;</span><br><span class="line">margin:auto;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4  转行内块元素 </span><br><span class="line">display:inline-block</span><br><span class="line">text-align:center;</span><br><span class="line">line-height:100px;</span><br><span class="line">height:100px;</span><br></pre></td></tr></table></figure>
<h2 id="2-盒模型和怪异盒模型"><a href="#2-盒模型和怪异盒模型" class="headerlink" title="2  盒模型和怪异盒模型"></a>2  盒模型和怪异盒模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通盒模型     content+ paddign*2 + border*2 +margin*2 =  普通盒模型</span><br><span class="line">怪异盒模型     contnet + margin*2   = 怪异盒模型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.两者区别</span><br><span class="line"></span><br><span class="line">标准盒模型总宽度 = width + 左右padding + 左右border + 左右margin</span><br><span class="line"></span><br><span class="line">标准盒模型总高度 = height + 上下padding + 上下border + 上下margin</span><br><span class="line"></span><br><span class="line">怪异盒模型总宽度 = width + 左右margin (width包含了padding和border)</span><br><span class="line"></span><br><span class="line">怪异盒模型总高度 = height + 上下margin (height包含了padding和border)</span><br><span class="line"></span><br><span class="line">注：当没有添加文档声明时，就会触发某些浏览器的怪异模式，如IE6</span><br><span class="line"></span><br><span class="line">2.如何将标准盒模型转换为怪异盒模型</span><br><span class="line"></span><br><span class="line">给给标准盒子加上这个属性：</span><br><span class="line"></span><br><span class="line">语法：box-sizing:border-box;</span><br><span class="line"></span><br><span class="line">注：box-sizing:content-box;  默认值</span><br></pre></td></tr></table></figure>
<h2 id="3-解决浮动塌陷"><a href="#3-解决浮动塌陷" class="headerlink" title="3  解决浮动塌陷"></a>3  解决浮动塌陷</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 万能清除浮动  :after</span><br><span class="line">2 overflow:hidden</span><br><span class="line">3 给父元素添加高度</span><br><span class="line">4 给父元素加边框</span><br><span class="line">5 给父元素加padding</span><br><span class="line">clear both</span><br><span class="line">6 最后面添加有个空的div  height：0  clear both</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法1: 给父元素加overflow:hidden;</span><br><span class="line">方法2: 在浮动元素下面加空div,并添加样式</span><br><span class="line">       div&#123;</span><br><span class="line">       	clear:both;</span><br><span class="line">       	height:0; </span><br><span class="line">       	overflow:hidden;</span><br><span class="line">       	&#125;</span><br><span class="line">方法3: 万能清除浮动法（在父元素的后面添加伪类选择器 :after）：</span><br><span class="line">    :after&#123;</span><br><span class="line">           	content: &apos;&apos;;</span><br><span class="line">           	clear: both;</span><br><span class="line">           	display:block;</span><br><span class="line">           	height:0;</span><br><span class="line">           	visibility:hidden;</span><br><span class="line">           	overflow: hidden;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-em-，rem-px-vw-vh"><a href="#4-em-，rem-px-vw-vh" class="headerlink" title="4 em ，rem , px,  vw,vh"></a>4 em ，rem , px,  vw,vh</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 em   根据父元素的倍数</span><br><span class="line">2 rem  根据根元素的倍数（根元素的font-size的大小）     （适配会根据rem来设定）  动态设置  html的font-size</span><br><span class="line">3 vw,vh   只适用于高版本浏览器  ie9以上   移动都可以用  【100%内核都是 -webkit-】</span><br><span class="line">4 px像素</span><br><span class="line">5 百分比   %</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 px就是像素，也是我们现在经常使用的基本单位，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。</span><br><span class="line">2 em参考物是父元素的font-size，默认字体大小是16px，所以1em不是固定值，因为它会继承父元素的字体大小</span><br><span class="line">3 rem参考物是相对于根元素，我们在使用时可以在根元素设置一个参考值即可，相对于em使用，减少很大运算工作量，例：html大小为10px，12rem就是120px。</span><br><span class="line">4 % 是相对于父元素的大小设定的比率。</span><br><span class="line">5 vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</span><br><span class="line">假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）</span><br><span class="line">6 vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</span><br><span class="line">假如浏览器的高度为500px，那么1vh就等于5px（500px/100）</span><br></pre></td></tr></table></figure>
<h2 id="5-边框一像素问题-✨"><a href="#5-边框一像素问题-✨" class="headerlink" title="5 边框一像素问题 ✨"></a>5 边框一像素问题 ✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tarnsfrom : scale(0.7)  缩放   css3转换</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">解决问题:移动端1像素变粗</span><br><span class="line">	为什么移动端CSS里面写了1px，实际上看起来比1px粗；了解设备物理像素和逻辑像素的同学应该很容易理解，其实这两个px的含义其实是不一样的，UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的`window.devicePixelRatio`来获取，也可以用媒体查询的`-webkit-min-device-pixel-ratio`来获取。当然，比例多少与设备相关。在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。</span><br><span class="line">解决方案:transform: scale(0.5) 方案，用高度1px的div充当边框</span><br><span class="line">     div &#123;</span><br><span class="line">            height: 1px;</span><br><span class="line">            background: #000;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 2倍屏 */</span><br><span class="line">        @media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123;</span><br><span class="line">            div &#123;</span><br><span class="line">                -webkit-transform: scaleY(0.5);</span><br><span class="line">                transform: scaleY(0.5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 3倍屏 */</span><br><span class="line">        @media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123;</span><br><span class="line">            div &#123;</span><br><span class="line">                -webkit-transform: scaleY(0.33);</span><br><span class="line">                transform: scaleY(0.33);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-安卓和iOS兼容问题-—-前端显示的兼容问题"><a href="#6-安卓和iOS兼容问题-—-前端显示的兼容问题" class="headerlink" title="6  安卓和iOS兼容问题 —- 前端显示的兼容问题"></a>6  安卓和iOS兼容问题 —- 前端显示的兼容问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">链接1   https://blog.csdn.net/Jkssns/article/details/103456913   </span><br><span class="line">1、😊IOS下input默认样式(圆角、阴影).</span><br><span class="line">解决方案</span><br><span class="line">input &#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">  border-radius: 0;</span><br><span class="line">  border: 1px #ccc solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、😊在IOS下页面滑动卡顿，Android没问题</span><br><span class="line">解决方案</span><br><span class="line">body &#123;-webkit-overflow-scrolling:touch; overflow-scrolling: touch;&#125;</span><br><span class="line"></span><br><span class="line">3、😊input type 改为button</span><br><span class="line">解决方案</span><br><span class="line">当input type为button，disabled为true，会出现背景色异常(其实就是禁用的样式)</span><br><span class="line">把input的disabled改为readonly  （只读）</span><br><span class="line">opacity：1</span><br><span class="line"></span><br><span class="line">4、😊input type=text切换到英文输入法IOS下的问题</span><br><span class="line">解决方案</span><br><span class="line">input添加autocapitalize属性 --- 自动大小写</span><br><span class="line">&lt;input class=&quot;SmallFour&quot; type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt;</span><br><span class="line"></span><br><span class="line">5、😊禁止数字自动识别为电话号码</span><br><span class="line">这个比较有用，因为一串数字在iphone的部分浏览器上会显示成蓝色，样式加成别的颜色也是不生效的。不是我亲测，在微信内部浏览器没问题，但是在safari上有问题，IOS系统版本12.1.4</span><br><span class="line">解决方案</span><br><span class="line">在HTML的head里面配置  format-detection格式检验</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line">6、😊input 的placeholder属性会使文本位置偏上</span><br><span class="line">解决方案</span><br><span class="line">line-height: （和input框的高度一样高）---pc端解决方法</span><br><span class="line">line-height：normal ---移动端解决方法</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">7、😊input type=number之后，pc端出现上下箭头</span><br><span class="line">解决方案</span><br><span class="line">input::-webkit-inner-spin-button &#123;</span><br><span class="line">  -webkit-appearance: none !important;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8、😊是图片填充到外层的框内，很好用，直接给图片添加样式。</span><br><span class="line">解决方案</span><br><span class="line">object-fit: cover;</span><br><span class="line">width:100%;</span><br><span class="line">height:100%;</span><br><span class="line"></span><br><span class="line">9、手机端按住不放 阻止浏览器默认响应事件 调试</span><br><span class="line">解决方案</span><br><span class="line">//clikMenu 你要点击的事件节点</span><br><span class="line">function touchendmovie(clikMenu)&#123;</span><br><span class="line">    var timeOutEvent = 0;</span><br><span class="line">    $(document).on(&apos;touchstart&apos;,clikMenu,function(e)&#123;</span><br><span class="line">        timeOutEvent = setTimeout(function()&#123;</span><br><span class="line">        //这里编写你要执行的事件 &#125;,300);</span><br><span class="line">        //这里设置长按响应时间</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;);</span><br><span class="line">    $(document).on(&apos;touchmove&apos;,clikMenu,function(e)&#123;</span><br><span class="line">        clearTimeout(timeOutEvent);</span><br><span class="line">        timeOutEvent = 0;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(document).on(&apos;touchend&apos;,clikMenu,function(e)&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        if(timeOutEvent != 0 )&#123;</span><br><span class="line">            console.log(&apos;这里是点击了一下&apos;); </span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(timeOutEvent); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">10、禁止复制、选中文本</span><br><span class="line">解决方案</span><br><span class="line">.el &#123;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -khtml-user-select: none;</span><br><span class="line">   user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-css预处理器"><a href="#7-css预处理器" class="headerlink" title="7 css预处理器"></a>7 css预处理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 sass  less</span><br><span class="line">  </span><br><span class="line">scss 是sass的升级版</span><br><span class="line">sass  不能直接被浏览器解析，需要编译成css才能用，其中提供了一些变量、循环等方法，类似于编程语言的特点，公司使用scss（有大括号），sass没有大括号，靠缩进</span><br></pre></td></tr></table></figure>
<h2 id="8-H5-新增新特性"><a href="#8-H5-新增新特性" class="headerlink" title="8 H5 新增新特性"></a>8 H5 新增新特性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  新增语义化标签 nav , header ,footer ,section、aside、article</span><br><span class="line">2  input 新增类型  email search  url  tel  number date ···</span><br><span class="line">3  视频video  音频audio</span><br><span class="line">4  canvas新增 --- 画布</span><br><span class="line">5  获取定位  谷歌浏览器不行（）  </span><br><span class="line">6  web存储   localStorage  sessionStorage    （indexdb 本地数据库）</span><br><span class="line">7  拖拽 ondrap</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/ainyi/p/9777841.html</span><br><span class="line">H5 新特性</span><br><span class="line">1. 语义化标签：header、footer、section、nav、aside、article</span><br><span class="line">2. 增强型表单：input 的多个 type</span><br><span class="line">3. 新增表单元素：datalist、keygen、output</span><br><span class="line">4. 新增表单属性：placehoder、required、min 和 max</span><br><span class="line">5. 音频视频：audio、video</span><br><span class="line">6. canvas</span><br><span class="line">7. 地理定位</span><br><span class="line">8. 拖拽</span><br><span class="line">9. 本地存储：localStorage - 没有时间限制的数据存储；sessionStorage - 针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除</span><br><span class="line">10. 新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause</span><br><span class="line">11. WebSocket：单个 TCP 连接上进行全双工通讯的协议</span><br></pre></td></tr></table></figure>
<h2 id="9-适配"><a href="#9-适配" class="headerlink" title="9 适配    *"></a>9 适配    <strong>*</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rem来适配 </span><br><span class="line">1  后期字体大小不适配  就用px</span><br><span class="line">2  rem插件    </span><br><span class="line">由于rem是根据根元素的font-size大小而定，所以根据浏览器当前的分辨率改变font-size的值，就可以用rem作为统一单位适配移动端</span><br><span class="line"></span><br><span class="line">第一种：</span><br><span class="line">1.rem适配没问题</span><br><span class="line">2.rem是根据根元素的大小（html的字体大小来计算）</span><br><span class="line">3.html&#123; font-size：10&#125; 1rem == 10px</span><br><span class="line">4.根据移动设备的像素比 dpr ，再根据设备的宽度，按照某种算法  动态设置html 的 font-size，然后页面大小会随着font-size大小改变而改变，通过onsize 动态设置</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">第4步：在媒体查询中@media-screen中，写了多个 根元素设置 html&#123;font-size&#125;</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">我们公司移动端一般不太那么严格去适配，我们公司宽度都用百分比%，字体大小直接用px,高的话用padding，不会写死高度</span><br><span class="line"></span><br><span class="line">第四种：</span><br><span class="line">1 宽度都用百分比</span><br><span class="line">2 高度还是用px</span><br><span class="line">3 webpack vue react  px2rem 直接能将你写的px转成rem</span><br></pre></td></tr></table></figure>
<h2 id="10-响应式布局✨"><a href="#10-响应式布局✨" class="headerlink" title="10 响应式布局✨"></a>10 响应式布局✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http://caibaojian.com/356.html</span><br><span class="line">1  😊不同的终端显示不同的布局   media</span><br><span class="line">2  😊不同分辨率显示布局一样 （视频）</span><br><span class="line"></span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">（user-scalable = no 属性能够解决 iPad 切换横屏之后触摸才能回到具体尺寸的问题。 ）</span><br><span class="line"></span><br><span class="line">Media Queries 是响应式设计的核心。 它根据条件告诉浏览器如何为指定视图宽度渲染页面。假如一个终端的分辨率小于 980px，那么可以这样写：</span><br><span class="line"></span><br><span class="line">@media screen and (max-width: 980px) &#123;</span><br><span class="line">  #head &#123; … &#125;</span><br><span class="line">  #content &#123; … &#125;</span><br><span class="line">  #footer &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 😊设置多种试图宽度</span><br><span class="line">假如我们要设定兼容 iPad 和 iPhone 的视图，那么可以这样设置：</span><br><span class="line">/** iPad **/</span><br><span class="line">@media only screen and (min-width: 768px) and (max-width: 1024px) &#123;&#125;</span><br><span class="line">/** iPhone **/</span><br><span class="line">@media only screen and (min-width: 320px) and (max-width: 767px) &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width: 990px) and (min-width: 768px) &#123;</span><br><span class="line">   css样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-定位"><a href="#11-定位" class="headerlink" title="11 定位"></a>11 定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">relative1: 占据文档流,占位置</span><br><span class="line">2: 参考自身加载在页面中的位置</span><br><span class="line">用途：主要给绝对定位提供包含块</span><br><span class="line"></span><br><span class="line">absolute 绝对定位</span><br><span class="line">1: 💖脱离文档流,不占位置</span><br><span class="line">2: 💖默认参考html的00点(浏览器零点)</span><br><span class="line">3: 💖如果有父级,且父级有定位,那就参考父级元素(默认定位除外) 相当于给子元素指定了参考物</span><br><span class="line">用途：网页上需要重叠的地方可以使用绝对定位</span><br><span class="line"></span><br><span class="line">fixed：这种定位方式是相对于整个文档的，只需设置它相对于各个方向的偏移值，就可以将该元素固定在页面固定的位置，通常用来显示一些提示信息，脱离文档流；</span><br><span class="line"></span><br><span class="line">sticky </span><br><span class="line">1: 💖脱离文档流,不占位</span><br><span class="line">2: 💖元素固定在页面中不随着页面滚动而滚动，会受滚动条会影响。</span><br><span class="line">3: 💖参考浏览器的00点</span><br><span class="line">用途：网页上跟随着视口移动的元素（例如，回到顶部）</span><br><span class="line"></span><br><span class="line">static： </span><br><span class="line">1: 页面达到一定高度时,脱离文档流</span><br><span class="line">2: 效果是吸附浏览器顶部</span><br><span class="line"></span><br><span class="line">1 粘性定位</span><br><span class="line">2 定位的时候 --- 如果父元素设置了transfrom，子元素的fixed定位会失效</span><br><span class="line">3 定位元素层次关系	z-index</span><br></pre></td></tr></table></figure>
<h2 id="12-iframe"><a href="#12-iframe" class="headerlink" title="12 iframe"></a>12 iframe</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">嵌入页面来使用  &lt;iframe src=&quot;www.baidu.com&quot; &gt;&lt;/iframe&gt;</span><br><span class="line">用来跨域  页面与页面之间的跨域访问</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-javascript-数据类型"><a href="#1-javascript-数据类型" class="headerlink" title="1   javascript 数据类型"></a>1   javascript 数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">基本类型  String (显示)  Number(运算)  Boolean(判断)  Undefined(声明未赋值)  Null(对象的空) Symbol(做键值)</span><br><span class="line">引用类型  Object Array Function</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">基本类型存在  栈中   用完就销毁</span><br><span class="line">引用类型      堆中   不会自动销毁</span><br><span class="line"></span><br><span class="line">引用赋值和浅拷贝和深拷贝</span><br><span class="line"></span><br><span class="line">引用赋值   就是 =   引用同一个地址  所有如果改变某个属性  所有引用都改变</span><br><span class="line">浅拷贝   只拷贝一层   [...arr] &#123;...obj&#125;</span><br><span class="line">深拷贝   遍历对象进行递归 ， JSON.stringify + JSON.parse ,  immutable.js</span><br><span class="line"></span><br><span class="line">遍历对象  1、 for(let key in obj)&#123;</span><br><span class="line">              console.log(key + &apos;---&apos; + obj[key])</span><br><span class="line">          &#125;</span><br><span class="line">         2、1）、Object.keys（obj）     数组的key值组成的数组</span><br><span class="line">		    2）、Object.values（obj）   数组的value值组成的数组</span><br><span class="line">		    </span><br><span class="line">typeof  判断基本类型  </span><br><span class="line"></span><br><span class="line">所有的引用类型 用 typeof 都返回 &apos;object&apos;</span><br><span class="line"></span><br><span class="line">如果判断引用类型  instanceof   实例与构造函数之间关系</span><br><span class="line"></span><br><span class="line">arr instancof Array</span><br><span class="line">fn instanceof Function</span><br></pre></td></tr></table></figure>
<h2 id="for…in和for…of区别💖💖"><a href="#for…in和for…of区别💖💖" class="headerlink" title="for…in和for…of区别💖💖"></a>for…in和for…of区别💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.for...in 可以遍历对象 for...of 不能遍历对象</span><br><span class="line">2.for...in 遍历数组得到数组的下标，for...of遍历的数组得到数组的元素</span><br></pre></td></tr></table></figure>
<h2 id="forEach和map的区别💖💖"><a href="#forEach和map的区别💖💖" class="headerlink" title="forEach和map的区别💖💖"></a>forEach和map的区别💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.写法</span><br><span class="line">2.返回值：</span><br><span class="line">forEach()没有返回值，不可以链式调用，forEach()允许callback更改原始数组的元素</span><br><span class="line">map()返回一个新数组，原数组不会改变。</span><br><span class="line">3.没有办法终止或者跳出forEach()循环，除非抛出异常</span><br></pre></td></tr></table></figure>
<h2 id="2-深拷贝、浅拷贝、引用赋值的区别💖💖"><a href="#2-深拷贝、浅拷贝、引用赋值的区别💖💖" class="headerlink" title="2  深拷贝、浅拷贝、引用赋值的区别💖💖"></a>2  深拷贝、浅拷贝、引用赋值的区别💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">赋值是将某一数值或对象赋给某个变量的过程，分为：</span><br><span class="line">   1、基本数据类型：赋值，赋值之后两个变量互不影响</span><br><span class="line">   2、引用数据类型：赋**址**，两个变量具有相同的引用，指向同一个对象，相互之间有影响</span><br><span class="line">   </span><br><span class="line">浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。（...  object.assign)</span><br><span class="line"></span><br><span class="line">   深拷贝：深拷贝不会拷贝引用类型的引用，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突. (json, arr.map, arr.filter)</span><br></pre></td></tr></table></figure>
<h4 id><a href="#" class="headerlink" title></a><img src="https://img.jbzj.com/file_images/article/202003/20200304101814144.png" alt="20200304101814144.png"></h4><h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3  排序"></a>3  排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000016286789 </span><br><span class="line">sort排序  冒泡排序  选择排序</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">1.sort排序</span><br><span class="line">按升序排列</span><br><span class="line">arr.sort(</span><br><span class="line">    function(n1,n2)&#123;</span><br><span class="line">    	return n1-n2</span><br><span class="line">&#125;)</span><br><span class="line">按降序排列</span><br><span class="line">arr.sort(</span><br><span class="line">	function(n1,n2)&#123;</span><br><span class="line">		return n2-n1</span><br><span class="line">&#125;)</span><br><span class="line">2.冒泡排序</span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[j], arr[i]] = [arr[i], arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3.选择排序  将最大或者最小的数放在最前面一个一个排</span><br><span class="line">function selectSort(arr) &#123;</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var min = i</span><br><span class="line">        for (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                min = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i != min) &#123;</span><br><span class="line">            [arr[min], arr[i]] = [arr[i], arr[min]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.快速排序</span><br><span class="line">function quickSort(arr)&#123;</span><br><span class="line">  qSort(0, arr.length - 1);</span><br><span class="line">  return arr;</span><br><span class="line">  function qSort(left, right)&#123;</span><br><span class="line">    if (left &gt;= right)//两个数相遇则结束该轮排序</span><br><span class="line">      return;</span><br><span class="line">    var key = arr[left];//取最左边的元素作为标识数</span><br><span class="line">    var i = left;</span><br><span class="line">    var j = right;</span><br><span class="line">    while (i != j)&#123;//两个数相遇则结束该轮排序</span><br><span class="line">      while (i != j &amp;&amp; arr[j] &gt;= key) j--;//j前移</span><br><span class="line">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class="line">      while (i != j &amp;&amp; arr[i] &lt;= key) i++;//i后移</span><br><span class="line">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(left, j - 1);//对标识数前面的数继续该方法排序</span><br><span class="line">    qSort(j + 1, right);//对标识数后面的数继续该方法排序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-去重-（数组方法indexOf、includes、splice和set）💖💖"><a href="#4-去重-（数组方法indexOf、includes、splice和set）💖💖" class="headerlink" title="4 去重  （数组方法indexOf、includes、splice和set）💖💖"></a>4 去重  （数组方法indexOf、includes、splice和set）💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/lewiscutey/p/8269567.html</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、💖可以用两层循环比较数组中的元素，相等的话用 arr.splice(j, 1); 色pe李思  删除后面的那个</span><br><span class="line"></span><br><span class="line">2、💖indexOf (下标/-1)</span><br><span class="line">新建一个空的结果数组，for 循环原数组，用indexOf判断结果数组是否存在当前元素（存在返回下标，不存在返回-1），如果有相同的值则跳过，不相同则push进数组。</span><br><span class="line"></span><br><span class="line">3、💖includes (true/false)</span><br><span class="line">也是新建一个空的结果数组，用array.includes(arr[i])判断新数组中是否包含了原数组中的某个元素，如果包括了返回true，不包括返回false，当false的时候，将这个元素push到新数组中</span><br><span class="line"></span><br><span class="line">💖Set()方法去重(ES6新增)</span><br><span class="line"></span><br><span class="line">1、💖数组去重方法（使用Array.from）：</span><br><span class="line"></span><br><span class="line">let arr = [12,43,23,43,68,12];</span><br><span class="line">console.log( new Set(arr));//结果输出的是一个对象</span><br><span class="line"></span><br><span class="line">//使用Array.from转成数组</span><br><span class="line"></span><br><span class="line">let item = Array.from(new Set(arr));</span><br><span class="line"></span><br><span class="line">2、💖数组去重方法（使用...扩展运算符）：</span><br><span class="line"></span><br><span class="line">let arr = [12,43,23,43,68,12];</span><br><span class="line">let item = [...new Set(arr)];</span><br></pre></td></tr></table></figure>
<h2 id="5-闭包-💖💖✨"><a href="#5-闭包-💖💖✨" class="headerlink" title="5  闭包    **💖💖✨"></a>5  闭包    **💖💖✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">闭包的作用是 声明局部变量供外部使用，正常来讲，函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量，但是我们又需要使用函数内部的局部变量，所以就出现了闭包，函数套函数就可以称为一个简单的闭包。</span><br><span class="line"></span><br><span class="line">1  💖声明局部变量供外部使用，防止变量污染全局 （如果不 return，你就无法使用这个闭包。把 return bar 改成 window.bar = bar 也是一样的，只要让外面可以访问到这个 bar 函数就行了。）</span><br><span class="line">2  💖闭包因为有函数  所以会存在堆中   可以存储值   一般会用来做缓存</span><br><span class="line">💖缺点  在IE中过多的引用可能导致内存泄露  </span><br><span class="line">💖解决方案  手动清除，在退出函数之前，将不使用的局部变量全部删除（设置为null）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">💖垃圾回收机制：</span><br><span class="line">在Javascript中，垃圾回收机制能够回收垃圾，释放内存。垃圾就是没有被引用的对象,或者是几个对象相互引用形成一个闭环,还有从根上访问不到也是垃圾.他们就会被清除.</span><br><span class="line"></span><br><span class="line">根：一组基本的可达值,他们不会被删除</span><br><span class="line">	1.全局变量</span><br><span class="line">	2.本地函数的参数和变量</span><br><span class="line">	3.当前在调用链上的其他函数的参数和变量</span><br><span class="line"></span><br><span class="line">通常用采用的垃圾回收有两种方法：💖标记清除、引用计数。</span><br><span class="line"></span><br><span class="line">标记清除方法：</span><br><span class="line">垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。然后会把环境中已经无法访问的变量再次加上标记。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间</span><br><span class="line">　　</span><br><span class="line">引用计数（不太常用）</span><br><span class="line">引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，　则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。</span><br><span class="line"></span><br><span class="line">3 写法 </span><br><span class="line">	💖函数嵌套</span><br><span class="line">	💖内部函数会作为外部函数的返回值</span><br><span class="line">	💖内部函数因为作用域链可以访问外部函数的变量 会做为内部函数的返回值</span><br><span class="line"></span><br><span class="line">代码 </span><br><span class="line">  function fn1()&#123;</span><br><span class="line">          var a = 10</span><br><span class="line">          return function()&#123;</span><br><span class="line">              return  a</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">💖闭包概念：</span><br><span class="line">1. 有一个 A 函数，再 A 函数内部返回一个 B 函数</span><br><span class="line">2. 再 A 函数外部有变量引用这个 B 函数</span><br><span class="line">3. B 函数内部访问着 A 函数内部的私有变量</span><br><span class="line">以上三个条件缺一不可</span><br><span class="line"></span><br><span class="line">💖闭包特点：</span><br><span class="line">1. 💖作用域空间不销毁</span><br><span class="line">- 优点： 因为不销毁，变量页不会销毁，增加了变量的生命周期</span><br><span class="line">- 缺点： 因为不销毁，会一直占用内存，多了以后就会导致内存溢出</span><br><span class="line">2. 💖可以利用闭包访问再一个函数外部访问函数内部的变量</span><br><span class="line">- 优点： 可以再函数外部访问内部数据</span><br><span class="line">- 缺点： 必须要时刻保持引用，导致函数执行栈不被销毁</span><br><span class="line">3. 💖保护私有变量</span><br><span class="line">- 优点： 可以把一些变量放在函数里面，不会污染全局</span><br><span class="line">- 缺点： 要利用闭包函数才能访问，不是很方便</span><br><span class="line">代码：</span><br><span class="line">function fun() &#123;</span><br><span class="line">    var count = 1;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        count++</span><br><span class="line">        console.log(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn = fun()</span><br><span class="line">fn()  /* 2 */</span><br><span class="line">fn()  /* 3 */</span><br></pre></td></tr></table></figure>
<h2 id="6-面向对象-—-封装"><a href="#6-面向对象-—-封装" class="headerlink" title="6  面向对象    — 封装"></a>6  面向对象    — 封装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">面向对象编程，使用构造函数构造对象</span><br><span class="line">1. 先书写一个构造函数</span><br><span class="line">2. 在构造函数内向对象添加一些成员</span><br><span class="line">3.使用这个构造函数创造一个对象（和 new 连用）</span><br><span class="line">4.构造函数可以创建对象，并且创建一个带有属性和方法的对象</span><br><span class="line"></span><br><span class="line">5.面向对象就是要想办法找到一个有属性和方法的对象</span><br><span class="line">6.面向对象就是我们自己制造构造函数的过程</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">// 1. 先创造一个构造函数</span><br><span class="line">function Person(name, gender) &#123;</span><br><span class="line">  this.age = 18</span><br><span class="line">  this.name = name</span><br><span class="line">  this.gender = gender</span><br><span class="line">&#125;</span><br><span class="line">// 2. 使用构造函数创建对象</span><br><span class="line">var p1 = new Person(&apos;Jack&apos;, &apos;man&apos;)</span><br><span class="line">var p2 = new Person(&apos;Rose&apos;, &apos;woman&apos;)</span><br><span class="line">// 3. 使用原型向构造函数添加方法：</span><br><span class="line">Person.prototype.sayHi = function () &#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">p1.sayHi()</span><br><span class="line">// 4. 实例化对象的 __proto__ 和所属的构造函数的 prototype 是一个对象空间</span><br><span class="line">console.log(p1.__proto__ === Person.prototype) // true</span><br><span class="line">// 5. p1和p2都是Person的实例,p1.__proto__ 和 p2.__proto__ 指向的都是 Person.prototype,两个实例化对象p1和p2执行的是同一个方法。即构造函数原型Person.prototype里的方法。</span><br><span class="line">console.log(p1.sayHi === p2.sayHi) // true</span><br></pre></td></tr></table></figure>
<h2 id="8-继承-继承是为了优化代码，优化性能✨"><a href="#8-继承-继承是为了优化代码，优化性能✨" class="headerlink" title="8  继承  继承是为了优化代码，优化性能✨"></a>8  继承  继承是为了优化代码，优化性能✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">组合继承 = 借用构造函数继承 + 原型对象继承</span><br><span class="line"></span><br><span class="line">多个类中存在相同的属性和行为时，将这些内容放到单独一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。</span><br><span class="line"></span><br><span class="line">多个类可以称为子类，单独这个类称为父类或者超类，基类等。</span><br><span class="line"></span><br><span class="line">子类可以直接访问父类中的非私有的属性和行为。</span><br><span class="line"></span><br><span class="line">几种继承方式：</span><br><span class="line">1.💖通过extends关键字让类与类之间产生继承关系。（es6）</span><br><span class="line">例如： class B extedns A &#123;  &#125;      // B 继承了 A 的属性和方法</span><br><span class="line"></span><br><span class="line">2.💖原型链继承：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个引用类型的实例   Student.prototype = new Person()</span><br><span class="line"></span><br><span class="line">3.💖构造函数继承：有两个函数，在子类型构造函数的内部调用另一个构造函数的方法，通过使用apply()和call()方法改变this指向，可以在新创建的对象上执行构造函数</span><br><span class="line">function Student() &#123;</span><br><span class="line">    Person.call(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.💖组合继承：将原型链和借用构造函数技术组合到一起。使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性</span><br><span class="line"></span><br><span class="line">5.💖原型式继承（使用Object.create()方法）</span><br><span class="line"></span><br><span class="line"> 二、继承的好处？💖💖</span><br><span class="line"></span><br><span class="line">1、提高了代码的复用性。</span><br><span class="line"></span><br><span class="line">2、继承的出现让类与类之间产生了关系，提供了多态的前提。</span><br><span class="line"></span><br><span class="line"> //超类  父类   假继承</span><br><span class="line"> function A(name, age) &#123;</span><br><span class="line"> 	this.name = name;</span><br><span class="line"> 	this.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> A.prototype.eat = function () &#123;</span><br><span class="line">	 console.log(this.name + &quot;吃 &quot; + this.name);</span><br><span class="line"> &#125;;</span><br><span class="line">Dog.prototype = new A();</span><br><span class="line">Cat.prototype = new A();</span><br><span class="line"> function Dog(name, age) &#123;</span><br><span class="line"> 		A.call(this, name, age);</span><br><span class="line"> &#125;</span><br><span class="line"> function Cat(name, age) &#123;</span><br><span class="line">	 A.call(this, name, age);</span><br><span class="line"> &#125;</span><br><span class="line"> var dog1 = new Dog(&quot;小白&quot;, 3);</span><br><span class="line"> var dog2 = new Dog(&quot;小白1&quot;, 31);</span><br><span class="line"> var cat1 = new Cat(&quot;喵咪&quot;, 3);</span><br><span class="line"> console.log(dog1, cat1);</span><br><span class="line"> dog1.eat();</span><br><span class="line"> cat1.eat();</span><br><span class="line">console.log(dog1.eat === dog2.eat); //true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.组合继承</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &apos;Jack&apos;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = function () &#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function Student() &#123;</span><br><span class="line">    Person.call(this)</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = new Person()</span><br><span class="line">var s1 = new Student()</span><br><span class="line"></span><br><span class="line">2.ES6类class的继承</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &apos;Jack&apos;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = function () &#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 下面表示创造一个 Student 类，继承自 Person 类</span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // 必须在 constructor 里面执行一下 super() 完成继承 </span><br><span class="line">        super()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var s1 = new Student()</span><br><span class="line">3 属性继承 -- 只继承属性不继承方法</span><br><span class="line">4 原型继承  -- 把自己完全变成父亲</span><br></pre></td></tr></table></figure>
<h2 id="9-this的指向💖💖"><a href="#9-this的指向💖💖" class="headerlink" title="9  this的指向💖💖"></a>9  this的指向💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">普通函数的this   谁调用指向谁     把谁找到   就看.前面的对象   全局window可以省略的</span><br><span class="line">箭头函数的this会指向上层环境  不会改变</span><br><span class="line">        组件内部生命函数 一定要  箭头函数  this会指向当前组件</span><br><span class="line">        add=()=&gt;&#123; this.指向当前组件 &#125;</span><br><span class="line"></span><br><span class="line">函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系</span><br><span class="line">1.全局定义的函数直接调用，this =&gt; window</span><br><span class="line">2.对象内部的方法调用，this =&gt; 调用者</span><br><span class="line">3.定时器的处理函数，this =&gt; window</span><br><span class="line">4.事件处理函数，this =&gt; 事件源</span><br><span class="line">5.自调用函数，this =&gt; window</span><br><span class="line"></span><br><span class="line">6.💖💖call 和 apply 和 bind强行改变this指向</span><br><span class="line">函数名.call(要改变的this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)</span><br><span class="line">函数名.apply(要改变的this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])</span><br><span class="line">bind方法不会立即执行函数，而是返回一个已经改变了 this 指向的函数 --- bind 返回的是函数</span><br><span class="line">var newFn = 函数名.bind(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...);</span><br><span class="line">newFn(传递参数)</span><br><span class="line"></span><br><span class="line">this指向它调用的对象</span><br><span class="line">指向window--- 普通函数调用的时候   定时器    forEach  事件绑定IE</span><br><span class="line">指向上一层函数---  箭头函数指向创建环境</span><br><span class="line">指向自己--- 自定义构造函数   事件函数   对象</span><br></pre></td></tr></table></figure>
<h2 id="10-事件机制-–-eventLoop💖💖✨"><a href="#10-事件机制-–-eventLoop💖💖✨" class="headerlink" title="10  事件机制 – eventLoop💖💖✨"></a>10  事件机制 – eventLoop💖💖✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">宏任务 普通那些</span><br><span class="line">微任务 </span><br><span class="line">     .then()</span><br><span class="line">     .catch()</span><br><span class="line">     .progress()</span><br><span class="line">     $nextTick(()=&gt;&#123;//dom渲染完成之后执行&#125;)</span><br><span class="line"></span><br><span class="line">宏任务 </span><br><span class="line">	 script</span><br><span class="line"> 	 setTimeout()</span><br><span class="line"> 	 setInterval()</span><br><span class="line"> 	 ajax()</span><br></pre></td></tr></table></figure>
<h2 id="13-重排和重绘"><a href="#13-重排和重绘" class="headerlink" title="13 重排和重绘"></a>13 重排和重绘</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dom删除增加  dom宽高改变 （布局变了叫重排）</span><br><span class="line">css变了叫做重绘    display:block   dsplay:none  （重绘）</span><br></pre></td></tr></table></figure>
<h2 id="14-解析地址✨"><a href="#14-解析地址✨" class="headerlink" title="14 解析地址✨"></a>14 解析地址✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/#/list?name=sss&amp;zzz=fff</span><br><span class="line">query 问号后面</span><br><span class="line">hash #</span><br><span class="line">list</span><br></pre></td></tr></table></figure>
<h2 id="16-http-面试-💖💖✨"><a href="#16-http-面试-💖💖✨" class="headerlink" title="16 http 面试 💖💖✨"></a>16 http 面试 💖💖✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http 请求方式  get post delete ....</span><br><span class="line"></span><br><span class="line">http 状态 100 请求继续 200 成功  301 （重定向）   401 (参数错误)   404 （url错了）       500 （服务器代码错了）</span><br><span class="line"></span><br><span class="line">请求头特别重要</span><br><span class="line">	content-type 特别重要</span><br><span class="line">	</span><br><span class="line">// 面试--重点题</span><br><span class="line">post请求</span><br><span class="line">	axios  默认请求  content-type:application/json </span><br><span class="line">	如果要是跨域</span><br><span class="line">	通过 webapck 代理 解决跨域 proxy:&#123;&#125;  //</span><br></pre></td></tr></table></figure>
<h2 id="11-ES6"><a href="#11-ES6" class="headerlink" title="11  ES6"></a>11  ES6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">1 箭头函数  ()=&gt;  this指向  固话不变   （原生js里面使用不是特别多 ）  vue - react</span><br><span class="line"></span><br><span class="line">2 Promise   async await </span><br><span class="line">	由于 js异步代码 ---  不是谁先调用谁完成  </span><br><span class="line">	Prmose.relove()</span><br><span class="line">	.then()</span><br><span class="line">	.then()</span><br><span class="line">	.then().catch(err=&gt;)</span><br><span class="line">	Promise.reject().catch()</span><br><span class="line">	Promise.all()  // </span><br><span class="line">	Promise.race()   只要有一个完成就执行</span><br><span class="line">	Promise.all([fn1,fn2,fn3,fn4]).then(res=&gt;[])   ---  *****  都完成之后调用</span><br><span class="line">	5接口 返回数据</span><br><span class="line">	async function del()&#123;</span><br><span class="line">		awiat fn1()</span><br><span class="line">		await fn2()</span><br><span class="line">		..</span><br><span class="line">	&#125;</span><br><span class="line">	del().then()</span><br><span class="line">3  await 不能单独使用</span><br><span class="line">4  解构赋值    let [] = [a,b]    a=10 b=11  let [b,a] = [a,b]    </span><br><span class="line">			 let &#123;name,age&#125; = &#123;name:&quot;zzzz&quot;,age:20&#125;</span><br><span class="line">5  ...   浅拷贝  [...arr]  &#123;...obj&#125;  深拷贝 </span><br><span class="line">   ...   模拟arguments 获取实参的集合   箭头没有arguments对象</span><br><span class="line"></span><br><span class="line">6 `` 模板字符串  $&#123;&#125;</span><br><span class="line">7 Set 能去重复  保证数据唯一  [...new Set(arr)]   --- </span><br><span class="line">8 对象简写	 新增的对象方法  </span><br><span class="line">	Object.assign(&#123;&#125;,obj1,obj2) //合并对象 &#123;...&#125;   浅拷贝</span><br><span class="line">	Object.frzze() 创建不可更改的对象</span><br><span class="line">	Object.definedProperty()   ******</span><br><span class="line">	</span><br><span class="line">	💖vue 双向数据绑定原理  2.0   ---- 3XXX使用的不是这个   Proxy   （代理不是一会儿）</span><br><span class="line">		利用 原生  Object.defineProperty 这个方法来监听和改变值的，</span><br><span class="line">		defineProperty 有两个函数  一个set,一个是get</span><br><span class="line">		get函数 使用数据就触发 -- 调用数据的时候触发   get方法来进行同步数据</span><br><span class="line">		set函数  修改数据的时候触发 渲染视图的方法 render()</span><br><span class="line"></span><br><span class="line">9 symbol 唯一   为了给对象添加key值来使用</span><br><span class="line">10 class 必会</span><br><span class="line">	继承  原型对象 </span><br><span class="line">11 数组的方法</span><br><span class="line">	include 是否包含</span><br><span class="line">	find((item)  //返回是元素</span><br><span class="line">	findIndex((item))  //返回值下标</span><br><span class="line">	es5遍历</span><br><span class="line">	filter</span><br><span class="line">	map</span><br><span class="line">	every</span><br><span class="line">	some</span><br><span class="line">	redcuer((第一个参数,后面的每一个参数)=&gt;) //请和</span><br><span class="line"></span><br><span class="line">12  💖let const </span><br><span class="line">	都不能重复声明</span><br><span class="line">	const不能重新赋值  let可以重新赋值  没有预解析  先声明再调用</span><br><span class="line">	块级作用域   &#123;&#125; 外部访问不到  不用怕变量污染全局，也不怕快里面重复生命</span><br></pre></td></tr></table></figure>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="1-promise💖💖✨"><a href="#1-promise💖💖✨" class="headerlink" title="1 promise💖💖✨"></a>1 promise💖💖✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">2  因为  我们开发程序 有可能是有关联的 </span><br><span class="line">	例如   可以程序 有三步组成   第一步的结果会影响到第二步 ， 第二步结果会影响第三步 </span><br><span class="line"></span><br><span class="line">1 解决异步回调问题  （回调地狱）</span><br><span class="line"></span><br><span class="line">3 Promise.then().then().then().catch()</span><br><span class="line"></span><br><span class="line">三个状态：</span><br><span class="line">Pending  进行中</span><br><span class="line">fulfilled   成功</span><br><span class="line">Rejected   失败</span><br><span class="line"></span><br><span class="line">同一时间只能存在一种状态,且状态一旦改变就不能再变</span><br><span class="line"></span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	resolve(&apos;ok&apos;) // 传递给.then</span><br><span class="line">	reject(err)  // 传递catch</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">async  --- await</span><br><span class="line"></span><br><span class="line">async function () &#123; &#125;  返回promise对象</span><br><span class="line">await 将异步转成同步</span><br><span class="line"></span><br><span class="line">Promise.all()</span><br><span class="line">Promise.race()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.promise语法</span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // resolve 表示成功的回调</span><br><span class="line">  // reject 表示失败的回调</span><br><span class="line">&#125;).then(function (res) &#123;</span><br><span class="line">  // 成功的函数</span><br><span class="line">  </span><br><span class="line">  return 数值或者Promise对象</span><br><span class="line">  </span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">  // 失败的函数</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">2.async/await语法</span><br><span class="line">async function fn() &#123;</span><br><span class="line">  const res = await promise对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211009154113599.png" alt="image-20211009154113599"></p>
<h2 id="2-let-const-var-区别-💖💖"><a href="#2-let-const-var-区别-💖💖" class="headerlink" title="2  let const var  区别 💖💖"></a>2  let const var  区别 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var  存在变量提升（预解析）  能够重复声明变量</span><br><span class="line"></span><br><span class="line">let const 没有变量提升</span><br><span class="line">let,const 会产生块及作用域 ，声明的变量是私有的，不可重复声明 </span><br><span class="line"></span><br><span class="line">let  可以修改</span><br><span class="line">const  不可以修改    我们一般定义 常量  配置属性</span><br><span class="line"></span><br><span class="line">使用的一般我们会根据 💖作用域来选    -----   解决了 变量渲染全局的问题  ----- 有点类似闭包的特性</span><br></pre></td></tr></table></figure>
<h2 id="3-箭头函数-💖💖"><a href="#3-箭头函数-💖💖" class="headerlink" title="3 箭头函数 💖💖"></a>3 箭头函数 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 使用情况  在vue和react或者其他框架里面，我们一般情况下  this都应该指向当前组件 ， 如果用普通函数会导致this指向不明确，所以用箭头函数比较合适</span><br><span class="line"></span><br><span class="line">2 箭头函数的this始终指向它的外部环境，不会发生改变</span><br><span class="line"></span><br><span class="line">3 let  foo = () =&gt; &#123;&#125;      后面有没有大括号是两种  如果有大括号就是普通函数   如果不加大括号  自动加return</span><br><span class="line"> 不能做构造函数    因为this指向固化</span><br><span class="line">5 箭头函数没有 arguments对象 （获取实参的集合）， 我们可以通过 ...拓展运算符来模拟实参集合</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">箭头函数只能简写函数表达式，不能简写声明式函数</span><br><span class="line">语法： (函数的行参) =&gt; &#123; 函数体内要执行的代码 &#125;</span><br><span class="line">箭头函数内部没有 this，箭头函数的 this 是上下文的 this</span><br><span class="line">箭头函数内部没有 arguments 这个参数集合</span><br><span class="line"></span><br><span class="line">函数的行参只有一个的时候可以不写 ()其余情况必须写</span><br><span class="line">函数体只有一行代码的时候，可以不写 &#123;&#125;，并且会自动 return</span><br><span class="line"></span><br><span class="line">一句代码，不需要return的时候，要写&#123; &#125;</span><br><span class="line">一句代码，需要return的时候，可以不写&#123; &#125;</span><br><span class="line">返回一个对象的时候，要写成（&#123; &#125;）</span><br></pre></td></tr></table></figure>
<h2 id="4-解构赋值"><a href="#4-解构赋值" class="headerlink" title="4  解构赋值"></a>4  解构赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=10  b=11   </span><br><span class="line">[b,a]= [a,b]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解构对象</span><br><span class="line"></span><br><span class="line">  gender: &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; name, age, gender &#125; = obj</span><br><span class="line">解构数组</span><br><span class="line">const arr = [&apos;Jack&apos;, &apos;Rose&apos;, &apos;Tom&apos;]</span><br><span class="line">let [a, b, c] = arr</span><br></pre></td></tr></table></figure>
<h2 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5 模板字符串"></a>5 模板字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` $&#123;&#125; `</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num = 100</span><br><span class="line">let str = `hello$&#123;num&#125;world$&#123;num&#125;`</span><br><span class="line">console.log(str) // hello100world100</span><br></pre></td></tr></table></figure>
<h2 id="6-class-类"><a href="#6-class-类" class="headerlink" title="6  class  类"></a>6  class  类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;&#125;</span><br><span class="line">class Man extends Preson&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		super()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 下面表示创造一个 Student 类，继承自 Person 类</span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        // 必须在 constructor 里面执行一下 super() 完成继承 </span><br><span class="line">        super()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-Set-Map-去重"><a href="#7-Set-Map-去重" class="headerlink" title="7 Set ,Map   去重"></a>7 Set ,Map   去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [...new Set(arr)]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/leftJS/p/11080962.html</span><br><span class="line">1.set类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">(1)实例对象方法</span><br><span class="line">add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。</span><br><span class="line">delete(value)：删除某个值，删除成功返回true，否则返回false。</span><br><span class="line">has(value)：返回一个布尔值，表示该值是否为Set的成员。</span><br><span class="line">clear()：清除所有成员，没有返回值。</span><br><span class="line">const mySet = new Set([&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, 1, 2, 1])</span><br><span class="line">console.log(mySet)  // &#123;&apos;a&apos;, &apos;b&apos;, 1, 2&#125;   </span><br><span class="line"></span><br><span class="line">然后使用Array.from将对象转为数组</span><br><span class="line"></span><br><span class="line">myset.add(&apos;c&apos;).add(&#123;&apos;a&apos;: 1&#125;)</span><br><span class="line">console.log(mySet) // &#123;&apos;a&apos;, &apos;b&apos;, 1, 2, &apos;c&apos;, &#123;a: 1&#125;&#125; </span><br><span class="line">console.log(mySet.size)     // 6</span><br><span class="line">mySet.has(2)     // true</span><br><span class="line"></span><br><span class="line">(2)遍历方法</span><br><span class="line">keys()：返回键名的遍历器。</span><br><span class="line">values()：返回键值的遍历器。</span><br><span class="line">entries()：返回键值对的遍历器。</span><br><span class="line">forEach()：使用回调函数遍历每个成员。</span><br><span class="line"></span><br><span class="line">(3)数组去重</span><br><span class="line">function unique(arr)&#123;</span><br><span class="line">    return [...(new Set(arr))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</span><br><span class="line">(1)map对象的方法</span><br><span class="line">set(key, val): 向Map中添加新元素</span><br><span class="line">get(key): 通过键值查找特定的数值并返回</span><br><span class="line">has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false</span><br><span class="line">delete(key): 通过键值从Map中移除对应的数据</span><br><span class="line">clear(): 将这个Map中的所有元素删除</span><br><span class="line">const m1 = new Map([[&apos;a&apos;, 111], [&apos;b&apos;, 222]])</span><br><span class="line">console.log(m1) // &#123;&quot;a&quot; =&gt; 111, &quot;b&quot; =&gt; 222&#125;</span><br><span class="line">m1.get(&apos;a&apos;)  // 111</span><br><span class="line">const m2 = new Map([[&apos;c&apos;, 3]])    &#123;&quot;c&quot; =&gt; 3 &#125;</span><br><span class="line">const m3 = new Map(m2)</span><br><span class="line">m3.get(&apos;c&apos;) // 3</span><br><span class="line">m3.has(&apos;c&apos;) // true</span><br><span class="line">m3.set(&apos;d&apos;, 555)</span><br><span class="line">m3.get(&apos;d&apos;) // 555</span><br><span class="line"></span><br><span class="line">(2)遍历方法</span><br><span class="line">keys()：返回键名的遍历器</span><br><span class="line">values()：返回键值的遍历器</span><br><span class="line">entries()：返回键值对的遍历器</span><br><span class="line">forEach()：使用回调函数遍历每个成员</span><br><span class="line"></span><br><span class="line">(3)数组去重</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    //定义常量 res,值为一个Map对象实例</span><br><span class="line">    const res = new Map();</span><br><span class="line">    //返回arr数组过滤后的结果，结果为一个数组</span><br><span class="line">    //过滤条件是，如果res中没有某个键，就设置这个键的值为1</span><br><span class="line">    return arr.filter((a) =&gt; !res.has(a) &amp;&amp; res.set(a, 1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-symbol-唯一"><a href="#9-symbol-唯一" class="headerlink" title="9 symbol   唯一"></a>9 symbol   唯一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了给对象添加key值来使用</span><br></pre></td></tr></table></figure>
<h2 id="10-数组的方法（新增）"><a href="#10-数组的方法（新增）" class="headerlink" title="10 数组的方法（新增）"></a>10 数组的方法（新增）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">includes 是否包含</span><br><span class="line">	find((item)  //返回是元素</span><br><span class="line">	findIndex((item))  //返回值下标</span><br><span class="line">	</span><br><span class="line">	es5遍历</span><br><span class="line">	filter</span><br><span class="line">	map</span><br><span class="line">	every</span><br><span class="line">	some</span><br><span class="line">	arr.reduce(callback,[initialValue])  //求和,callback为回调函数，initialvalue为初始值</span><br></pre></td></tr></table></figure>
<h2 id="11-…-拓展运算符-浅拷贝-深拷贝"><a href="#11-…-拓展运算符-浅拷贝-深拷贝" class="headerlink" title="11  … 拓展运算符   浅拷贝/深拷贝"></a>11  … 拓展运算符   浅拷贝/深拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5]</span><br><span class="line">let arr1 = [...arr] 浅拷贝</span><br><span class="line"></span><br><span class="line">模拟arguments 获取实参的集合   箭头没有arguments对象</span><br></pre></td></tr></table></figure>
<h2 id="12-symbol-唯一-用做key值-💖💖"><a href="#12-symbol-唯一-用做key值-💖💖" class="headerlink" title="12  symbol  唯一   用做key值 💖💖"></a>12  symbol  唯一   用做key值 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Symbol 本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值。</span><br><span class="line">2.声明方法：let id = Symbol(&quot;id&quot;);</span><br><span class="line">3.Symbol 数据类型的特点是唯一性，即使是用同一个变量生成的值也不相等。</span><br><span class="line">let id1 = Symbol(&apos;id&apos;);</span><br><span class="line">let id2 = Symbol(&apos;id&apos;);</span><br><span class="line">console.log(id1 == id2);  //false</span><br><span class="line">4.Symbol 数据类型的另一特点是隐藏性，for···in，object.keys() 不能访问</span><br></pre></td></tr></table></figure>
<h2 id="16-http状态码-💖💖"><a href="#16-http状态码-💖💖" class="headerlink" title="16  http状态码 💖💖"></a>16  http状态码 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">链接  https://www.jianshu.com/p/eed60f57b7b7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</span><br><span class="line">2xx 成功 </span><br><span class="line">200 最常见    请求成功ok</span><br><span class="line">202 请求但是尚未处理</span><br><span class="line"></span><br><span class="line">3xx 重定向</span><br><span class="line"></span><br><span class="line">4xx</span><br><span class="line">400  请求语法错误</span><br><span class="line">401  发送请求时候需要http认证</span><br><span class="line">403  表明对请求资源的访问被服务器拒绝了  超出访问权限</span><br><span class="line">404  请求地址或者请求方式发生错误 </span><br><span class="line"></span><br><span class="line">5XX 服务器那端的代码不一致</span><br><span class="line">500 服务器定义的内容前端定义的不一致 --</span><br><span class="line">503 后端维护服务器</span><br></pre></td></tr></table></figure>
<h2 id="17-axios-post传参与get传参的区别-💖💖"><a href="#17-axios-post传参与get传参的区别-💖💖" class="headerlink" title="17  axios post传参与get传参的区别 💖💖"></a>17  axios post传参与get传参的区别 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1  post  上传   都可以用post</span><br><span class="line">2  get   明文请求     jsonp必须用get    请求内容在地址栏显示  不安全   </span><br><span class="line"></span><br><span class="line">1、💖传送方式：get通过地址栏传输，post通过请求体传输。</span><br><span class="line">2、💖传送长度：get参数有长度限制（受限于url长度），而post无限制</span><br><span class="line">3、get方式的💖安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</span><br><span class="line"></span><br><span class="line">2 💖post传参 </span><br><span class="line">	容易发送两次请求</span><br><span class="line">	1 跨域检验  options请求  -- 服务器返回204（意思就是请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面。）才会发送post请求</span><br><span class="line">	2 才会发送post请求   </span><br><span class="line">	post请求转数据格式</span><br><span class="line">	</span><br><span class="line">	这三种不需要检验跨域</span><br><span class="line">	x-www-from-urlencoded</span><br><span class="line">	formData</span><br><span class="line">	text/plain </span><br><span class="line">	</span><br><span class="line">	axios默认格式永远  applcaition/json</span><br><span class="line">	</span><br><span class="line">	import qs from &quot;qs&quot;</span><br><span class="line">	 1) </span><br><span class="line">	 axios.default.post[&quot;Content-Type&quot;] = &quot;application/x-www-from-urlencoded;chaset=utf8&quot;</span><br><span class="line">	 </span><br><span class="line">	 post请求的数据 需要 qs.stringify进行反序列化</span><br><span class="line">	 data:qs.stringify(data)</span><br></pre></td></tr></table></figure>
<h2 id="18-事件流-💖💖-✨"><a href="#18-事件流-💖💖-✨" class="headerlink" title="18 事件流    💖💖 ✨"></a>18 事件流    💖💖 ✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">冒泡  --  从内向外  -- 事件委托</span><br><span class="line">捕获  --  从外向内  --  改热键 </span><br><span class="line"></span><br><span class="line">div.addEventListener(&quot;click&quot;,function()&#123;&#125;,false) --  removeEventLisener</span><br><span class="line">div.onclick=function()&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. 冒泡：</span><br><span class="line">就是从事件目标的事件处理函数开始，依次向外，直到 window 的事件处理函数触发，也就是从下向上的执行事件处理函数</span><br><span class="line">2. 捕获：</span><br><span class="line">就是从 window 的事件处理函数开始，依次向内，直到事件目标的事件处理函数执行，也就是从上向下的执行事件处理函数</span><br><span class="line">事件触发默认冒泡，从内向外触发。</span><br><span class="line">阻止冒泡的几种方式：</span><br><span class="line">(1) e.stopPropagation() 点击只出现li</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var ul = document.querySelector(&apos;ul&apos;)</span><br><span class="line">    var li = document.querySelector(&apos;li&apos;)</span><br><span class="line">    li.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">        e.stopPropagation()</span><br><span class="line">        console.log(&apos;li&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ul.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;ul&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">(2)e.cancelBubble = true 点击只出现li</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var ul = document.querySelector(&apos;ul&apos;)</span><br><span class="line">    var li = document.querySelector(&apos;li&apos;)</span><br><span class="line">    li.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">        e.cancelBubble = true</span><br><span class="line">        console.log(&apos;li&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ul.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;ul&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">(3)事件监听第三个参数true,事件捕获，默认false,事件冒泡。冒泡先出现li,再出现ul。捕获先出现ul,再出现li。</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var ul = document.querySelector(&apos;ul&apos;)</span><br><span class="line">    var li = document.querySelector(&apos;li&apos;)</span><br><span class="line">    li.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">        console.log(&apos;li&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ul.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;ul&apos;)</span><br><span class="line">    &#125;,true)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="19-作用域链"><a href="#19-作用域链" class="headerlink" title="19 作用域链"></a>19 作用域链</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用域  外部访问不到内部变量   -- 闭包</span><br><span class="line">内部可以放外部  我们是调用一个变量的时候 会从他自己的作用域开始查找，找到就返回，找不到会想外层找，找到返回，找不到向外层找 以此类推， 如果最外层全局还不到就报错 is not defined</span><br></pre></td></tr></table></figure>
<h2 id="20-防抖-和-节流"><a href="#20-防抖-和-节流" class="headerlink" title="20 防抖 和 节流"></a>20 防抖 和 节流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 使用场景 </span><br><span class="line">   1 ) 搜索的时候 ， 很容易重复触发请求，怎么避免这个问题</span><br><span class="line">   2 ) 根据移动坐标来触发验证  ， 滑动验证码</span><br><span class="line">   </span><br><span class="line">https://segmentfault.com/a/1190000018428170    看看文章 （）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">防抖是将多次执行变为只执行一次（开关锁），节流是将多次执行变为每隔一段时间执行（清零）。</span><br><span class="line">　</span><br><span class="line">1. 防抖：（滚动事件，input框输入）</span><br><span class="line">防抖，一段时间内执行一次，核心在于开关锁 timer=null</span><br><span class="line"></span><br><span class="line">对于短时间内连续触发的事件（如滚动事件），防抖的含义就是让某个时间期限内，事件处理函数只执行一次。</span><br><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer = null //借助闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            clearTimeout(timer) </span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(fn,delay) // 简化写法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function showTop  () &#123;</span><br><span class="line">    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">　　console.log(&apos;滚动条位置：&apos; + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line">window.onscroll = debounce(showTop,1000)</span><br><span class="line"></span><br><span class="line">2. 节流：（点击事件）</span><br><span class="line">核心在于清零 clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</span><br><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    let valid = true</span><br><span class="line">    return function() &#123;</span><br><span class="line">       if(!valid)&#123;</span><br><span class="line">           //休息时间 暂不接客</span><br><span class="line">           return false </span><br><span class="line">       &#125;</span><br><span class="line">       // 工作时间，执行函数并且在间隔期内把状态位设为无效</span><br><span class="line">        valid = false</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            fn()</span><br><span class="line">            valid = true;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function showTop  () &#123;</span><br><span class="line">    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">　　console.log(&apos;滚动条位置：&apos; + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line">window.onscroll = throttle(showTop,1000)</span><br></pre></td></tr></table></figure>
<h2 id="21-react💖💖-✨"><a href="#21-react💖💖-✨" class="headerlink" title="21 react💖💖 ✨"></a>21 react💖💖 ✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">react全家桶：react + react-router + redux + axios</span><br><span class="line"></span><br><span class="line">类组件</span><br><span class="line">1 setState(&#123;&#125;) 异步</span><br><span class="line">	1 setState 会执行render</span><br><span class="line">    2 setState多次 合并   将多个状态合并一起更新 减少render的调用</span><br><span class="line">    3 setState((prevState,prevProps)=&gt;(&#123;&#125;))</span><br><span class="line">    </span><br><span class="line">setState(&#123;&#125;)为什么异步？  生命周期</span><br><span class="line">	setState 改变了状态并触发了 render， 而 render 往往是伴随着重排和重绘的，显然，这是非常影响浏览器性能的操作。如果设计成同步的话，试想，假使多个组件绑定了一个合成事件处理函数，那么，当这个事件函数执行的时候，setState 会多次修改 state 并 render。我们不如在 setState 的时候先不触发，而是先把那些需要更改的组件标记一下，最后一起改变 state 并渲染，这对浏览器性能的提升显然是有积极的影响的。</span><br><span class="line"></span><br><span class="line">	this.setState(&#123;&#125;,callback) callback数据修改完成之后执行</span><br><span class="line">	this.setState((prevState,prevProps)=&gt;(&#123;&#125;),callback)</span><br><span class="line"></span><br><span class="line">2 生命周期  -- 三五分钟</span><br><span class="line">	更新的生命周期</span><br><span class="line">	shouldcomponentupdate(nextProps,nextState)&#123;</span><br><span class="line">		return </span><br><span class="line">	&#125;</span><br><span class="line">3 高阶组件  自定义高阶组件</span><br><span class="line"></span><br><span class="line">组件通信</span><br><span class="line">父传子</span><br><span class="line">子传父</span><br><span class="line">redux</span><br><span class="line">ref</span><br><span class="line">this.props.children   插槽   &#123;this.props.children&#125;  &#123;/* 这里接受&lt;SiderDemo&gt;XXX&lt;/SiderDemo&gt;传过来的XXX */&#125;</span><br><span class="line"></span><br><span class="line">4  context 跨组件通信</span><br><span class="line">只要包裹根组件，所有的子代组件都可以使用这个数据</span><br><span class="line">	&lt;context.Provider&gt;</span><br><span class="line">		&lt;App /&gt;</span><br><span class="line">	&lt;/context.Provider&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;context.Consumer&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			data=&gt;data就是共享的数据</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/context.Consumer&gt;</span><br><span class="line">	Router</span><br><span class="line">	react-redux </span><br><span class="line">	</span><br><span class="line">5 redux </span><br><span class="line">	reducer(state,action)&#123;</span><br><span class="line">	  swich()&#123;</span><br><span class="line">	  	case ADD</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	getState() //获取状态</span><br><span class="line">	dispatch(&#123;type:&quot;ADD&quot;&#125;) 触发行为</span><br><span class="line">	action</span><br><span class="line">	createStore()</span><br><span class="line">	数据模块化 </span><br><span class="line">	//subscribe()</span><br><span class="line">	</span><br><span class="line">	react-redux</span><br><span class="line">	&lt;Provider&gt;&lt;/Prvider&gt;</span><br><span class="line">	connenct(mapStateToProps,mapDispatchToProps)(app)</span><br><span class="line">	</span><br><span class="line">6 hook</span><br><span class="line">	let [n,setN] = useState(0)</span><br><span class="line">	useEffect(()=&gt;&#123;&#125;,[])</span><br><span class="line">	useRef()</span><br><span class="line">	useMemo()</span><br><span class="line">	useCallback()</span><br><span class="line">	useContext</span><br><span class="line">	useReducer</span><br><span class="line">	</span><br><span class="line">7 react与vue的优缺点？</span><br></pre></td></tr></table></figure>
<h2 id="22-react生命周期-💖💖✨"><a href="#22-react生命周期-💖💖✨" class="headerlink" title="22 react生命周期 💖💖✨"></a>22 react生命周期 💖💖✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">最早的一个生命周期</span><br><span class="line">constructro()&#123;</span><br><span class="line">	super()</span><br><span class="line">&#125;</span><br><span class="line">挂载阶段</span><br><span class="line">    1.componentWillMount 发生在 render 函数之前，还没有挂载 Dom</span><br><span class="line">    2.render </span><br><span class="line">    3.componentDidMount  发生在 render 函数之后，已经挂载 Dom</span><br><span class="line"> 更新阶段</span><br><span class="line">	* 1. componentWillReceiveProps</span><br><span class="line">    * 2. shouldComponentUpdate</span><br><span class="line">    * 3. componentWillUpdate</span><br><span class="line">    * 4. componentDidUpdate</span><br><span class="line"> 卸载阶段</span><br><span class="line"> 	componentWillUnmount</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line">     触发条件 父组件数据改变 自己的数据改变</span><br><span class="line">     触发条件  只有父组件render的时候才会触发   它的作用 同步state</span><br><span class="line">     componentWillReceiveProps(nextProps,nextState)&#123;</span><br><span class="line">         this.setState(&#123;</span><br><span class="line">             m:nextProps.n</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // 这种写法 不适应与 引用类型  引用类型需要 先转成字符串进行值比较  使用再转成对象</span><br><span class="line">     shouldComponentUpdate()&#123;</span><br><span class="line">        //优化性能的方案 </span><br><span class="line">          return Object.keys(nextState).some(key=&gt; nextState[key] !== this.state[key]) ||</span><br><span class="line">            Object.keys(nextProps).some(key=&gt; nextProps[key] !== this.props[key])</span><br><span class="line">     &#125;</span><br><span class="line">     //组件将要更新  没啥用</span><br><span class="line">     componentWillUpdate(nextProps,nextState)&#123;&#125;</span><br><span class="line">    //  </span><br><span class="line">    render()</span><br><span class="line">    // 组件更新完成之后执行</span><br><span class="line">    componentDidUpdate(prevProps,prevState)&#123;</span><br><span class="line">        // 数据更细完成之后才会执行  --- 无论哪个数据更新完之后都会执行</span><br><span class="line">        // </span><br><span class="line">     &#125;</span><br><span class="line">卸载阶段</span><br><span class="line">	componentWillUnmount 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount  中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</span><br></pre></td></tr></table></figure>
<h2 id="23-react-路由传参-💖💖"><a href="#23-react-路由传参-💖💖" class="headerlink" title="23 react 路由传参 💖💖"></a>23 react 路由传参 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;pathname:&quot;/detail&quot;,state:&#123;&#125;&#125;&#125;&gt;&lt;/Link&gt;   </span><br><span class="line">路由两种模式   都能存储传递的值</span><br><span class="line">	query不能使用  刷新不保存</span><br><span class="line">	hash  想保存值  需要用 search:&quot;name=zzz&amp;age=20&quot;  在导航栏拼接字符串</span><br><span class="line">	history    state:&#123;name:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-微信小程序"><a href="#24-微信小程序" class="headerlink" title="24 微信小程序"></a>24 微信小程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1 上线流程</span><br><span class="line">	注册账号</span><br><span class="line">	下载开发工具</span><br><span class="line">	创建项目正常开发 可以....</span><br><span class="line">	开发的时候需要   设置  不校验合法域名</span><br><span class="line">	开发完成之后    小程序平台 配置 合法域名</span><br><span class="line">	上传代码  </span><br><span class="line">		大小不能超过 1个包 不超过2m  多个包 最大不能超过20m</span><br><span class="line">	提交审核  -- 通过</span><br><span class="line">	发布代码</span><br><span class="line">	</span><br><span class="line">2 传参   事件传参   data-自定义属性     e.currentTarget.dataset.自定属性</span><br><span class="line"></span><br><span class="line">3 路由传参   ?拼接地址的方法      在生命周期  onload(options)</span><br><span class="line"></span><br><span class="line">4  &lt;navigator open-type=&quot;&quot;&gt;&lt;/navigator&gt;</span><br><span class="line"> 1 navigate 正常跳转</span><br><span class="line"> 2 switchTab  tarBar</span><br><span class="line"> 3 redirect  替换</span><br><span class="line"> 4 relanugh   删除之前的并跳转</span><br><span class="line"> .....</span><br><span class="line"> </span><br><span class="line"> 5 小程序的运行原理</span><br><span class="line"> 	没有给页面</span><br><span class="line"> 		.wxml 结构</span><br><span class="line"> 		.wxss 样式</span><br><span class="line"> 		.js   逻辑</span><br><span class="line"> 		.json  配置</span><br><span class="line">  6  你做过微信小程序？</span><br><span class="line">  </span><br><span class="line">  7  小程序的优势？</span><br><span class="line">  </span><br><span class="line">  8   云开发  -- 云数据库</span><br></pre></td></tr></table></figure>
<h2 id="25-uniapp"><a href="#25-uniapp" class="headerlink" title="25  uniapp"></a>25  uniapp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue开发小程序  --- vue开发小程序 最后可以打包app</span><br><span class="line">vue的语法 开发各种软件的工具</span><br><span class="line">同一套代码  可以打包成 app  也可以转换成各种小程序</span><br></pre></td></tr></table></figure>
<h2 id="26-混合开发"><a href="#26-混合开发" class="headerlink" title="26  混合开发"></a>26  混合开发</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h5+安卓</span><br><span class="line">h5+ios   怎么交互</span><br><span class="line">&lt;webview src=&quot;h5页面&quot; /&gt;</span><br><span class="line">1 前端  window.saoma=function(data)&#123; //data &#125; </span><br><span class="line">2 原生  扫码信息拿到   window.saoma(扫码信息拿到)</span><br></pre></td></tr></table></figure>
<h2 id="27-VUE"><a href="#27-VUE" class="headerlink" title="27 VUE"></a>27 VUE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">1 MVVM是什么？</span><br><span class="line">	https://www.cnblogs.com/wzfwaf/p/10553160.html</span><br><span class="line">	前后端分离：Model用纯JavaScript对象表示，View负责显示。</span><br><span class="line">	model：服务器的业务逻辑操作</span><br><span class="line">	view：用户界面</span><br><span class="line">	ViewModel：核心枢纽</span><br><span class="line">	过程：把view和model关联起来的就是View Model。</span><br><span class="line"></span><br><span class="line">            ViewModel负责吧Model的数据同步到view显出来，还负责吧view修改同步到Model。</span><br><span class="line"></span><br><span class="line">	1. 各部分之间的通信，都是双向的。</span><br><span class="line"></span><br><span class="line">	2. View 与 Model 不发生联系，都通过ViewModel传递。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">三.双向绑定是什么原理，能写出来吗？</span><br><span class="line">大大减轻开发负担，自动化处理。</span><br><span class="line"></span><br><span class="line">双向绑定：data和view之间的自动化处理</span><br><span class="line"></span><br><span class="line">2 组件通信？</span><br><span class="line">	this.$parent --- 比较常用</span><br><span class="line">	this.$children</span><br><span class="line">	ref</span><br><span class="line">	mixin:[组件1,组件2] [重要]</span><br><span class="line">	$root</span><br><span class="line">	eventBus</span><br><span class="line"></span><br><span class="line">3 v-if v-show区别</span><br><span class="line"></span><br><span class="line">4 methods,computed,watch</span><br><span class="line">	methods:强调的主观调用</span><br><span class="line">	computed,watch:自动调用</span><br><span class="line">	1 使用选择 推荐使用 computed</span><br><span class="line">	2 如果监听的数据会影响多个数据 那么watch</span><br><span class="line">	3 如果多个值影响一个值 computed</span><br><span class="line">	4 如果 设计到异步ajax那么只能使用watch ***</span><br><span class="line">	5 计算属性会有值的缓存</span><br><span class="line">	6 watch 出发的时候有间隔 （相当于做了节流了）</span><br><span class="line">	watch : set函数</span><br><span class="line">	conputed: get函数</span><br><span class="line">	</span><br><span class="line">5 keepAlive    --------     相当于react请求中存储在本地</span><br><span class="line">	1 缓存组件 一般 &lt;keep-alive&gt; router-view &lt;/keep-alive&gt;</span><br><span class="line">	应该销毁的组件没有销毁  （闭包 -- 函数）  （项目启动过程中缓存）</span><br><span class="line">	2  两个生命周期</span><br><span class="line">		actived()&#123;&#125; //进入的时候执行</span><br><span class="line">		deactived()&#123;&#125; //离开的时候会执行</span><br><span class="line">	3 设置是否需要缓存 </span><br><span class="line">		include   exclude   填写的是组件的name值 </span><br><span class="line">	</span><br><span class="line">6 vuex</span><br><span class="line">	vuex不一定非用不可，多组件之间共享数据，（维护简单）</span><br><span class="line">	state 存储状态</span><br><span class="line">	mutations 修改状态 </span><br><span class="line">	getter 计算属性</span><br><span class="line">	actions  异步请求数据  -- commit(&quot;mutaitions&quot;)</span><br><span class="line">	module:&#123;&#125;,</span><br><span class="line">	puligins:[]</span><br><span class="line">	</span><br><span class="line">	用户信息</span><br><span class="line">	订单信息</span><br><span class="line">	评论</span><br><span class="line">  </span><br><span class="line"> 7 路由</span><br><span class="line"> 	1 路由传参  动态路由  /user/:id</span><br><span class="line"> 	2 路由的生命周期   --- 验证是否等</span><br><span class="line"> 		登录---&gt; 会在本地存储一个状态 --- 全局钩子 beforeEach((to,from,next))</span><br><span class="line"> 		但是--前端不安全的验证 -- 因为本地存储的数据可以改</span><br><span class="line"> 		真安全访问的  还得跟后台传token 让后台验证token</span><br><span class="line"> 		token 请求头里面 </span><br><span class="line"> 	3 mode:&quot;hash/history&quot;</span><br><span class="line"> 		history 容易出现404  需要服务端配置 资源路径访问的问题</span><br><span class="line"> 	4 后台管理系统</span><br><span class="line">    	动态路由改变路由表</span><br><span class="line">    	1 如果权限单一 </span><br><span class="line">    		直接通过 后端传递 用户权限字段来判断 role  v-if=&quot;&quot;</span><br><span class="line">    	2 如果权限复杂</span><br><span class="line">    		动态生成路由表  --- 动态修改 routes</span><br><span class="line">    		登录的时候 根据你的角色 给你路由表 </span><br><span class="line">     如果问道 路由传参 传参了 内容不变   </span><br><span class="line">     	监听路由</span><br><span class="line">            </span><br><span class="line"> 8   自定义指令</span><br><span class="line">    	vue.directive()</span><br><span class="line">    自定义过滤器</span><br><span class="line">    	vue.filter()</span><br><span class="line">  9  生命周期</span><br><span class="line">  	 	常见8个</span><br><span class="line">  </span><br><span class="line">  10 key值</span><br><span class="line">  		添加唯一标识</span><br><span class="line">  		1) 添加删除的时候  回去直接处理改变的</span><br><span class="line">  		2) 当你加Key的组件如果key改变 它会自动跟新</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">11 vue请求数据放在created好还是mounted里好</span><br><span class="line"></span><br><span class="line">**建议放在created里**</span><br><span class="line">**created**:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</span><br><span class="line">**mounted**:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</span><br><span class="line"></span><br><span class="line">如果在**mounted**钩子函数中请求数据可能导致页面闪屏问题</span><br><span class="line">其实就是加载时机问题，放在**created**里会比**mounted**触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了</span><br><span class="line"></span><br><span class="line">由于 JavaScript 的限制，Vue 不能检测以下数组的变动：</span><br><span class="line"></span><br><span class="line">​```javascript</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		items: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[1] = &apos;x&apos; // 不是响应性的</span><br><span class="line">vm.items.length = 2 // 不是响应性的</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">当利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</span><br><span class="line">可以使用：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue);或者：vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br><span class="line">当修改数组的长度时，例如：vm.items.length = newLength</span><br><span class="line">可以使用：vm.items.splice(newLength)</span><br><span class="line"></span><br><span class="line">由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</span><br><span class="line"></span><br><span class="line">因为Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</span><br></pre></td></tr></table></figure>
<h2 id="29-webpack-基础-💖💖"><a href="#29-webpack-基础-💖💖" class="headerlink" title="29  webpack  基础 💖💖"></a>29  webpack  基础 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry :入口文件      多页应用 多入口多出口</span><br><span class="line">output: 出口文件</span><br><span class="line">module:&#123;   loader</span><br><span class="line">	rules:[]</span><br><span class="line">&#125;</span><br><span class="line">plugins:[ ],</span><br><span class="line">devServer:&#123;&#125;  //webpack服务器</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &quot;development&quot;,</span><br><span class="line">  entry: &quot;./src/main.js&quot;,     //入口文件</span><br><span class="line">  output: &#123;                    //出口文件</span><br><span class="line">    filename: &quot;main.js&quot;,</span><br><span class="line">    path: path.join(__dirname, &quot;../dist&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.scss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;style-loader&quot;, // 将 JS 字符串生成为 style 节点</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;css-loader&quot;, // 将 CSS 转化成 CommonJS 模块</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;sass-loader&quot;, // 将 Sass 编译成 CSS</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &quot;./index.html&quot;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // contentBase: path.join(__dirname, &quot;../dist&quot;),</span><br><span class="line">    port: 3000,   //端口号</span><br><span class="line">    open: true,  //是否自动打开浏览器</span><br><span class="line">    hot: true,  // 热更新</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &apos;/api&apos;: &#123;// &apos;/api&apos;:匹配项</span><br><span class="line">        target: &apos;http://www.baidu.com&apos;,// 接口的域名</span><br><span class="line">        // secure: false,// 如果是https接口，需要配置这个参数</span><br><span class="line">        changeOrigin: true,// 如果接口跨域，需要进行这个参数配置</span><br><span class="line">        // pathRewrite: &#123;// 如果接口本身没有/api需要通过pathRewrite来重写了地址</span><br><span class="line">        //   &apos;^api&apos;: &apos;&apos;</span><br><span class="line">        // &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 💖**Proxy**</span><br><span class="line"></span><br><span class="line"> webpack中的`proxy`只是一层代理，用于把指定的`path`，代理去后端提供的地址，背后使用node来做server。可能有人疑惑，为什么只适用本地开发？因为该技术只是在webpack打包阶段在本地临时生成了node server，来实现类似nginx 的`proxy_pass`的反向代理效果</span><br><span class="line"></span><br><span class="line">  `proxy`工作原理实质上是利用`http-proxy-middleware` 这个http代理中间件，实现请求转发给其他服务器。例如：本地主机A为`http://localhost:3000`，该主机浏览器发送一个请求，接口为`/api`，这个请求的数据（响应）在另外一台服务器B`http://10.231.133.22:80`上，这时，就可以通过A主机设置webpack proxy，直接将请求发送给B主机。</span><br></pre></td></tr></table></figure>
<h2 id="31-ajax-💖💖-✨"><a href="#31-ajax-💖💖-✨" class="headerlink" title="31 ajax  💖💖 ✨"></a>31 ajax  💖💖 ✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前后端交互技术  核心两个</span><br><span class="line">XMLHttpRequest   ---  $.ajax  axios</span><br><span class="line">fetch  -- fetch</span><br><span class="line"></span><br><span class="line">1 ajax 原理</span><br><span class="line">  1） 创建一个 ajax 对象   const xhr = new XMLHttpRequest()</span><br><span class="line">  2） 发送请求   xhr.open(&quot;methods&quot;,url,true)</span><br><span class="line">  3)  发送参数   xhr.send(null)</span><br><span class="line">  4)  监听变化触发函数   xhr.onreadystatechange</span><br><span class="line"></span><br><span class="line">2 axios 二次分装    </span><br><span class="line">	请求拦截器  修改参数类型 ， 统一传固定参数 。。。</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	相应拦截器  错误几种处理  </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">3 $.ajax  当你想用 jsonp的时候  用封装$.ajax</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. ajax：</span><br><span class="line">   ajax全名async javascript and XML(异步的javascript和XML),客户端给服务端发送消息的工具，以及接受响应的工具。</span><br><span class="line">   (1)创建一个 ajax 对象</span><br><span class="line">   const xhr = new XMLHttpRequest()</span><br><span class="line">   (2)配置链接信息</span><br><span class="line">   // xhr.open(&apos;请求方式&apos;, &apos;请求地址&apos;, 是否异步默认 true 表示异步false 表示同步)</span><br><span class="line">   xhr.open(&apos;get&apos;, &apos;./data.php&apos;)</span><br><span class="line">   (3)发送请求</span><br><span class="line">   xhr.send()</span><br><span class="line">   (4)获得相应数据</span><br><span class="line">   // ajax状态码 xhr.readyState,只有当 readyState === 4 的时候，我们才可以正常使用服务端给我们的数据</span><br><span class="line">   // 记录http状态码 xhr.status,200 ~ 299 表示本次请求成功了</span><br><span class="line">   // readyStateChange事件专门用来监听ajax对象</span><br><span class="line">   // responseText用来记录服务端给我们的响应体内容的</span><br><span class="line">   xhr.onreadyStateChange = function () &#123;</span><br><span class="line">     if (xhr.readyState === 4 &amp;&amp; /^2\d&#123;2|$/.test(xhr.status)) &#123;</span><br><span class="line">     console.log(xhr.responseText)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   (5)发送参数</span><br><span class="line">   // get 请求的参数就直接在 url 后面进行拼接就可以</span><br><span class="line">   xhr.open(&apos;get&apos;, &apos;./data.php?a=100&amp;b=200&apos;)</span><br><span class="line">   // post 请求的参数是携带在请求体中的,必须要先设置一下请求头中的 content-type</span><br><span class="line">   // application/x-www-form-urlencoded 表示的数据格式就是 key=value&amp;key=value</span><br><span class="line">   xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;)</span><br><span class="line">   xhr.send(&apos;a=100&amp;b=200&apos;)</span><br><span class="line"></span><br><span class="line">2. axios:</span><br><span class="line">   (1)设置拦截器</span><br><span class="line">   import axios from &quot;axios&quot;;</span><br><span class="line">   const fetchData = axios.create(&#123;</span><br><span class="line">     baseURL: &quot;http://localhost:3000&quot;, // 请求地址前缀</span><br><span class="line">     withCredentials: true, // 允许携带cookie</span><br><span class="line">   &#125;);</span><br><span class="line">   //添加请求拦截器</span><br><span class="line">   fetchData.interceptors.request.use(</span><br><span class="line">     function (config) &#123;</span><br><span class="line">         if (config.method == &quot;get&quot;) &#123;</span><br><span class="line">             config.params = &#123;</span><br><span class="line">                 ...config.params,</span><br><span class="line">                 token: JSON.parse(localStorage.getItem(&quot;user&quot;)).token,  //携带token</span><br><span class="line">                 cookie: JSON.parse(localStorage.getItem(&quot;user&quot;)).cookie,  //携带cookie</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;</span><br><span class="line">         if (config.method == &quot;post&quot;) &#123;</span><br><span class="line">             config.data = &#123;</span><br><span class="line">                 ...config.data,</span><br><span class="line">                 token: JSON.parse(localStorage.getItem(&quot;user&quot;)).token,  //携带token</span><br><span class="line">                 cookie: JSON.parse(localStorage.getItem(&quot;user&quot;)).cookie,   //携带cookie</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;</span><br><span class="line">         return config;</span><br><span class="line">     &#125;,</span><br><span class="line">     function (error) &#123;</span><br><span class="line">         //请求错误时做些事</span><br><span class="line">         return Promise.reject(error);</span><br><span class="line">     &#125;</span><br><span class="line">   );</span><br><span class="line">   //添加响应拦截器</span><br><span class="line">   fetchData.interceptors.response.use(</span><br><span class="line">     function (response) &#123;</span><br><span class="line">         //对响应数据做些事</span><br><span class="line">         return response;</span><br><span class="line">     &#125;,</span><br><span class="line">     function (error) &#123;</span><br><span class="line">         //响应错误时做些事</span><br><span class="line">         return Promise.reject(error);</span><br><span class="line">     &#125;</span><br><span class="line">   );</span><br><span class="line">   export default fetchData;</span><br><span class="line">   (2)二次封装</span><br><span class="line">   // 导入拦截器</span><br><span class="line">   import fetchData from &quot;./fetchData&quot;;</span><br><span class="line">   // get请求用params传参</span><br><span class="line">   export async function getPlayList(data = &#123;&#125;) &#123;</span><br><span class="line">     return await fetchData.get(&quot;/top/playlist&quot;, &#123;</span><br><span class="line">     params: data,</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   // post请求用data传参</span><br><span class="line">   export async function login(data) &#123;</span><br><span class="line">     return await fetchData.post(&quot;/login/cellphone&quot;, data);</span><br><span class="line">   &#125;</span><br><span class="line">3. jsonp:</span><br><span class="line">   (1)script 标签的 src 属性本质就是请求一个外部资源，是不受到同源策略的影响的。并且请求回来的东西是一个字符串，浏览器会把这个字符串当作 js 代码来执行。所以我们就可以利用这个 script 标签的 src 属性来进行跨域请求。</span><br><span class="line">   (2)使用Jquery封装函数$.ajax</span><br><span class="line">   $.ajax(&#123;</span><br><span class="line">     url: &quot;http://127.0.0.1:8081/list&quot;,</span><br><span class="line">     dataType: &quot;jsonp&quot;,</span><br><span class="line">     success: (res) =&gt; &#123;</span><br><span class="line">     	console.log(res)</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="32-事件委托-提高性能-💖💖"><a href="#32-事件委托-提高性能-💖💖" class="headerlink" title="32  事件委托   提高性能 💖💖"></a>32  事件委托   提高性能 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1  利用的是冒泡原理 ，将事件注册给父辈组件，因为冒泡点击本身的时候父组件会触发，可以通过判断事件源，来判断是谁触发的从而实现事件委托</span><br><span class="line">2  减少了事件注册， 动态添加的元素依然会享有事件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事件委托：</span><br><span class="line">可以给未来元素添加事件</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  	var oUl = docuemnt.querySelector(&apos;ul&apos;)   </span><br><span class="line">    oUl.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">      e = e || window.event</span><br><span class="line">      var target = e.target || e.srcElement</span><br><span class="line">      if (target.nodeName === &apos;LI&apos;) &#123;</span><br><span class="line">        console.log(&apos;我是 li，我被点击了&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="36-BFC-块级格式化上下文"><a href="#36-BFC-块级格式化上下文" class="headerlink" title="36 BFC(块级格式化上下文)"></a>36 BFC(块级格式化上下文)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BFC(块级格式化上下文):它是一个独立的渲染区域，只有块级元素参与， 它规定了BFC内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</span><br><span class="line">BFC的布局规则（规定、标准）：</span><br><span class="line">    一、BFC内部的Box会在垂直方向，一个接一个地放置。</span><br><span class="line">    二、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置）</span><br><span class="line">    三、每个元素的margin box的左边， 与包含块border box的左边相接触</span><br><span class="line">    四、BFC的区域不会与float box重叠。</span><br><span class="line">    五、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</span><br><span class="line">    六、计算BFC的高度时，浮动元素也参与计算</span><br><span class="line">💖BFC的触发条件：</span><br><span class="line">    根元素(html)</span><br><span class="line">    float属性不为none</span><br><span class="line">    position为absolute或fixed</span><br><span class="line">    display为inline-block, table-cell, table-caption, flex, inline-flex</span><br><span class="line">    overflow不为visible</span><br><span class="line">应用：</span><br><span class="line">    清除浮动</span><br><span class="line">    三栏布局</span><br></pre></td></tr></table></figure>
<h2 id="42-什么是回调函数"><a href="#42-什么是回调函数" class="headerlink" title="42 什么是回调函数?"></a>42 什么是回调函数?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">回调函数是指用一个函数作为参数传入另一个函数，这个函数会被在某个时机调用。</span><br></pre></td></tr></table></figure>
<h2 id="Reducer✨"><a href="#Reducer✨" class="headerlink" title="Reducer✨"></a>Reducer✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</span><br><span class="line"></span><br><span class="line">Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;   <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">&gt;     <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">&gt;       <span class="keyword">return</span> state + action.payload;</span><br><span class="line">&gt;     <span class="keyword">default</span>: </span><br><span class="line">&gt;       <span class="keyword">return</span> state;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> state = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">&gt;   type: <span class="string">'ADD'</span>,</span><br><span class="line">&gt;   payload: <span class="number">2</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面代码中，`reducer`函数收到名为`ADD`的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。</span><br><span class="line"></span><br><span class="line">实际应用中，Reducer 函数不用像上面这样手动调用，`store.dispatch`方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入`createStore`方法。</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>createStore</code>接受 Reducer 作为参数，生成一个新的 Store。以后每当<code>store.dispatch</code>发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">            type: &quot;CHANGE_USER&quot;,</span><br><span class="line">            payload: &#123;</span><br><span class="line">                nickname: &quot;张张大可爱&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>为什么这个函数叫做 Reducer 呢？因为它可以作为数组的<code>reduce</code>方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> actions = [</span><br><span class="line">&gt;   &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">0</span> &#125;,</span><br><span class="line">&gt;   &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;,</span><br><span class="line">&gt;   &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">2</span> &#125;</span><br><span class="line">&gt; ];</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> total = actions.reduce(reducer, <span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，数组<code>actions</code>表示依次有三个 Action，分别是加<code>0</code>、加<code>1</code>和加<code>2</code>。数组的<code>reduce</code> （reduce 为数组中的每一个元素依次执行回调函数 (回调函数又称为累加器)) ）方法接受 Reducer 函数作为参数，就可以直接得到最终的状态<code>3</code>。</p>
<h1 id="Redux✨"><a href="#Redux✨" class="headerlink" title="Redux✨"></a>Redux✨</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（1）Web 应用是一个状态机，视图与状态是一一对应的。</span><br><span class="line"></span><br><span class="line">（2）所有的状态，保存在一个对象里面。</span><br></pre></td></tr></table></figure>
<h2 id="1-Redux的基本概念"><a href="#1-Redux的基本概念" class="headerlink" title="1 Redux的基本概念"></a>1 Redux的基本概念</h2><ul>
<li>整个应用只有一个 Store</li>
<li>State 只能通过触发 Action 来更改</li>
<li>State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer</li>
</ul>
<h2 id="2-Actions"><a href="#2-Actions" class="headerlink" title="2 Actions"></a>2 Actions</h2><p>Action 很简单，就是一个单纯的包含 <code>{ type, payload }</code> 的对象，<code>type</code> 是一个常量用来标示动作类型，<code>payload</code> 是这个动作携带的数据。Action 需要通过 <code>store.dispatch()</code> 方法来发送。</p>
<h2 id="3-Store"><a href="#3-Store" class="headerlink" title="3 Store"></a>3 Store</h2><p>现在有了 Action 和 Reducer，Store 的作用就是连接这两者，Store 的作用有这么几个：</p>
<ul>
<li>Hold 住整个应用的 State 状态树</li>
<li>提供一个 <code>getState()</code> 方法获取 State</li>
<li>提供一个 <code>dispatch()</code> 方法发送 action 更改 State</li>
<li>提供一个 <code>subscribe()</code> 方法注册回调函数监听 State 的更改</li>
</ul>
<p>创建一个 Store 很容易，将 <strong>root reducer</strong> 函数传递给 <code>createStore</code> 方法即可：</p>
<p>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> someApp <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">let</span> store = createStore(someApp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用</span></span><br><span class="line"><span class="comment">// let store = createStore(someApp, window.STATE_FROM_SERVER);</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们就拿到了 <code>store.dispatch</code>，可以用来分发 action 了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'CHANGE_A'</span> &#125;);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'CHANGE_B'</span>, <span class="attr">payload</span>: <span class="string">'Modified b'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop listening to state updates</span></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure>
<h2 id="阻止冒泡相关的三种方法✨"><a href="#阻止冒泡相关的三种方法✨" class="headerlink" title="阻止冒泡相关的三种方法✨"></a>阻止冒泡相关的三种方法✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.event.stopPropagation();</span><br><span class="line">事件处理过程中，阻止了事件冒泡，但不会阻击默认行为</span><br><span class="line"></span><br><span class="line">2.return false;</span><br><span class="line">事件处理过程中，阻止了事件冒泡，也阻止了默认行为</span><br><span class="line"></span><br><span class="line">还有一种有冒泡有关的：</span><br><span class="line">3.event.preventDefault();</span><br><span class="line">它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为</span><br></pre></td></tr></table></figure>
<h2 id="5-Uniapp-页面的生命周期函数有那些？✨"><a href="#5-Uniapp-页面的生命周期函数有那些？✨" class="headerlink" title="5 Uniapp 页面的生命周期函数有那些？✨"></a>5 Uniapp 页面的生命周期函数有那些？✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">onInit</span><br><span class="line">监听页面初始化，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onLoad</span><br><span class="line">监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onShow</span><br><span class="line">监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onReady</span><br><span class="line">监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onHide</span><br><span class="line">监听页面隐藏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onUnload</span><br><span class="line">监听页面卸载</span><br></pre></td></tr></table></figure>
<h2 id="9-Vue-生命周期"><a href="#9-Vue-生命周期" class="headerlink" title="9 Vue 生命周期"></a>9 Vue 生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">created</span><br><span class="line">实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data数据的初始化，el没有。 挂载阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beforeMount</span><br><span class="line">挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂载html到页面上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mounted</span><br><span class="line">挂载完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beforeUpdate</span><br><span class="line">在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">updated</span><br><span class="line">在由于数据更改导致的虚拟DOM重新渲染和打补丁时会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beforeDestroy</span><br><span class="line">在实例销毁之前调用，实例仍然完全可用，这一步还可以用this来获取实例，一般在这一步做一些重置的操作，比如清除掉组件中的定时器和监听的dom事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">destroyed</span><br><span class="line">在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</span><br><span class="line"></span><br><span class="line">作者：善斋书社</span><br><span class="line">链接：https://www.jianshu.com/p/c97415daf180</span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure>
<h2 id="10-获取dom元素在哪个生命周期？-为什么？"><a href="#10-获取dom元素在哪个生命周期？-为什么？" class="headerlink" title="10 获取dom元素在哪个生命周期？ 为什么？"></a>10 获取dom元素在哪个生命周期？ 为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created()  mounted()</span><br></pre></td></tr></table></figure>
<h2 id="💖双向数据绑定原理"><a href="#💖双向数据绑定原理" class="headerlink" title="💖双向数据绑定原理"></a>💖双向数据绑定原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定利用的 Object.defineProperty， 这个方法提供了三个参数 最后对象参数里面有两个函数 </span><br><span class="line">一个set函数  set函数 当数据修改的时候自动触发 ，我们在set函数里面 更新视图</span><br><span class="line">一个get函数  get函数当我们调用这个属性的时候触发， get里面必须要有返回值，返回值应该是设置新值，返回值会把数据设置到对象</span><br><span class="line">所以利用这个两个函数  可以进行双向数据绑定</span><br><span class="line">遍历对象  进行递归</span><br><span class="line">Object.defineProperty只能对对向操作，不能操作数组 ，数据利用生生方法  push,unshift ...</span><br></pre></td></tr></table></figure>
<h2 id="跨域-✨"><a href="#跨域-✨" class="headerlink" title="跨域 ✨"></a>跨域 ✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">跨域源于浏览器同源策略   --    相同的协议 域名 和 端口号   -- 浏览器 （并不包含服务器）</span><br><span class="line">不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。</span><br><span class="line">开发的时候  </span><br><span class="line">localhost:8080  --  localhost:3000</span><br><span class="line">1 💖cors  后端给你设置响应头  允许你访问  （一般）</span><br><span class="line"></span><br><span class="line">2 💖webpack 配置代理    比较多</span><br><span class="line">	proxy :&#123;&#125;</span><br><span class="line">	打包之后不好使 -- </span><br><span class="line">	localhost:8087/user</span><br><span class="line">	</span><br><span class="line">	react官方脚手架默认是将 webpack 配置隐藏起来了，在进行配置之前需要将 webpack 配置暴露出来。</span><br><span class="line"></span><br><span class="line">1.输入命令 npm run eject   然后 y  成功之后 在项目根目录出现 config 文件夹,打开 config 文件夹下的 webpackDevServer.config.js 文件</span><br><span class="line">	</span><br><span class="line">  proxy: &#123;</span><br><span class="line">      &apos;/api&apos;: &#123;// &apos;/api&apos;:匹配项</span><br><span class="line">        target: &apos;http://www.baidu.com&apos;,// 接口的域名</span><br><span class="line">        // secure: false,// 如果是https接口，需要配置这个参数</span><br><span class="line">        changeOrigin: true,// 如果接口跨域，需要进行这个参数配置</span><br><span class="line">        // pathRewrite: &#123;// 如果接口本身没有/api需要通过pathRewrite来重写了地址</span><br><span class="line">        //   &apos;^api&apos;: &apos;&apos;</span><br><span class="line">        // &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">	使用了这种代理还需要修改一下axios请求的url，在路径前添加&apos;/api&apos;（代理名字），只有添加了/api的url才能触发上面配置的代理。</span><br><span class="line">	    </span><br><span class="line">	简单解释下这段配置，代理它到底帮我们做了什么。我们可以把本地跑起来的服务理解为用户A，A发起请求，希望去自己所在的服务（我们当前运行的本地项目）的api/request路径下找一个东西，很明显我们项目中没有这个路径，所以常规来说请求http://localhost:3001/api/request一定报404。</span><br><span class="line">	所以这时候需要代理：当请求中有代理名，代理就会给转发到接口的域名，就可以解决跨域</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3 💖nginx 反向代理</span><br><span class="line"></span><br><span class="line">4 💖jsonp     (jsonp使用不多，必须get请求)</span><br><span class="line">	利用src属性不不属于同源策略，所以可通过 动态创建script标签，通过script的src属性向服务器发送请求.请求过程中需要携带函数名，服务器接受到参数，获取函数名 会返回对象函数名调用的函数字符串 ， 实参就是要传递的数据，</span><br><span class="line">	页面需要动态创建函数，形参就在后端接受的到数据</span><br></pre></td></tr></table></figure>
<h2 id="Post请求✨"><a href="#Post请求✨" class="headerlink" title="Post请求✨"></a>Post请求✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">post 带参数 跟跨域有关系  </span><br><span class="line">axios 会先发一个 options请求  -- 后端没有处理 -- post请求发送不出来</span><br><span class="line">axios默认的 content-type格式是 application/json </span><br><span class="line"></span><br><span class="line">axios发送post请求的时候  你转    </span><br><span class="line">	application/x-www-form-urlencode</span><br><span class="line">	</span><br><span class="line">问你？ post请求 在跨域的时候 传参 会发几次请求？</span><br><span class="line"> 1 options </span><br><span class="line"> 2 post</span><br><span class="line"> 3 前端需要 </span><br><span class="line">    请求头 设置content-type  application/x-www-form-urlencode</span><br><span class="line"> 	qs  qs.tringify(data)</span><br><span class="line"> 	</span><br><span class="line"> 		</span><br><span class="line">	import qs from &quot;qs&quot;</span><br><span class="line">	 </span><br><span class="line">	 axios.default.post[&quot;Content-Type&quot;] = &quot;application/x-www-from-urlencoded;chaset=utf8&quot;</span><br><span class="line">	 </span><br><span class="line">	 post请求的数据 需要 qs.stringify进行反序列化</span><br><span class="line">	 data:qs.stringify(data)</span><br><span class="line"></span><br><span class="line">请求头里面  一定要会 content-type</span><br></pre></td></tr></table></figure>
<h2 id="数组的方法💖💖"><a href="#数组的方法💖💖" class="headerlink" title="数组的方法💖💖"></a>数组的方法💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">slice    复制</span><br><span class="line"></span><br><span class="line">push 加入到数组的最后面</span><br><span class="line">pop  从最后的位置删除</span><br><span class="line">unshift   从最前面添加</span><br><span class="line">shift   从最前面删除</span><br><span class="line"></span><br><span class="line">splice   切，删除   splice(切的位置，切几位，删除后要加入的内容)   改变原数组</span><br><span class="line">slice    复制</span><br><span class="line"></span><br><span class="line">indexOf   查找，返回下标，没找到返回-1</span><br><span class="line">includes  查找，找到返回true，没找到返回false</span><br><span class="line"></span><br><span class="line">concat    拼接</span><br><span class="line">reverse   反转数组</span><br><span class="line">join      转字符串</span><br><span class="line">sort      排序</span><br><span class="line"></span><br><span class="line">forEach</span><br><span class="line">map   （深拷贝，返回一个新数组）</span><br><span class="line">filter	（深拷贝，返回一个新数组）</span><br><span class="line">some</span><br><span class="line">every</span><br></pre></td></tr></table></figure>
<h2 id="字符串方法💖💖"><a href="#字符串方法💖💖" class="headerlink" title="字符串方法💖💖"></a>字符串方法💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">indexOf			返回下标</span><br><span class="line">lastindexOf		返回最后一个元素的下标</span><br><span class="line"></span><br><span class="line">slice			复制</span><br><span class="line">split			转化为数组</span><br><span class="line"></span><br><span class="line">replace			替换</span><br></pre></td></tr></table></figure>
<h2 id="原型✨✨"><a href="#原型✨✨" class="headerlink" title="原型✨✨"></a>原型✨✨</h2><blockquote>
<p>①所有<code>引用类型</code>都有一个<code>__proto__(隐式原型)</code>属性，属性值是一个普通的对象<br>②所有<code>函数</code>都有一个<code>prototype(原型)</code>属性，属性值是一个普通的对象<br>③所有<code>引用类型的__proto__</code>属性<code>指向</code>它<code>构造函数的prototype</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a.__proto__ === Array.prototype; // true12</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当访问一个实例化对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会根据它的__proto__找到它的构造函数的 prototype，如果还没有找到，就继续向上查找，这样就会形成一个链式结构，我们称为`原型链`</span><br><span class="line"></span><br><span class="line">原型链特点 ： 因为实例有指针  __proto__ 指向 原型对象，所以原型链上的方法和属性 实例可以共享</span><br><span class="line"></span><br><span class="line">原型链：</span><br><span class="line">实例化对象的__proto__里面有一个成员叫做constructor指向当前这个对象所属的构造函数。</span><br><span class="line"></span><br><span class="line">原型链的访问原则</span><br><span class="line">访问一个对象的成员的时候,自己没有就会去 __proto__ 中找,如果 __proto__ 里面没有就再去 __proto__ 里面找,一直找到 Object.prototype 里面都没有，那么就会返回 undefiend。</span><br></pre></td></tr></table></figure>
<p>React版本17</p>
<h2 id="this指向-💖💖"><a href="#this指向-💖💖" class="headerlink" title="this指向 💖💖"></a>this指向 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">call(指向对象,参数1,参数2)</span><br><span class="line">apply(指向对象,集合形式的参数)</span><br><span class="line">bind(指向对象,参数1,参数2)   bind需要再调用</span><br><span class="line"></span><br><span class="line">.bind .apply .call 不能改变箭头函数的this指向，因为箭头函数在定义的时候this指向就已经固化了，不能修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">函数名.call(要改变的this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)</span><br><span class="line">函数名.apply(要改变的this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])</span><br><span class="line">bind方法不会立即执行函数，而是返回一个已经改变了 this 指向的函数 --- bind 返回的是函数</span><br><span class="line">div onClick=&#123;this.addN.bind(this)&#125;</span><br><span class="line"></span><br><span class="line">三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</span><br><span class="line">bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。</span><br><span class="line"></span><br><span class="line">类组件中，this指向有问题</span><br><span class="line">1 通过bind修改this</span><br><span class="line">	可以通过 bind来修改this指向，在这里不能使用 call和apply 因为这两个子调用了</span><br><span class="line">div onClick=&#123;this.addN.bind(this)&#125; </span><br><span class="line"></span><br><span class="line">2 箭头函数的this始终指向外部环境</span><br></pre></td></tr></table></figure>
<h2 id="VUE和react的区别-💖💖"><a href="#VUE和react的区别-💖💖" class="headerlink" title="VUE和react的区别 💖💖"></a>VUE和react的区别 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vue 优点</span><br><span class="line">MVVM</span><br><span class="line">有指令，计算属性,watch监听，双向数据绑定，完整的生命周期，修饰符.使得vue开发起来相对简单，都是现成的可以直接用,就算js基础不好学习来也没有那么费劲</span><br><span class="line">vue中的特色是双向数据绑定</span><br><span class="line"></span><br><span class="line">缺点 写东西死板，api比较多</span><br><span class="line">  </span><br><span class="line">react 优点  </span><br><span class="line">VIEW</span><br><span class="line">比vue使用起来更难灵活，都是原生js所有各种方法都可以，</span><br><span class="line">在react中是单向数据绑定，</span><br><span class="line"></span><br><span class="line">缺点 需要原生js基础好点，对于原生的依赖比较大，有点相当于原生开发了</span><br><span class="line"></span><br><span class="line">diff算法 比较   虚拟DOM   dom对象节点</span><br><span class="line">逐层比较</span><br></pre></td></tr></table></figure>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虚拟 dom 是相对于浏览器所渲染出来的真实 dom而言的，在react，vue等技术出现之前，我们要改变页面展示的内容时只能遍历整颗 dom 树，找到需要修改的 dom 然后修改样式行为或者结构。</span><br><span class="line"></span><br><span class="line">这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树及其层级结构，那么每次 dom 的更改就变成了对 js 对象的属性的增删改查，这样一来查找 js 对象的属性变化要比查询 dom 树的性能开销小。</span><br><span class="line"></span><br><span class="line">react以及Vue在diff时，都是在对比虚拟dom节点，下文提到的节点都指虚拟节点</span><br></pre></td></tr></table></figure>
<h2 id="diff算法-💖💖"><a href="#diff算法-💖💖" class="headerlink" title="diff算法 💖💖"></a>diff算法 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">逐层比较</span><br><span class="line"></span><br><span class="line">在React中比较两个虚拟DOM节点，当两个节点不同时，应该如何处理。这分为两种情况：💖（1）节点类型不同 ，💖（2）节点类型相同，但是属性不同。</span><br><span class="line"></span><br><span class="line">💖不同类型节点的比较</span><br><span class="line">如果发现新旧两个节点类型不同时，Diff算法会直接删除旧的节点及其子节点并插入新的节点，这是由于前面提出的不同组件产生的DOM结构一般是不同的，所以可以不用浪费时间去比较。注意的是，删除节点意味着彻底销毁该节点，并不会将该节点去与后面的节点相比较。</span><br><span class="line"></span><br><span class="line">💖相同类型节点的比较</span><br><span class="line">若是两个节点类型相同时，Diff算法会更新节点的属性实现转换</span><br><span class="line"></span><br><span class="line">💖列表节点的比较</span><br><span class="line">列表节点的操作一般包括添加、删除和排序，列表节点需要我们给它一个key才能进行高效的比较。（key可以帮助 React跟踪循环创建列表中的虚拟DOM元素，了解哪些元素已更改、添加或删除。</span><br><span class="line"></span><br><span class="line">每个绑定key的虚拟DOM元素，在兄弟元素之间都是独一无二的。）</span><br></pre></td></tr></table></figure>
<h2 id="33-当你输入网址的时候经历了什么？-💖💖"><a href="#33-当你输入网址的时候经历了什么？-💖💖" class="headerlink" title="33  当你输入网址的时候经历了什么？** 💖💖"></a>33  当你输入网址的时候经历了什么？** 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> 1、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</span><br><span class="line">　　</span><br><span class="line">　　浏览器缓存可以根据是否需要向服务器重新发起HTTP请求分为两个部分，第一种是💖强制缓存，第二种是💖协商缓存 。</span><br><span class="line">　　　　</span><br><span class="line">　　💖强制缓存的优先级高于协商缓存，</span><br><span class="line">　　所以，首先浏览器要查找当前URL是否存在强制缓存中，</span><br><span class="line">　　如果不存在的话，会向服务器发送请求，并将请求结果存入缓存中；</span><br><span class="line">　　如果强制缓存中存在的话，判断HTTP请求头cache-control中的max-age的时间是否过期，</span><br><span class="line">　　没过期的话，直接使用缓存内容，返回状态码200；</span><br><span class="line">　　过期了的话，需要用到协商缓存，</span><br><span class="line">　　通过Etag（资源的实体标识（哈希字符串））来判断资源内容是否更新，更新的话，Etag会改变，服务器根据If-None-Match（是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值）中携带的上次请求返回的Etag值，判断资源内容是否更新，并发送不同的状态码，如果内容更新的话，返回状态码200，重新向服务器发送请求，返回新资源；如果没更新的话，返回304，读取本地缓存。</span><br><span class="line">　　</span><br><span class="line">　　2、向服务器发送请求，首先需要DNS域名解析</span><br><span class="line">　　这个过程其实就是将域名还原为IP地址的过程。</span><br><span class="line">　　当我们在地址栏直接输入的话，</span><br><span class="line">首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。</span><br><span class="line">　　如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。</span><br><span class="line">　　如果还是没有找到则会查找本地DNS服务器，按照根域服务器（先查询cn域的服务器） -&gt;顶级域,.cn-&gt;第二层域，hb.cn -&gt;子域，www.hb.cn的顺序找到IP地址。</span><br><span class="line">　　</span><br><span class="line">　　3、根据IP建立TCP连接（三次握手）。</span><br><span class="line">第一次握手： 建立连接时，浏览器首先向服务器发送一段报文，表示请求建立新的连接，等待服务器确认； </span><br><span class="line">　　第二次握手： 服务器收到报文后，确认浏览器的报文Seq序号有效，服务器能正常接收浏览器发送的数据，并同意创建新连接；</span><br><span class="line">　　第三次握手：浏览器收到服务器发送的确认收到数据的TCP报文后，再向服务器发送确认的报文，这个报文发送完毕，表示浏览器和服务器连接成功，完成三次握手。</span><br><span class="line"></span><br><span class="line">　　4、完成三次握手后，浏览器向服务器发送HTTP请求。</span><br><span class="line">完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。</span><br><span class="line"></span><br><span class="line">　　5、服务器处理请求，浏览器接收HTTP响应。</span><br><span class="line"></span><br><span class="line">　　6、根据请求的结果渲染页面，构建DOM树。</span><br><span class="line">　　</span><br><span class="line">💖这是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: 重排和重绘。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为重排;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为重绘。</span><br><span class="line"></span><br><span class="line">　　7、关闭TCP连接（四次挥手）。</span><br><span class="line">第一次挥手是浏览器发完数据后，发送一段请求断开连接的报文（FIN）。</span><br><span class="line"></span><br><span class="line">　　第二次挥手是服务器发送一个表示同意断开的报文（ACK），</span><br><span class="line">　　第三次挥手是服务器发送一段请求断开连接的报文（FIN）。</span><br><span class="line">　　</span><br><span class="line">　　第四次挥手是浏览器发送一个表示同意断开的报文（ACK）</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\Administrator\Desktop\1034346-20170329150734545-432760222.jpg" alt="1034346-20170329150734545-432760222"></p>
<h2 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、使用location.reload()</span><br><span class="line">2、使用history.go(0)</span><br></pre></td></tr></table></figure>
<h2 id="服务端更新图片之后，在前端显示图片不更新"><a href="#服务端更新图片之后，在前端显示图片不更新" class="headerlink" title="服务端更新图片之后，在前端显示图片不更新"></a>服务端更新图片之后，在前端显示图片不更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在服务端的图片更新之后，前端的图片没有更新？</span><br><span class="line"></span><br><span class="line">这是因为浏览器首次读取服务端的图片之后，再次读取同名图片，会直接从临时文件中读取，不再请求服务端。如果清除浏览器缓存，则图片更新。</span><br><span class="line"></span><br><span class="line">可以修改图片名，或者给图片src后加上随机数。</span><br><span class="line">var version = Math.random();</span><br><span class="line">&lt;img src=&#123;&quot;./test.png?&quot;+version&#125; /&gt;</span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line">  由于在img的src中增加了随机数参数，多次访问图片时，浏览器认为是访问了不同的图片路径(或者说是访问了不同的图片），浏览器会每次重新访问服务器读取图片， 而不再读取缓存中的图片。</span><br></pre></td></tr></table></figure>
<h2 id="F12调试页面tab使用"><a href="#F12调试页面tab使用" class="headerlink" title="F12调试页面tab使用"></a>F12调试页面tab使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Elements标签页</span><br><span class="line">这个就是查看、编辑页面上的元素，包括HTML和CSS：</span><br><span class="line"></span><br><span class="line">Console控制台</span><br><span class="line">这个除了查看错误信息、打印调试信息（console.log()）、写一些测试脚本</span><br><span class="line"></span><br><span class="line">sources    添加断点，查看执行顺序</span><br><span class="line">network    查看发送的axios请求(请求起始行、请求头、请求体)</span><br><span class="line">application  查看Cookies与localstorage、sessionStorage存储</span><br></pre></td></tr></table></figure>
<h2 id="Cookies与localstorage、sessionStorage的区别-💖💖"><a href="#Cookies与localstorage、sessionStorage的区别-💖💖" class="headerlink" title="Cookies与localstorage、sessionStorage的区别 💖💖"></a>Cookies与localstorage、sessionStorage的区别 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">共同点：都是保存在浏览器端、且同源的 </span><br><span class="line">区别： </span><br><span class="line">   一、cookie数据始终在同源的http请求中携带（即便不须要），即💖cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，能够限制cookie只属于某个路径下 </span><br><span class="line">   二、💖存储大小限制也不一样，cookie数据不能超过4K，同时由于每次http请求都会携带cookie、因此cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，sessionStorage能够达到5M，localStorage能改达到20M </span><br><span class="line">   三、数据有效期不一样，sessionStorage：仅在当前浏览器窗口关闭以前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，所以用做持久数据；cookie：只在设置的cookie过时时间以前有效，即便窗口关闭或浏览器关闭 </span><br><span class="line">   四、做用域不一样，sessionStorage不在不一样的浏览器窗口中共享，即便是同一个页面；localstorage在全部同源窗口中都是共享的；cookie也是在全部同源窗口中都是共享的</span><br><span class="line">   </span><br><span class="line">   1.cookie:</span><br><span class="line">cookie是一个以字符串的形式存储数据的位置,在字符串中以key=value的形式出现,每一个key=value是一条数据,多个数据之间以 ; 分割。每一个 HTTP 请求都会在请求头中携带 cookie 到服务端,每一个 HTTP 响应都会在响应头中携带 cookie 到客户端,也就是,cookie 是不需要我们手动设置，就会自动在 客户端 和 服务端之间游走的数据。</span><br><span class="line"></span><br><span class="line">读取cookie：</span><br><span class="line">const cookie = document.cookie</span><br><span class="line">console.log(cookie) // 就能得到当前 cookie 的值</span><br><span class="line"></span><br><span class="line">设置cookie：</span><br><span class="line">// 下面这个 cookie 数据会在 2043 年 12 月 18 日 12 点以后过期，过期后会自动消失</span><br><span class="line">document.cookie = &apos;b=200;expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;&apos;</span><br><span class="line"></span><br><span class="line">删除cookie：</span><br><span class="line">// 因为 cookie 不能直接删除</span><br><span class="line">// 所以我们只能把某一条 cookie 的过期时间设置成当前时间之前</span><br><span class="line">// 那么浏览器就会自动删除 cookie</span><br><span class="line">document.cookie = &apos;b=200;expires=Thu, 18 Dec 2018 12:00:00 GMT&quot;;&apos;</span><br><span class="line"></span><br><span class="line">2.web本地存储：</span><br><span class="line">没有过期时间,不会跟随服务器发送,大小5M,不用在服务器下运行。</span><br><span class="line">// 设置</span><br><span class="line">localStorage/sessionStorage .setItem(&apos;item&apos;, &apos;abc&apos;)</span><br><span class="line">// 获取</span><br><span class="line">console.log(localStorage/sessionStorage .getItem(&apos;item&apos;))</span><br><span class="line">// 删除</span><br><span class="line">localStorage/sessionStorage .removeItem(&apos;item&apos;)</span><br><span class="line">// 清空</span><br><span class="line">localStorage/sessionStorage .clear()</span><br></pre></td></tr></table></figure>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在react中是单向数据绑定，而在vue中的特色是双向数据绑定</span><br><span class="line"></span><br><span class="line">单向数据流只能从一个方向来修改状态。下图是单向数据流的极简示意：</span><br><span class="line"></span><br><span class="line">简单的单向数据流（unidirectional data flow）是指用户访问View，View发出用户交互的Action，在Action里对state进行相应更新。state更新后会触发View更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</span><br></pre></td></tr></table></figure>
<h2 id="优化-💖💖"><a href="#优化-💖💖" class="headerlink" title="优化 💖💖"></a>优化 💖💖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">合并优化</span><br><span class="line">合并请求的主要目的是减少浏览器对服务器发起的请求数，从而减少在发起请求过程中花费的时间。本测试采用了合并JS、合并CSS以及合并小图片（也就是使用CSS精灵）等方式来减少请求。</span><br><span class="line"></span><br><span class="line">图片内容的懒加载、</span><br><span class="line">组件懒加载（</span><br><span class="line">const Alert = lazy(() =&gt; import(&apos;./components/alert&apos;));</span><br><span class="line">export default function App(props) &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;Suspense fallback=&quot;正在加载中...&quot;&gt;</span><br><span class="line">          &lt;Alert/&gt;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;）</span><br><span class="line"></span><br><span class="line">尽量使用CSS动画代替js动画</span><br><span class="line"></span><br><span class="line">防抖和节流</span><br><span class="line"></span><br><span class="line">使用唯一key优化列表 diff</span><br><span class="line"></span><br><span class="line">数据共享 redux 持久化Keepalive，PersistGate</span><br><span class="line"></span><br><span class="line">加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</span><br><span class="line">默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS 预解析了。</span><br><span class="line"></span><br><span class="line">//用meta信息来告知浏览器, 当前页面要做DNS预解析</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line">在页面header中使用link标签来强制对DNS预解析: </span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot;&gt;</span><br><span class="line"></span><br><span class="line">注意：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询 。</span><br><span class="line"></span><br><span class="line">//如果需要禁止隐式的 DNS Prefetch</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="css的计算属性（calc）"><a href="#css的计算属性（calc）" class="headerlink" title="css的计算属性（calc）"></a>css的计算属性（calc）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在css3样式中有一个类似与函数的计算属性calc()，它主要用于指定元素的长度，无论是border、margin、pading、font-size和width等属性都可以使用calc来设置动态值。calc支持的运算单位有rem , em , %, px，calc是支持单位的混合使用的，其计算优先级别和数学一致。</span><br></pre></td></tr></table></figure>
<h2 id="前端捕获用户使用中的问题"><a href="#前端捕获用户使用中的问题" class="headerlink" title="前端捕获用户使用中的问题"></a>前端捕获用户使用中的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">因此可以在前端页面脚本执行出错时将错误信息上传到服务器，然后打开服务器收集的错误信息进行分析来改进产品的质量</span><br><span class="line"></span><br><span class="line">捕获错误：</span><br><span class="line">try...catch</span><br><span class="line">window.onerror</span><br><span class="line">promise...catch</span><br><span class="line"></span><br><span class="line">addEventListener全局监听</span><br><span class="line">当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个Eerror事件，并执行该元素上的onerror()处理函数。这些error事件能被单一的window.addEventListener捕获。</span><br><span class="line"></span><br><span class="line">上报错误的的方式</span><br><span class="line">上报错误的目的是因为本地定位不到错误，所以可以使用image把错误传到后端，在后端看日志</span><br><span class="line"></span><br><span class="line">动态创建一个Image对象，利用Image对象上报</span><br><span class="line"></span><br><span class="line">function logError(sev, msg)&#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = &quot;log.php?sev=&quot; + encodeURIComponent(sev) + &quot;&amp;msg=&quot; + encodeURIComponent(msg)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承（）</p>
<p>深拷贝浅拷贝的实现方法</p>
<p>axios中文文档</p>
<p>redux</p>
<h2 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">发送请求</span><br><span class="line">axios(config) // 直接传入配置</span><br><span class="line">axios(url,[config]) // 传入url和配置</span><br><span class="line">axios[method](url[, option]) // 直接调用请求方式方法，传入url和配置</span><br><span class="line">axios[method](url[, data[, option]]) // 直接调用请求方式方法，传入data、url和配置</span><br><span class="line">axios.request(option) // 调用 request 方法</span><br><span class="line"></span><br><span class="line">请求拦截器</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">    // 这里写发送请求前处理的代码</span><br><span class="line">    return config;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // 这里写发送请求错误相关的代码</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">响应拦截器</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // 这里写得到响应数据后处理的代码</span><br><span class="line">    return response;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // 这里写得到错误响应处理的代码</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">取消请求</span><br><span class="line">const CancelToken = axios.CancelToken;</span><br><span class="line">const source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&apos;xxxx&apos;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line">// 取消请求 (请求原因是可选的)</span><br><span class="line">source.cancel(&apos;主动取消请求&apos;);</span><br><span class="line"></span><br><span class="line">2、axios有哪些常用方法？</span><br><span class="line">答：</span><br><span class="line">一、axios.get(url[, config]) //get请求用于列表和信息查询</span><br><span class="line">二、axios.delete(url[, config]) //删除</span><br><span class="line">三、axios.post(url[, data[, config]]) //post请求用于信息的添加</span><br><span class="line">四、axios.put(url[, data[, config]]) //更新操作</span><br><span class="line"></span><br><span class="line">3、说下你了解的axios相关配置属性？</span><br><span class="line">答：</span><br><span class="line">url是用于请求的服务器URL</span><br><span class="line">method是创建请求时使用的方法,默认是get</span><br><span class="line">baseURL将自动加在url前面，除非url是一个绝对URL。它可以通过设置一个baseURL便于为axios实例的方法传递相对URL</span><br><span class="line"></span><br><span class="line">headers是即将被发送的自定义请求头</span><br><span class="line">headers:&#123;&apos;X-Requested-With&apos;:&apos;XMLHttpRequest&apos;&#125;,</span><br><span class="line"></span><br><span class="line">params是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象</span><br><span class="line">params:&#123;</span><br><span class="line">ID:12345</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">axios跨域</span><br><span class="line">我们需要额外下载一个三方包http-proxy-middleware，在src目录下新建文件setupProxy.js，配置如下：</span><br><span class="line">const &#123;createProxyMiddleware&#125; = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line">module.exports = function(app) &#123;</span><br><span class="line">  app.use(createProxyMiddleware(&apos;/api&apos;, </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;target&quot;: &quot;https://getman.cn&quot;,</span><br><span class="line">        &quot;changeOrigin&quot;: true,</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写axios实现"><a href="#手写axios实现" class="headerlink" title="手写axios实现"></a>手写axios实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">axios 本质是 xhr 外层包裹 Promise</span><br><span class="line">function axios(url, formdata) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    let xhr = null;</span><br><span class="line"></span><br><span class="line">    if (window.XMLHttpRequest) &#123;</span><br><span class="line">      xhr = new XMLHttpRequest();    //创建一个 ajax 对象</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">        xhr = new ActiveXObject(&quot;smxml2.XMLHTTP&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    xhr.open(&quot;POST&quot;, url);       //发送请求</span><br><span class="line"> </span><br><span class="line">    xhr.onreadystatechange = () =&gt; &#123;              //监听变化触发函数</span><br><span class="line">      if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">        const result = JSON.parse(xhr.responseText);</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    xhr.onerror = (err) =&gt; &#123;          //抛出异常</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    xhr.setRequestHeader(&quot;Authorization&quot;, `Bearer ....`);</span><br><span class="line"> </span><br><span class="line">    xhr.send(formdata);       //发送参数</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="post请求头"><a href="#post请求头" class="headerlink" title="post请求头"></a>post请求头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2 post传参 </span><br><span class="line">	容易发送两次请求</span><br><span class="line">	1 跨域检验  options请求  -- 服务器返回204（意思就是请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面。）才会发送post请求</span><br><span class="line">	2 才会发送post请求   </span><br><span class="line">	post请求转数据格式</span><br><span class="line">	</span><br><span class="line">	这三种不需要检验跨域</span><br><span class="line">	x-www-from-urlencoded</span><br><span class="line">	formData</span><br><span class="line">	text/plain </span><br><span class="line">	</span><br><span class="line">	axios默认格式永远  applcaition/json</span><br><span class="line">	</span><br><span class="line">	import qs from &quot;qs&quot;</span><br><span class="line">	 1) </span><br><span class="line">	 axios.default.post[&quot;Content-Type&quot;] = &quot;application/x-www-from-urlencoded;chaset=utf8&quot;</span><br><span class="line">	 </span><br><span class="line">	 post请求的数据 需要 qs.stringify进行反序列化</span><br><span class="line">	 data:qs.stringify(data)</span><br></pre></td></tr></table></figure>
<h2 id="服务端渲染-客户端渲染"><a href="#服务端渲染-客户端渲染" class="headerlink" title="服务端渲染/客户端渲染"></a>服务端渲染/客户端渲染</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">使用的是客户端渲染</span><br><span class="line">区别：</span><br><span class="line">   最重要的区别就是究竟是谁来完成html文件的完整拼接，如果是在服务器端完成的，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了html的拼接，则就是客户端渲染。</span><br><span class="line">   </span><br><span class="line">服务器端渲染</span><br><span class="line">优点：</span><br><span class="line">    前端耗时少。因为后端拼接完了html，浏览器只需要直接渲染出来。</span><br><span class="line">    有利于SEO（搜索引擎优化）。因为在后端有完整的html页面，所以爬虫更容易爬取获得信息，更有利于seo。</span><br><span class="line">    无需占用客户端资源。即解析模板的工作完全交由后端来做，客户端只要解析标准的html页面即可，这样对于客户端的资源占用更少，尤其是移动端，也可以更省电。</span><br><span class="line">缺点：</span><br><span class="line">    不利于前后端分离，开发效率低。另外，服务器端渲染，前端直接完成html模板，然后交由后端。如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。</span><br><span class="line">    占用服务器端资源。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。</span><br><span class="line"> </span><br><span class="line">客户端渲染</span><br><span class="line">优点：　　</span><br><span class="line">前后端分离。前端专注于前端UI，后端专注于api开发，且前端有更多的选择性，而不需要遵循后端特定的模板。</span><br><span class="line">体验更好。比如，我们将网站做成SPA（单页面应用）或者部分内容做成SPA，这样，尤其是移动端，可以使体验更接近于原生app。</span><br><span class="line">缺点：</span><br><span class="line">前端响应较慢。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。</span><br><span class="line">不利于SEO。</span><br></pre></td></tr></table></figure>
<h2 id="单页面应用（SPA）和多页面应用（MPA）"><a href="#单页面应用（SPA）和多页面应用（MPA）" class="headerlink" title="单页面应用（SPA）和多页面应用（MPA）"></a>单页面应用（SPA）和多页面应用（MPA）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指只有一个主页面的应用，一开始只需加载一次 js,css 等相关资源。所有的内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅刷新局部资源。</span><br><span class="line">指有多个独立的页面的应用，每个页面必须重复加载 js,css 等相关资源。多页应用跳转，需要整页资源刷新。</span><br></pre></td></tr></table></figure>
<h2 id="数组遍历方法"><a href="#数组遍历方法" class="headerlink" title="数组遍历方法"></a>数组遍历方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forEach		遍历数组中的每一项，没有返回值，对原数组没有影响</span><br><span class="line">map（不改变原数组） 		它提供一个回调函数，参数依次为处于当前循环的元素、该元素下标、数组本身，默认返回一个数组，这个新数组的每一个元素都是原数组元素执行了回调函数之后的返回值。</span><br><span class="line">			</span><br><span class="line">filter（不改变原数组）		根据一个条件，对数组元素进行筛选。它提供一个回调函数，参数依次为处于当前循环的元素、该元素下标、数组本身，默认返回一个数组，原数组的元素执行了回调函数之后，返回值若为true，则会将这个元素放入返回的数组中。</span><br><span class="line"></span><br><span class="line">some和every（不改变原数组）  提供一个回调函数，数组的每一个元素都会执行回调函数，</span><br><span class="line">当返回值全部为true时，every方法会返回true，只要有一个为false，every方法返回false。当有一个为true时，some方法返回true，当全部为false时，every方法返回false。</span><br></pre></td></tr></table></figure>
<h2 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回定时器ID</span><br></pre></td></tr></table></figure>
<h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211012133533831.png" alt="image-20211012133533831"></p>
<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。XSS的重点不在于跨站点，而在于脚本的执行。那么XSS的原理是：</span><br><span class="line">恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。</span><br></pre></td></tr></table></figure>
<h2 id="获取dom元素"><a href="#获取dom元素" class="headerlink" title="获取dom元素"></a>获取dom元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">querySelector(&quot;.a&quot;)</span><br><span class="line">getElemenetById(&quot;a&quot;)</span><br></pre></td></tr></table></figure>
<p>主管</p>
<p>金融云</p>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2022/09/11/nodejs/" rel="next" title="nodejs">
                  <i class="fa fa-chevron-left"></i> nodejs
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML-CSS"><span class="nav-number">1.</span> <span class="nav-text">HTML+CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#弹性布局"><span class="nav-number">1.1.</span> <span class="nav-text">弹性布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-块元素垂直居中"><span class="nav-number">1.2.</span> <span class="nav-text">1  块元素垂直居中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-盒模型和怪异盒模型"><span class="nav-number">1.3.</span> <span class="nav-text">2  盒模型和怪异盒模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-解决浮动塌陷"><span class="nav-number">1.4.</span> <span class="nav-text">3  解决浮动塌陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-em-，rem-px-vw-vh"><span class="nav-number">1.5.</span> <span class="nav-text">4 em ，rem , px,  vw,vh</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-边框一像素问题-✨"><span class="nav-number">1.6.</span> <span class="nav-text">5 边框一像素问题 ✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-安卓和iOS兼容问题-—-前端显示的兼容问题"><span class="nav-number">1.7.</span> <span class="nav-text">6  安卓和iOS兼容问题 —- 前端显示的兼容问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-css预处理器"><span class="nav-number">1.8.</span> <span class="nav-text">7 css预处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-H5-新增新特性"><span class="nav-number">1.9.</span> <span class="nav-text">8 H5 新增新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-适配"><span class="nav-number">1.10.</span> <span class="nav-text">9 适配    *</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-响应式布局✨"><span class="nav-number">1.11.</span> <span class="nav-text">10 响应式布局✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-定位"><span class="nav-number">1.12.</span> <span class="nav-text">11 定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-iframe"><span class="nav-number">1.13.</span> <span class="nav-text">12 iframe</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript"><span class="nav-number">2.</span> <span class="nav-text">JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-javascript-数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">1   javascript 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for…in和for…of区别💖💖"><span class="nav-number">2.2.</span> <span class="nav-text">for…in和for…of区别💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forEach和map的区别💖💖"><span class="nav-number">2.3.</span> <span class="nav-text">forEach和map的区别💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-深拷贝、浅拷贝、引用赋值的区别💖💖"><span class="nav-number">2.4.</span> <span class="nav-text">2  深拷贝、浅拷贝、引用赋值的区别💖💖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.4.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-排序"><span class="nav-number">2.5.</span> <span class="nav-text">3  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-去重-（数组方法indexOf、includes、splice和set）💖💖"><span class="nav-number">2.6.</span> <span class="nav-text">4 去重  （数组方法indexOf、includes、splice和set）💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-闭包-💖💖✨"><span class="nav-number">2.7.</span> <span class="nav-text">5  闭包    **💖💖✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-面向对象-—-封装"><span class="nav-number">2.8.</span> <span class="nav-text">6  面向对象    — 封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-继承-继承是为了优化代码，优化性能✨"><span class="nav-number">2.9.</span> <span class="nav-text">8  继承  继承是为了优化代码，优化性能✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-this的指向💖💖"><span class="nav-number">2.10.</span> <span class="nav-text">9  this的指向💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-事件机制-–-eventLoop💖💖✨"><span class="nav-number">2.11.</span> <span class="nav-text">10  事件机制 – eventLoop💖💖✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-重排和重绘"><span class="nav-number">2.12.</span> <span class="nav-text">13 重排和重绘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-解析地址✨"><span class="nav-number">2.13.</span> <span class="nav-text">14 解析地址✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-http-面试-💖💖✨"><span class="nav-number">2.14.</span> <span class="nav-text">16 http 面试 💖💖✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-ES6"><span class="nav-number">2.15.</span> <span class="nav-text">11  ES6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6"><span class="nav-number">3.</span> <span class="nav-text">ES6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-promise💖💖✨"><span class="nav-number">3.1.</span> <span class="nav-text">1 promise💖💖✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-let-const-var-区别-💖💖"><span class="nav-number">3.2.</span> <span class="nav-text">2  let const var  区别 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-箭头函数-💖💖"><span class="nav-number">3.3.</span> <span class="nav-text">3 箭头函数 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-解构赋值"><span class="nav-number">3.4.</span> <span class="nav-text">4  解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-模板字符串"><span class="nav-number">3.5.</span> <span class="nav-text">5 模板字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-class-类"><span class="nav-number">3.6.</span> <span class="nav-text">6  class  类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Set-Map-去重"><span class="nav-number">3.7.</span> <span class="nav-text">7 Set ,Map   去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-symbol-唯一"><span class="nav-number">3.8.</span> <span class="nav-text">9 symbol   唯一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-数组的方法（新增）"><span class="nav-number">3.9.</span> <span class="nav-text">10 数组的方法（新增）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-…-拓展运算符-浅拷贝-深拷贝"><span class="nav-number">3.10.</span> <span class="nav-text">11  … 拓展运算符   浅拷贝/深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-symbol-唯一-用做key值-💖💖"><span class="nav-number">3.11.</span> <span class="nav-text">12  symbol  唯一   用做key值 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-http状态码-💖💖"><span class="nav-number">3.12.</span> <span class="nav-text">16  http状态码 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-axios-post传参与get传参的区别-💖💖"><span class="nav-number">3.13.</span> <span class="nav-text">17  axios post传参与get传参的区别 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-事件流-💖💖-✨"><span class="nav-number">3.14.</span> <span class="nav-text">18 事件流    💖💖 ✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-作用域链"><span class="nav-number">3.15.</span> <span class="nav-text">19 作用域链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-防抖-和-节流"><span class="nav-number">3.16.</span> <span class="nav-text">20 防抖 和 节流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-react💖💖-✨"><span class="nav-number">3.17.</span> <span class="nav-text">21 react💖💖 ✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-react生命周期-💖💖✨"><span class="nav-number">3.18.</span> <span class="nav-text">22 react生命周期 💖💖✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-react-路由传参-💖💖"><span class="nav-number">3.19.</span> <span class="nav-text">23 react 路由传参 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-微信小程序"><span class="nav-number">3.20.</span> <span class="nav-text">24 微信小程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-uniapp"><span class="nav-number">3.21.</span> <span class="nav-text">25  uniapp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-混合开发"><span class="nav-number">3.22.</span> <span class="nav-text">26  混合开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-VUE"><span class="nav-number">3.23.</span> <span class="nav-text">27 VUE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-webpack-基础-💖💖"><span class="nav-number">3.24.</span> <span class="nav-text">29  webpack  基础 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-ajax-💖💖-✨"><span class="nav-number">3.25.</span> <span class="nav-text">31 ajax  💖💖 ✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-事件委托-提高性能-💖💖"><span class="nav-number">3.26.</span> <span class="nav-text">32  事件委托   提高性能 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-BFC-块级格式化上下文"><span class="nav-number">3.27.</span> <span class="nav-text">36 BFC(块级格式化上下文)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-什么是回调函数"><span class="nav-number">3.28.</span> <span class="nav-text">42 什么是回调函数?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reducer✨"><span class="nav-number">3.29.</span> <span class="nav-text">Reducer✨</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redux✨"><span class="nav-number">4.</span> <span class="nav-text">Redux✨</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redux的基本概念"><span class="nav-number">4.1.</span> <span class="nav-text">1 Redux的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Actions"><span class="nav-number">4.2.</span> <span class="nav-text">2 Actions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Store"><span class="nav-number">4.3.</span> <span class="nav-text">3 Store</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻止冒泡相关的三种方法✨"><span class="nav-number">4.4.</span> <span class="nav-text">阻止冒泡相关的三种方法✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Uniapp-页面的生命周期函数有那些？✨"><span class="nav-number">4.5.</span> <span class="nav-text">5 Uniapp 页面的生命周期函数有那些？✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Vue-生命周期"><span class="nav-number">4.6.</span> <span class="nav-text">9 Vue 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-获取dom元素在哪个生命周期？-为什么？"><span class="nav-number">4.7.</span> <span class="nav-text">10 获取dom元素在哪个生命周期？ 为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#💖双向数据绑定原理"><span class="nav-number">4.8.</span> <span class="nav-text">💖双向数据绑定原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨域-✨"><span class="nav-number">4.9.</span> <span class="nav-text">跨域 ✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Post请求✨"><span class="nav-number">4.10.</span> <span class="nav-text">Post请求✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的方法💖💖"><span class="nav-number">4.11.</span> <span class="nav-text">数组的方法💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串方法💖💖"><span class="nav-number">4.12.</span> <span class="nav-text">字符串方法💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型✨✨"><span class="nav-number">4.13.</span> <span class="nav-text">原型✨✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">4.14.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指向-💖💖"><span class="nav-number">4.15.</span> <span class="nav-text">this指向 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VUE和react的区别-💖💖"><span class="nav-number">4.16.</span> <span class="nav-text">VUE和react的区别 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟DOM"><span class="nav-number">4.17.</span> <span class="nav-text">虚拟DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff算法-💖💖"><span class="nav-number">4.18.</span> <span class="nav-text">diff算法 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-当你输入网址的时候经历了什么？-💖💖"><span class="nav-number">4.19.</span> <span class="nav-text">33  当你输入网址的时候经历了什么？** 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#刷新页面"><span class="nav-number">4.20.</span> <span class="nav-text">刷新页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务端更新图片之后，在前端显示图片不更新"><span class="nav-number">4.21.</span> <span class="nav-text">服务端更新图片之后，在前端显示图片不更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#F12调试页面tab使用"><span class="nav-number">4.22.</span> <span class="nav-text">F12调试页面tab使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookies与localstorage、sessionStorage的区别-💖💖"><span class="nav-number">4.23.</span> <span class="nav-text">Cookies与localstorage、sessionStorage的区别 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单向数据流"><span class="nav-number">4.24.</span> <span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化-💖💖"><span class="nav-number">4.25.</span> <span class="nav-text">优化 💖💖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css的计算属性（calc）"><span class="nav-number">4.26.</span> <span class="nav-text">css的计算属性（calc）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端捕获用户使用中的问题"><span class="nav-number">4.27.</span> <span class="nav-text">前端捕获用户使用中的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios封装"><span class="nav-number">4.28.</span> <span class="nav-text">axios封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手写axios实现"><span class="nav-number">4.29.</span> <span class="nav-text">手写axios实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#post请求头"><span class="nav-number">4.30.</span> <span class="nav-text">post请求头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务端渲染-客户端渲染"><span class="nav-number">4.31.</span> <span class="nav-text">服务端渲染/客户端渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单页面应用（SPA）和多页面应用（MPA）"><span class="nav-number">4.32.</span> <span class="nav-text">单页面应用（SPA）和多页面应用（MPA）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组遍历方法"><span class="nav-number">4.33.</span> <span class="nav-text">数组遍历方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时"><span class="nav-number">4.34.</span> <span class="nav-text">定时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拖拽"><span class="nav-number">4.35.</span> <span class="nav-text">拖拽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSS攻击"><span class="nav-number">4.36.</span> <span class="nav-text">XSS攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取dom元素"><span class="nav-number">4.37.</span> <span class="nav-text">获取dom元素</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="WayneLee"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">WayneLee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/waynelee7" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;waynelee7" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail &amp;rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WayneLee</span>
</div>
  <!--<div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  -->
<!--
  <span class="post-meta-divider">|</span>
-->
  <!-- <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div> 
  -->
<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("10/11/2018 00:00:00");//
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "网站已运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>


        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":250,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
