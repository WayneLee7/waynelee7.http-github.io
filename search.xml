<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue-router</title>
    <url>/2018/08/15/Vue-router/</url>
    <content><![CDATA[<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p>
</li>
<li><p>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>
</li>
<li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>
</li>
</ol><a id="more"></a>
<h3 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h3><p>导入 vue-router 组件类库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span><br><span class="line">  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用 router-link 组件来导航</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>使用 router-view 组件来显示匹配到的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>创建使用<code>Vue.extend</code>创建组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 4.1 使用 Vue.extend 来创建登录组件</span><br><span class="line">   var login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 4.2 使用 Vue.extend 来创建注册组件</span><br><span class="line">   var register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span><br><span class="line">    var router = new VueRouter(&#123;</span><br><span class="line">      routes: [</span><br><span class="line">        &#123; path: &apos;/login&apos;, component: login &#125;,</span><br><span class="line">        &#123; path: &apos;/register&apos;, component: register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>使用 router 属性来使用路由规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 6. 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      router: router // 使用 router 属性来使用路由规则</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h3><p>在规则中定义参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; path: &apos;/register/:id&apos;, component: register &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>this.$route.params</code>来获取路由中的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var register = Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   // 父路由中的组件</span><br><span class="line">   const account = Vue.extend(&#123;</span><br><span class="line">     template: `&lt;div&gt;</span><br><span class="line">       这是account组件</span><br><span class="line">       &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | </span><br><span class="line">       &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;</span><br><span class="line">       &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">     &lt;/div&gt;`</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 login 组件</span><br><span class="line">   const login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;登录组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 register 组件</span><br><span class="line">   const register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 路由实例</span><br><span class="line">   var router = new VueRouter(&#123;</span><br><span class="line">     routes: [</span><br><span class="line">       &#123; path: &apos;/&apos;, redirect: &apos;/account/login&apos; &#125;, // 使用 redirect 实现路由重定向</span><br><span class="line">       &#123;</span><br><span class="line">         path: &apos;/account&apos;,</span><br><span class="line">         component: account,</span><br><span class="line">         children: [ // 通过 children 数组属性，来实现路由的嵌套</span><br><span class="line">           &#123; path: &apos;login&apos;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符</span><br><span class="line">           &#123; path: &apos;register&apos;, component: register &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">   var vm = new Vue(&#123;</span><br><span class="line">     el: &apos;#app&apos;,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     methods: &#123;&#125;,</span><br><span class="line">     components: &#123;</span><br><span class="line">       account</span><br><span class="line">     &#125;,</span><br><span class="line">     router: router</span><br><span class="line">   &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-router导航守卫</title>
    <url>/2018/08/29/Vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><p> 其实，导航守卫就是路由跳转过程中的一些钩子函数，再直白点路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。 </p><a id="more"></a>

<p> <strong>导航守卫分为</strong>：全局的、单个路由独享的、组件内的三种。分别来看一下： </p>
<p><strong>【全局的】</strong>：是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数，如下的写法。钩子函数按执行顺序包括<code>beforeEach</code>、<code>beforeResolve</code>（2.5+）、<code>afterEach</code>三个（以下的钩子函数都是按执行顺序讲解的）： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> <strong>全局守卫</strong></p>
<p>[<code>beforeEach</code>]：在路由跳转前触发，参数包括<code>to</code>,<code>from</code>,<code>next</code>（参数会单独介绍）三个，这个钩子作用主要是用于登录验证，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚。 </p>
<p> [<code>beforeResolve</code>]（2.5+）：这个钩子和<code>beforeEach</code>类似，也是路由跳转前触发，参数也是<code>to</code>,<code>from</code>,<code>next</code>三个，和<code>beforeEach</code>区别官方解释为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</span><br></pre></td></tr></table></figure>
<p> 即在 <code>beforeEach</code> 和 组件内<code>beforeRouteEnter</code> 之后，<code>afterEach</code>之前调用。 </p>
<p> [<code>afterEach</code>]：和<code>beforeEach</code>相反，他是在路由跳转完成后触发，参数包括<code>to</code>,<code>from</code>没有了<code>next</code>（参数会单独介绍）,他发生在<code>beforeEach</code>和<code>beforeResolve</code>之后，<code>beforeRouteEnter</code>（组件内守卫，后讲）之前。 </p>
<p><strong>路由守卫</strong></p>
<p><code>beforeEnter</code></p>
<p><strong>组件守卫</strong></p>
<p><code>beforeRouteEnter</code></p>
<p>  // 在渲染该组件的对应路由被 confirm 前调用</p>
<p>  // 不！能！获取组件实例 <code>this</code></p>
<p>  // 因为当守卫执行前，组件实例还没被创建</p>
<p>  虽然无法直接获取组件实力</p>
<p>  但是我们可以通过next参数的回调函数获取到当前实例进行操作</p>
<p>  beforeRouteEnter: (to, from, next) =&gt; {</p>
<pre><code>next((vm) =&gt; {

  //vm就是当前组件实例

});
</code></pre><p>  }</p>
<p><code>beforeRouteUpdate</code></p>
<p>  // 在当前路由改变，但是该组件被复用时调用</p>
<p>  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</p>
<p>  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</p>
<p>  // 可以访问组件实例 <code>this</code></p>
<p><code>beforeRouteLeave</code></p>
<p>  // 导航离开该组件的对应路由时调用</p>
<p>  // 可以访问组件实例 <code>this</code></p>
<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Froute-object.html" target="_blank" rel="noopener">路由对象</a></li>
<li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li>
<li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> （确认的）。</li>
<li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-link.html" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。</li>
<li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.onError()</code></a> 注册过的回调。</li>
</ul>
</li>
</ul>
<p><strong>确保要调用 <code>next</code> 方法，否则钩子就不会被 resolved。</strong></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue实例的生命周期函数</title>
    <url>/2018/08/02/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h2><ul>
<li><p>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</p>
</li>
<li><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p>
</li>
<li><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p>
<h3 id="主要的生命周期函数分类："><a href="#主要的生命周期函数分类：" class="headerlink" title="主要的生命周期函数分类："></a>主要的生命周期函数分类：</h3></li>
</ul><h4 id="创建期间的生命周期函数："><a href="#创建期间的生命周期函数：" class="headerlink" title="创建期间的生命周期函数："></a>创建期间的生命周期函数：</h4><ul>
<li>beforeCreate：刚初始化一个Vue空的实例对象，这个对象上只有一些生命周期函数和默认的事件，此时，还没有初始化好 data 和 methods 的数据</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板（如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作）</li>
<li>beforeMount：开始编辑模板 在内存中生成一个编译好的最终模板字符串，然后渲染为内存中的DOM，此时已经完成了模板的编译，但是还没有挂载到真正的页面中</li>
<li>mounted：此时，表示整个Vue实例已经初始化完毕了，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul><a id="more"></a>

<h4 id="运行期间的生命周期函数："><a href="#运行期间的生命周期函数：" class="headerlink" title="运行期间的生命周期函数："></a>运行期间的生命周期函数：</h4><ul>
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
<h4 id="销毁期间的生命周期函数："><a href="#销毁期间的生命周期函数：" class="headerlink" title="销毁期间的生命周期函数："></a>销毁期间的生命周期函数：</h4><ul>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。实例身上所有的data和所有的methods以及过滤器、指令….都处于可用状态，还没有真正执行销毁的过程</li>
<li>destroyed：Vue 实例销毁后调用。已经完全被销毁，此时实例所有的数据、方法、指令过滤器都不可用了</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2018/09/05/Vuex/</url>
    <content><![CDATA[<h1 id="vuex的基本介绍"><a href="#vuex的基本介绍" class="headerlink" title="vuex的基本介绍"></a><code>vuex</code>的基本介绍</h1><p><code>Vuex</code>是一个专门为<code>Vue.js</code>应用程序开发的状态管理模式。它采用集中式的存储管理应用所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变。 </p><p><code>vuex</code>是<code>vue</code>的状态管理工具，状态即数据， 状态管理就是管理<code>vue</code>中的数据。 </p><h4 id="vuex的优点"><a href="#vuex的优点" class="headerlink" title="vuex的优点"></a><code>vuex</code>的优点</h4><ul>
<li>可以用来解决组件通讯的问题</li>
<li><code>vuex</code>可以用来集中的管理<code>vue</code>项目中用到的所有数据（这并不意味着要将所有的数据都交给<code>vuex</code>进行管理）</li>
</ul><a id="more"></a>


<h4 id="为什么要使用vuex"><a href="#为什么要使用vuex" class="headerlink" title="为什么要使用vuex"></a>为什么要使用<code>vuex</code></h4><ul>
<li>在大型的项目中，组件通讯会变得很混乱，使用<code>vuex</code>可以统一的管理组件之间的通讯。并且可以通过开发者工具，追踪到变化。</li>
<li>当你要开发一个大型的<code>SPA</code>应用的时候，会出现：多个视图公用一个状态、不同视图的行为要改变同一个状态的情况，遇到这种情况的时候就需要考虑使用<code>Vuex</code>了，它会把组件的共享状态抽取出来，当做一个全局单例模式进行管理，这样不管你何时何地改变状态，都会通知到使用该状态的组件做出相应的修改；</li>
</ul>
<p><code>vuex</code>其实就是用一个全局的变量保存了<code>Vue</code>项目中的所有的公共数据，类似与在前端这块放了一个数据库，大家都可以在这里存数据，删数据，改数据，读数据，是不是有点熟悉：增，删，改，查；不过这个全局的变量给他定义了一个固定的名字就叫：<code>store</code>（仓库），是不是很形象，而这个仓库里面装数据的袋子就是<code>state</code>，加工数据的机器就叫做：<code>mutations</code>，操作机器的工人就叫做：<code>actions</code>，把数据装起来取走的卡车就叫做：<code>getters</code>;<br> 所以一个简单的<code>vuex</code>就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new vuex.store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Vuex-特点"><a href="#Vuex-特点" class="headerlink" title="Vuex 特点"></a><code>Vuex</code> 特点</h3><ul>
<li><code>Vuex</code>的状态存储是响应式的。当<code>Vue</code>组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 <code>store</code> 中的状态。改变 <code>store</code> 中的状态的唯一途径就是显式地提交(<code>commit</code>) <code>mutations</code>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ul>
<h3 id="Vuex实例"><a href="#Vuex实例" class="headerlink" title="Vuex实例"></a><code>Vuex</code>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这就是一个<code>vuex</code>的最简单实例，<code>store</code>就是组件中的共享状态，而改变状态的方法(其实是一个对象包含很多方法，但都是来改变<code>store</code>的)叫做:<code>mutations</code>；<br> 需要特变注意的是只能通过<code>mutations</code>改变<code>store</code>的<code>state</code>的状态，不能通过<code>store.state.count = 5</code>;直接更改（其实可以更改，不建议这么做，不通过<code>mutations</code>改变<code>state</code>，状态不会被同步）。<br> 使用<code>store.commit</code>方法触发<code>mutations</code>改变<code>state</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;);</span><br><span class="line">console.log(store.state.count)  // 1</span><br></pre></td></tr></table></figure>
<p> 这样一个简简单单的Vuex应用就实现了。 </p>
<h3 id="在Vue组件里使用Vuex"><a href="#在Vue组件里使用Vuex" class="headerlink" title="在Vue组件里使用Vuex"></a>在<code>Vue</code>组件里使用<code>Vuex</code></h3><p> <code>Vuex</code>的状态获取是一个方法，当<code>Vuex</code>状态更新时，相应的<code>Vue</code>组件也要更新，所以<code>Vue</code>应该在计算属性（<code>computed</code>）获取<code>state</code>； </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return store.state.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面的例子是直接操作全局状态<code>store.state.count</code>，那么每个使用该<code>Vuex</code>的组件都要引入。为了解决这个，<code>Vuex</code>通过<code>store</code>选项，提供了一种机制将状态从根组件注入到每一个子组件中。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 根组件</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    store,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Counter</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">            &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 通过这种注入机制，就能在子组件<code>Counter</code>通过<code>this.$store</code>访问： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return this.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mapState函数"><a href="#mapState函数" class="headerlink" title="mapState函数"></a><code>mapState</code>函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">        return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这样通过<code>count</code>计算属性获取同名<code>state.count</code>属性，是不是显得太重复了，我们可以使用<code>mapState</code>函数简化这个过程。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: state =&gt; state.count,</span><br><span class="line">        countAlias: &apos;count&apos;,    // 别名 `count` 等价于 state =&gt; state.count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 还有更简单的使用方法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h5 id="Getters对象"><a href="#Getters对象" class="headerlink" title="Getters对象"></a><code>Getters</code>对象</h5><p> 如果我们需要对<code>state</code>对象进行做处理计算，如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数。这样是很没有效率的事情，当这个处理过程更改了，还有在多个组件中进行同样的更改，这就更加不易于维护。</p>
<p><code>Vuex</code>中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理。<code>Getters</code>接受<code>state</code>作为第一个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 在<code>Vue</code>中通过<code>store.getters</code>对象调用。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodos () &#123;</span><br><span class="line">    return this.$store.getters.doneTodos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>Getter</code>也可以接受其他<code>getters</code>作为第二个参数： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">  &#125;,</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue组件</title>
    <url>/2018/08/12/Vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h3><p>什么是组件： 组件的出现，就是为了拆分<code>Vue</code>的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul>
<li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li>
<li>组件化： 是从<code>UI</code>界面的角度进行划分的；前端的组件化，方便<code>UI</code>组件的重用；</li>
</ul><a id="more"></a>

<h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><p>1、使用<code>Vue. extend</code>配合<code>Vue.component</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> login=Vue.extend(&#123;</span><br><span class="line">		template:<span class="string">'&lt;h1&gt;登陆组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line">		Vue.component(<span class="string">'login'</span>,login)</span><br></pre></td></tr></table></figure>
<p>2、直接使用<code>Vue.component</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'register'</span>,&#123;</span><br><span class="line">		template:<span class="string">'&lt;h1&gt;注册组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3、将模板字符串，定义到<code>script</code>标签中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>同时需要使用<code>Vue.component</code>来注册组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;,&#123;</span><br><span class="line">		template:&apos;#tmp1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意： 组件中的<code>DOM</code>结构，有且只能有唯一的根元素（<code>Root Element</code>）来进行包裹！</p>
<h3 id="组建中展示数据和响应事件"><a href="#组建中展示数据和响应事件" class="headerlink" title="组建中展示数据和响应事件"></a>组建中展示数据和响应事件</h3><p>1、在组件中，<code>data</code>需要被定义为一个方法</p>
<p> 组件中的<code>data</code>写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份<code>data</code>，就会造成一个变了全都会变的结果。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'account'</span>, &#123;</span><br><span class="line">      template: <span class="string">'#tmpl'</span>,</span><br><span class="line">      data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          msg: <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(<span class="string">'点击了登录按钮'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>2、在子组件中。如果将模板字符串定义到了<code>script</code>标签中了，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue自定义指令</title>
    <url>/2018/07/27/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。</p><p>自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。</p><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><p><strong>bind：</strong>只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。</p><a id="more"></a>



<p><strong>inserted：</strong>被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p><strong>update：</strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
<p><strong>componentUpdated：</strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>
<p><strong>unbind：</strong>只调用一次，指令与元素解绑时调用。</p>
<h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><p>指令钩子函数会被传入以下参数：</p>
<p>el：指令所绑定的元素，可以用来直接操作 DOM 。<br>binding：一个对象，包含以下属性：<br>name：指令名，不包括 v- 前缀。<br>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1”中，表达式为 “1 + 1”。<br>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。<br>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。<br>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue1.0中提供了一个Vue.directive(自定义指令名称，回调函数)来供程序员自定义指令</span></span><br><span class="line"><span class="comment">//注意:在定义指令时不需要加v-前缀但是使用时必须加v-前缀</span></span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 聚焦元素</span></span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个v-color指令</span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素被绑定时</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>) </span>&#123;</span><br><span class="line">        el.style.color = binding.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>使用自定义指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus v-color=&quot;customColor&quot; placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">    el: &apos;#app-4&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">	directives: &#123;</span><br><span class="line">        focus: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            inserted: function(el) &#123;</span><br><span class="line">                el.focus()</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 使用自定义元素 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue计算属性</title>
    <url>/2018/08/16/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p> 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。 </p>
<p>表达式里面包含了3个操作，有时候可能会更加复杂，这时我们可以使用计算属性。如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;reversedText&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                text: &apos;123,456&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            reversedText: function () &#123;</span><br><span class="line">                //这里的this指向的是当前的vue实例</span><br><span class="line">                return this.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;);  //如果这两的text是后台接受的数据，最好加个判断数据为不为空</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 所有计算属性都以函数的形式写在<code>Vue</code>实例内的<code>computed</code>选项内，最终返回计算后的结果 </p>
<h3 id="计算属性用法"><a href="#计算属性用法" class="headerlink" title="计算属性用法"></a>计算属性用法</h3><p>在一个计算属性里可以完成各种复杂的逻辑，包括逻辑运算、函数调用等，只要最终返回一个结果就可以。除了上面的简单的用法，计算属性还可以依赖多个<code>vue</code>实例的数据，只要其中任意一个数据变化，计算属性就会重新执行，视图也会更新，例如下面的例子展示的是购物车内两个包裹的物品总价 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;prices&quot;&gt;</span><br><span class="line">         总价： &#123;&#123;prices&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">       // &lt;!--购物车总价--&gt;</span><br><span class="line">        var prices = new Vue(&#123;</span><br><span class="line">            el: &quot;#prices&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                package1: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为mate20pro&quot;,</span><br><span class="line">                    price: 4566,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为p30&quot;,</span><br><span class="line">                    price: 4166,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                ],</span><br><span class="line">                package2: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;苹果&quot;,</span><br><span class="line">                    price: 30,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;香蕉&quot;,</span><br><span class="line">                    price: 2,</span><br><span class="line">                    count: 20</span><br><span class="line">                &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                prices: function () &#123;</span><br><span class="line">                    var prices = 0;</span><br><span class="line">                    debugger</span><br><span class="line">                    for (var i = 0; i &lt; this.package1.length; i++) &#123;</span><br><span class="line">                        prices += this.package1[i].price * this.package1[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (var i = 0; i &lt; this.package2.length; i++) &#123;</span><br><span class="line">                        prices += this.package2[i].price * this.package2[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return prices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 当package1或package2中的商品发生变化，比如购买数量变化或者增删商品时，计算属性prices就会自动更新，视图中的总价也会自动变化<br>每个计算属性都包含一个getter和setter，上面的例子都是计算属性默认用法，只是利用了getter来读取。在你需要时，也可以提供一个setter函数，当手动修改计算属性的值就像修改一个普通数据那样，就会触发setter函数，执行一些自定义的操作。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--setter--&gt;</span><br><span class="line">        &lt;div id=&quot;setter&quot;&gt;</span><br><span class="line">         姓名： &#123;&#123;fullName&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> var setter = new Vue(&#123;</span><br><span class="line">            el: &quot;setter&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                firstName: &apos;Jack&apos;,</span><br><span class="line">                lastName:&apos;Green&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                fullName: &#123;</span><br><span class="line">                    //getter,用于读取</span><br><span class="line">                    get: function ()</span><br><span class="line">                    &#123;</span><br><span class="line">                        return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">                    &#125;,</span><br><span class="line">                    //setter，写入时触发</span><br><span class="line">                    set: function (newValue)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var names = newValue.split(&apos; &apos;);</span><br><span class="line">                        this.firstName = names[0];</span><br><span class="line">                        this.lastName = names[1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 当执行 setter.fullName=’Join Doe’时候，setter就会被调用，数据firstName和lastName都会相对更新，视图同样也会更新<br>    绝大多情况下，我们只会使用默认的getter方法来读取一个计算属性，在业务中很少使用到setter，所以在声明一个计算属性的时候，可以直接使用默认的写法，不必将getter和setter都声明<br>   计算属性除啦以上简单的文本插值外，还经常用于动态的设置元素的样式名称class和内联样式style，当使用组件时，计算属性也经常用来动态传递props以后，我会慢慢介绍到<br>计算属性还有两个很使用的小技巧很容易被忽略，一是计算属性可以依赖其他计算属性，二是计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他Vue实例的数据 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;div id=&quot;app2&quot;&gt;</span><br><span class="line">         &#123;&#123;reversedText&#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var app1 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app1&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: &quot;123,456&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var app2 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app2&quot;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                reversedText: function () &#123;</span><br><span class="line">                    //这里是依赖app1实例中的数据text</span><br><span class="line">                    return app1.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 这里我们创建了两个vue实例app1和app2，在app2的计算属性reversedText中，依赖的是app1的数据text，所以当text变化时，实例app2的计算属性也会变化，这样的用法以后用到的也会比较多，尤其是在多人协同开发时很常用，以为你写的组件所用到的数据需要依赖他人的组件提供，以后接触的多了就会慢慢的意识到这一点。 </p>
<h3 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a><strong>计算属性缓存</strong></h3><p> 其实细心的话就会发现，调用methods里的方法也能实现和计算属性一样的效果，甚至有的方法还能接收参数，使用起来更加的灵活，既然使用methods就可以实现，那为什么还需要计算属性呢？原因就是计算属性是基于他的依赖缓存的。一个计算属性所依赖的数据发生变化时，他才会重新取值，<br>所以依赖的text只要不改变。计算属性也就不更新 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed：&#123;</span><br><span class="line">now：function()</span><br><span class="line"> 	&#123;</span><br><span class="line">		return Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里的<code>Date.now()</code>不是响应式依赖，所以计算属性<code>now</code> 不会更新，但是<code>methods</code>则不同，只要重新渲染他就会被调用，因此函数也会被执行。<br>使用计算属性还是<code>methods</code>取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存 </p>
<p><code>methods</code>和计算属性<code>computed</code> 实现的最终效果其实是一样的，然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 数据  没有发生改变，多次访问 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用<code>methods</code>方法将总会再次执行函数。</p>
<p>计算属性的求值结果会被缓存起来，方便下次直接使用，如果计算属性方法中所依赖的任何数据都没有发生过改变，则不会重新对计算属性求值。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack5</title>
    <url>/2022/09/06/Webpack5/</url>
    <content><![CDATA[<p>文章转载自 <a href="https://lab.puji.design/" target="_blank" rel="noopener">PUJI 实验室</a> 仅供个人复习查阅</p><h1 id="Webpack-5"><a href="#Webpack-5" class="headerlink" title="Webpack 5"></a>Webpack 5</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Webpack 是一种前端资源构建工具，静态模块打包器 ( module bundler )。在 Webpack 看来，前端的所有资源文件 ( js / json / css / img / less / … ) 都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源 ( module )。</p><a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先使用npm init初始化项目 然后安装webpack以及webpack-cli</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局安装</span><br><span class="line">npm i webpack webpack-cli -g</span><br><span class="line">本地安装</span><br><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在文件根目录新建webpack.config.js配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line"></span><br><span class="line">module.exports=&#123;</span><br><span class="line">	entry:&apos;./assets/js/main.js&apos;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&apos;app.js&apos;,</span><br><span class="line">		path:path.resolve(__dirname,&apos;dist&apos;)</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugin:[],</span><br><span class="line">	mode:&apos;development&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h3><p>使用本地环境进行打包输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Entry入口"><a href="#Entry入口" class="headerlink" title="Entry入口"></a>Entry入口</h3><p>指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>
<h3 id="Output输出"><a href="#Output输出" class="headerlink" title="Output输出"></a>Output输出</h3><p>指示webpack打包后的资源bundles输出到哪里，以及如何命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&apos;app.js&apos;,//输出文件名称</span><br><span class="line">		path:path.resolve(__dirname,&apos;dist&apos;),//输出文件路径</span><br><span class="line">		clean:true//删除不需要的旧文件</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Loader解析器"><a href="#Loader解析器" class="headerlink" title="Loader解析器"></a>Loader解析器</h3><p>让webpack能够去处理那些非js文件（webpack自身只理解js）</p>
<h3 id="Plugin插件"><a href="#Plugin插件" class="headerlink" title="Plugin插件"></a>Plugin插件</h3><p>可以用于执行范围更广的任务。插件的范围包括 从打包优化和压缩，一直到重新定义环境中的变量等。</p>
<h3 id="Mode模式"><a href="#Mode模式" class="headerlink" title="Mode模式"></a>Mode模式</h3><p>指示webpack使用相应模式的配置</p>
<ul>
<li>development 开发模式 ：会将process.env.NODE_ENV的值设为development。启用NameChunksPlugin和NameModulesPlugin。特点是能让代码本地调试运行的环境</li>
<li>production 生产模式：会将process.env.NODE_ENV的值设为production。启用FlagDependencyUsagePlugin，FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin。特点是能让代码优化上线运行的环境</li>
<li>node</li>
</ul>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p>在开发环境中，用于自动编译并自动刷新页面。方便开发过程中的调试。注：该功能只会在内存中编译打包，不会有任何文件输出，如需更新到生产环境中，还需重新打包代码。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		static:&apos;./dist&apos;//环境目录</span><br><span class="line">		compress:true//设置gzip压缩，提高传输效率</span><br><span class="line">		host:&apos;0.0.0.0&apos;//设置服务器主机</span><br><span class="line">		port:3000,//设置端口号</span><br><span class="line">		historyApiFallback:true//设置路由</span><br><span class="line">		open:true//自动打开页面</span><br><span class="line">		watchFiles:&#123;//更改后自动刷新</span><br><span class="line">		 paths:[</span><br><span class="line">		 	&apos;./*&apos;</span><br><span class="line">		 ],</span><br><span class="line">		 options:&#123;</span><br><span class="line">		 	usePolling:false</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		liveReload:true//启用热加载</span><br><span class="line">		hot:true//启用热模块</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack-dev-server</span><br></pre></td></tr></table></figure>
<h2 id="资源模块-Asset-Modules"><a href="#资源模块-Asset-Modules" class="headerlink" title="资源模块 Asset Modules"></a>资源模块 Asset Modules</h2><p>官方说明：<a href="https://webpack.docschina.org/guides/asset-modules" target="_blank" rel="noopener">https://webpack.docschina.org/guides/asset-modules</a></p>
<p>该方法需将资源在js中通过import进行导入或css中进行导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//js文件导入</span><br><span class="line">import 命名 from &apos;资源路径&apos;</span><br><span class="line">//css文件引用</span><br><span class="line">.box&#123;</span><br><span class="line">	background-image:url(&apos;资源路径&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源模块类型</p>
<ul>
<li>asset/resource：发送一个单独的文件并导出URL</li>
<li>asset/inline：导出一个资源的Data URL（64位图）</li>
<li>asset/source：导出资源的源代码</li>
<li>asset：在导出一个资源的Data URL和发送一个单独的文件之间自动选择</li>
</ul>
<h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.png$/i,//监听资源文件</span><br><span class="line">				type:&apos;asset/resource&apos;,//设置资源类型</span><br><span class="line">				generator:&#123;</span><br><span class="line">				filename:&apos;assets/images/[name][ext]&apos;//生成资源名称</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源名称可以使用[contenthash][ext]将资源名称生成为hash值命名</p>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // 监听资源文件</span><br><span class="line">        test: /\.svg$/i,</span><br><span class="line">        // 设置资源类型</span><br><span class="line">        type: &apos;asset/inline&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // 监听资源文件</span><br><span class="line">        test: /\.txt$/i,</span><br><span class="line">        // 设置资源类型</span><br><span class="line">        type: &apos;source&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="asset"><a href="#asset" class="headerlink" title="asset"></a>asset</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // 监听资源文件</span><br><span class="line">        test: /\.jpg$/i,</span><br><span class="line">        // 设置资源类型</span><br><span class="line">        type: &apos;asset&apos;,</span><br><span class="line">        // 小于设置的大小则转为 64 位图，否则转 URL</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: 4 * 1024 // 4kb</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          // 生成资源名称</span><br><span class="line">          filename: &apos;assets/images/[name][ext]&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源处理"><a href="#资源处理" class="headerlink" title="资源处理"></a>资源处理</h2><h3 id="HTML资源"><a href="#HTML资源" class="headerlink" title="HTML资源"></a>HTML资源</h3><p>打包html</p>
<ol>
<li><p>下载 html-webpack-plugin 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2 在webpack.config.js 文件中引入插件并调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	plugin:[</span><br><span class="line">		//打包html文件</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			template:&apos;./index.html&apos;//指定html模板文件</span><br><span class="line">			inject:&apos;body&apos;//指定script标签位置</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack会在输出目录中新创建一个html文件，在原始的html文件中无需引入js文件，通过webpack 变异后的html文件会自动引入。</p>
<p>官方说明：<a href="https://webpack.docschina.org/plugins/html-webpack-plugin/" target="_blank" rel="noopener">https://webpack.docschina.org/plugins/html-webpack-plugin/</a></p>
<p>配置选项：<a href="https://github.com/jantimon/html-webpack-plugin#options" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin#options</a></p>
<h3 id="样式资源"><a href="#样式资源" class="headerlink" title="样式资源"></a>样式资源</h3><p><strong>打包css资源</strong></p>
<p>下载样式处理解析器 css-loader与style-loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i css-loader style-loader -D</span><br></pre></td></tr></table></figure>
<p>在配置文件中添加解析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	module:&#123;</span><br><span class="line">		rule:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.css$/i,</span><br><span class="line">				use:[&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在js文件中导入css文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;../css/main.css&apos;</span><br></pre></td></tr></table></figure>
<p><strong>打包scss资源</strong></p>
<p>下载样式处理解析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i sass-loader sass -D</span><br></pre></td></tr></table></figure>
<p>在配置文件中添加解析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.scss$/i,</span><br><span class="line">				use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在js文件中导入scss文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;../css/main.scss&apos;</span><br></pre></td></tr></table></figure>
<p><strong>抽离css代码为独立文件</strong></p>
<p>下载插件 mini-css-extract-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>
<p>引用插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line">module.exports=&#123;</span><br><span class="line">	...</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.s[ac]ss/i,</span><br><span class="line">				use:[</span><br><span class="line">					MiniCssExtractPlugin.loader,</span><br><span class="line">					&apos;css-loader&apos;,</span><br><span class="line">					&apos;sass-loader&apos;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">	 new MiniCssExtractPlugin(&#123;</span><br><span class="line">	 	filename:&apos;asstrs/css/[name].css&apos;</span><br><span class="line">	 &#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是生成模式，将自动压缩css文件，无需额外配置</p>
<p>官方文档：<a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin" target="_blank" rel="noopener">https://webpack.docschina.org/plugins/mini-css-extract-plugin</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=30" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=30</a></p>
<p><strong>css代码压缩 （生产模式）</strong></p>
<p>安装插件 css-minimizer-webpack-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>在配置文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      // 使用插件优化 css 代码</span><br><span class="line">      new CssMinimizerPlugin()</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  // 模式</span><br><span class="line">  mode: &apos;production&apos; **</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>压缩 CSS 代码，仅在生产模式下有效</li>
</ul>
<p>官方文档：<a href="https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/" target="_blank" rel="noopener">https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/</a></p>
<p><strong>CSS 兼容性处理</strong></p>
<p>下载 postcss-loader, postcss, postcss-preset-env 模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i postcss-loader postcss postcss-preset-env -D</span><br></pre></td></tr></table></figure>
<p>在根目录下创建 postcss.config.js 文件并进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &apos;postcss-preset-env&apos;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 其他选项</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.s[ac]ss$/i,</span><br><span class="line">        use: [</span><br><span class="line">          // 抽离 css 为独立文件</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          // 将 css 文件整合到 js 文件中</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          // css 兼容处理</span><br><span class="line">          &apos;postcss-loader&apos;,</span><br><span class="line">          // 编译 sass 文件为 css 文件</span><br><span class="line">          &apos;sass-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      // 对输出结果重命名</span><br><span class="line">      filename: &apos;assets/css/[name].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postcss-preset-env 帮助 postcss 找到 package.json 中 browserslist 里的配置，通过配置加载指定的 css 兼容性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在 package.json 中添加浏览器列表</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;browserslist&quot;: &#123;</span><br><span class="line">    &quot;development&quot;: [</span><br><span class="line">      &quot;last 1 chrome version&quot;,</span><br><span class="line">      &quot;last 1 firfoxe version&quot;,</span><br><span class="line">      &quot;last 1 safari version&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;production&quot;: [</span><br><span class="line">      &quot;&gt;0.2%&quot;,</span><br><span class="line">      &quot;not dead&quot;,</span><br><span class="line">      &quot;not op_mini all&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1e7411j7T5?p=13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=13</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=67" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=67</a></p>
<h3 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源 *"></a>图片资源 *</h3><p>下载图片处理解析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i url-loader file-loader html-loader -D</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="字体资源"><a href="#字体资源" class="headerlink" title="字体资源"></a>字体资源</h3><h3 id="字体资源-1"><a href="#字体资源-1" class="headerlink" title="字体资源"></a>字体资源</h3><p>通过 CSS 引入字体资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &apos;PujiSansExpandedHeavy&apos;;</span><br><span class="line">  src: url(&apos;../fonts/PujiSans-ExpandedHeavy.eot&apos;); /* IE9 Compat Modes */</span><br><span class="line">  src: url(&apos;../fonts/PujiSans-ExpandedHeavy.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */</span><br><span class="line">    url(&apos;../fonts/PujiSans-ExpandedHeavy.woff2&apos;) format(&apos;woff2&apos;), /* Modern Browsers */</span><br><span class="line">    url(&apos;../fonts/PujiSans-ExpandedHeavy.woff&apos;) format(&apos;woff&apos;), /* Modern Browsers */</span><br><span class="line">    url(&apos;../fonts/PujiSans-ExpandedHeavy.ttf&apos;) format(&apos;truetype&apos;); /* Safari, Android, iOS */</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  text-rendering: optimizeLegibility;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 webpack.config.js 文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // 监听资源文件</span><br><span class="line">        test: /\.(woff|woff2|eot|ttf|otf)$/i,</span><br><span class="line">        // 设置资源类型</span><br><span class="line">        type: &apos;asset/resource&apos;,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          // 生成资源名称</span><br><span class="line">          filename: &apos;assets/fonts/[name][ext]&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据资源"><a href="#数据资源" class="headerlink" title="数据资源"></a>数据资源</h3><p>如需导入 CSV, TSV, XML 等数据格式文件，需使用相关的数据 loader 进行加载</p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=33" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=33</a></p>
<h3 id="自定义-JSON-资源"><a href="#自定义-JSON-资源" class="headerlink" title="自定义 JSON 资源"></a>自定义 JSON 资源</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=34" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=34</a></p>
<h3 id="JS-资源"><a href="#JS-资源" class="headerlink" title="JS 资源"></a>JS 资源</h3><p><strong>JS 语法检查</strong></p>
<p>使用 eslint 扫描我们所写的代码是否符合规范，严格意义上来说，eslint 配置跟 webpack 无关，但在工程化开发环境中，他往往是不可或缺的。</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i eslint -D</span><br></pre></td></tr></table></figure>
<p>创建配置文件，根据提示选择需要的类型。配置完成后，将在 node_modules 文件夹中生成一个 .eslintrc.json 文件，将文件复制到根目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx eslint --init</span><br></pre></td></tr></table></figure>
<p><img src="https://lab.puji.design/wp-content/uploads/2022/04/%E6%88%AA%E5%B1%8F2022-04-03-%E4%B8%8B%E5%8D%886.00.15-1024x154.png" alt="img"></p>
<p>在 VSCode 中安装扩展 Eslint ，重启软件后将自动生效。</p>
<p><strong>JS 兼容处理</strong></p>
<p>将 ES6 代码转换为低版本 ES 代码</p>
<p>安装模块</p>
<ul>
<li><strong>babel-loader</strong>： 在 webpack 里应用 babel 解析 ES6 的桥梁</li>
<li><strong>@babel/core</strong>： babel 核心模块</li>
<li><strong>@babel/preset-env</strong>： babel 预设，一组 babel 插件的集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.m?js$/,</span><br><span class="line">        // 排除 node_modules 中安装的库</span><br><span class="line">        exclude: /(node_modules|bower_components)/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          // 加载 loader</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            // 配置预设</span><br><span class="line">            presets: [&apos;@babel/preset-env&apos;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>regeneratorRuntime</strong></p>
<p>regeneratorRuntime 是 webpack 打包生成的全局辅助函数，由 babel 生成，用于兼容 async/await 的语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i @babel/runtime @babel/plugin-transform-runtime -D</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.m?js$/,</span><br><span class="line">        // 排除 node_modules 中安装的库</span><br><span class="line">        exclude: /(node_modules|bower_components)/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          // 加载 loader</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            // 配置预设</span><br><span class="line">            presets: [&apos;@babel/preset-env&apos;]</span><br><span class="line">            plugins: [</span><br><span class="line">              [</span><br><span class="line">                &apos;@babel/plugin-transform-runtime&apos;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JS 压缩</strong></p>
<p>安装插件 terser-webpack-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i terser-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      // 使用插件压缩 js 代码 (生产模式)</span><br><span class="line">      new TerserWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="公共路径-publicPath"><a href="#公共路径-publicPath" class="headerlink" title="公共路径 publicPath"></a>公共路径 publicPath</h3><p>publicPath 配置公共路径，所有文件的引用将自动添加公共路径的绝对地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  output: &#123;</span><br><span class="line">    ...</span><br><span class="line">    publicPath: &apos;https://localhost:3000/&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环境变量-Environment-variable"><a href="#环境变量-Environment-variable" class="headerlink" title="环境变量 Environment variable"></a>环境变量 Environment variable</h3><p>环境变量可以消除 webpack.config.js 在开发环境和生产环境之间的差异</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = ( env ) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...</span><br><span class="line">    mode: env.production ? &apos;production&apos; : &apos;development&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包命令时如果使用生产模式，则在命令后增加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack --env production</span><br></pre></td></tr></table></figure>
<h3 id="配置文件优化"><a href="#配置文件优化" class="headerlink" title="配置文件优化"></a>配置文件优化</h3><p>分别对 development 和 production 两种模式优化。完整配置文件可查看本页下方 “完整配置”。</p>
<p>1、首先新建 webpack-config 文件夹，在文件夹中添加三个文件，分别为通用的配置文件、开发模式的配置文件以及生产模式的配置文件。</p>
<p>2、使用 webpack-merge 将文件进行合并。安装 webpack-merge</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i webpack-merge -D</span><br></pre></td></tr></table></figure>
<p>3、添加一个合并文件 webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; merge &#125; = require(&apos;webpack-merge&apos;)</span><br><span class="line"></span><br><span class="line">const commonConfig = require(&apos;./webpack.config.common&apos;)</span><br><span class="line">const developmentConfig = require(&apos;./webpack.config.dev&apos;)</span><br><span class="line">const productionConfig = require(&apos;./webpack.config.prod&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = (env) =&gt; &#123;</span><br><span class="line">  switch(true) &#123;</span><br><span class="line">    case env.development:</span><br><span class="line">      return merge(commonConfig, developmentConfig)</span><br><span class="line"></span><br><span class="line">    case env.production:</span><br><span class="line">      return merge(commonConfig, productionConfig)</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      return new Error(&apos;No matching configuration was found.&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、修改 package.json 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将自定义的命令分别指向相应的文件以及添加 env 环境变量的参数</span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack serve -c ./webpack-config/webpack.config.js --env development&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack -c ./webpack-config/webpack.config.js --env production&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、使用命令运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<h3 id="HMR-开发环境"><a href="#HMR-开发环境" class="headerlink" title="HMR ( 开发环境 )"></a>HMR ( 开发环境 )</h3><p>Hot module replacement 热模块替换，可使一个模块发生变化，只重新打包这一个模块，而非全部重新打包，可以更快速的构建代码打包速度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 开启 HMR 功能</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=60" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=60</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1e7411j7T5?p=20" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=20</a></p>
<h3 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h3><p>一种提供源代码到构建后代码映射的技术，如果构建后代码出错了，通过映射关系可以追踪源代码的错误。在 webpack.config.js 文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  devtool: &apos;source-map&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用的几种-source-map-类型"><a href="#常用的几种-source-map-类型" class="headerlink" title="常用的几种 source-map 类型"></a>常用的几种 source-map 类型</h4><ul>
<li>source-map：生成外部文件，错误代码的准确信息和源代码的错误位置</li>
<li>inline-source-map：内联，错误代码的准确信息和源代码的错误位置。在代码底部生成，构建速度比外部文件更快</li>
<li>hidden-source-map：生成外部文件，错误代码的原因，没有错误位置，无法追踪源代码错误。</li>
<li>eval-source-map：内联，错误代码的准确信息和源代码的错误位置。每一个文件都生成对应的 source-map</li>
<li>nosources-source-map：生成外部文件，</li>
<li>cheap-source-map：生成外部文件，错误代码的准确信息和源代码的错误位置。只精确到行</li>
<li>cheap-module-source-map：同 cheap-source-map，会将 loader 的 source map 加入</li>
</ul>
<h5 id="开发环境建议"><a href="#开发环境建议" class="headerlink" title="开发环境建议"></a>开发环境建议</h5><ul>
<li><strong>eval-source-map</strong></li>
<li>eval-cheap-module-source-map</li>
</ul>
<h5 id="生产环境建议"><a href="#生产环境建议" class="headerlink" title="生产环境建议"></a>生产环境建议</h5><ul>
<li><strong>source-map</strong></li>
<li>nosources-source-map</li>
<li>hidden-source-map</li>
</ul>
<h3 id="Oneof-生产模式"><a href="#Oneof-生产模式" class="headerlink" title="Oneof ( 生产模式 )"></a>Oneof ( 生产模式 )</h3><p>每个loader只会匹配一个，不能有两个配置处理一个类型的文件</p>
<p><a href="https://www.bilibili.com/video/BV1e7411j7T5?p=22" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=22</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        oneOf:[</span><br><span class="line">          &#123;</span><br><span class="line">            // 处理 css 资源</span><br><span class="line">            test: /\.css$/i,</span><br><span class="line">            use: [...CommonCssLoader]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            // 处理 scss 资源</span><br><span class="line">            test: /\.s[ac]ss$/i,</span><br><span class="line">            use: [...CommonCssLoader, &apos;sass-loader&apos;]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            // 处理图片资源</span><br><span class="line">            test: /\.(jpg|jpeg|png|gif)$/i,</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 8 * 1024,</span><br><span class="line">              name: &apos;[hash:12].[ext]&apos;,</span><br><span class="line">              esModule: false,</span><br><span class="line">              outputPath: &apos;images&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            // 处理 html 中的图片资源</span><br><span class="line">            test: /\.html$/i,</span><br><span class="line">            loader: &apos;html-loader&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tree-shaking-生产模式"><a href="#Tree-shaking-生产模式" class="headerlink" title="Tree shaking ( 生产模式 )"></a>Tree shaking ( 生产模式 )</h3><p>去除应用程序中没有使用的代码，可更大程度的优化代码。必须使用 ES6 模块化，并开启 production 模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; module &#125; from &apos;./filename.js&apos;</span><br></pre></td></tr></table></figure>
<p>如果不需要某些文件被 webpack 清除，可以在 package.json 中配置 sideEffects 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sideEffects&quot;: [&quot;*.css&quot; ,&quot;*.scss&quot;, &quot;*.global.js&quot;...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Code-split-生产模式"><a href="#Code-split-生产模式" class="headerlink" title="Code split ( 生产模式 )"></a>Code split ( 生产模式 )</h3><p>代码分离是 webpack 中最引人瞩目的特性之一，可将代码分离到不同的文件中，然后将这些文件按需加载或并行加载，同时还可以获取代码加载的优先级。</p>
<h4 id="方法1-入口起点-不推荐"><a href="#方法1-入口起点-不推荐" class="headerlink" title="方法1: 入口起点( 不推荐 )"></a>方法1: 入口起点( 不推荐 )</h4><p>使用 entry 配置手动分离代码，如果多个入口共享的文件，会分别在每个包里重复打包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./assets/js/main.js&apos;,</span><br><span class="line">    other: &apos;./assets/js/add.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;js/[name].bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2-防止重复"><a href="#方法2-防止重复" class="headerlink" title="方法2: 防止重复"></a>方法2: 防止重复</h4><p>使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &#123;</span><br><span class="line">      import: &apos;./assets/js/main.js&apos;,</span><br><span class="line">      dependOn: &apos;shared&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    other: &#123;</span><br><span class="line">      import: &apos;./assets/js/add.js&apos;,</span><br><span class="line">      dependOn: &apos;shared&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    shared: &apos;jQuery&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;js/[name].bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sliptChunks-插件"><a href="#sliptChunks-插件" class="headerlink" title="sliptChunks 插件"></a>sliptChunks 插件</h5><p>另外，还可使用 sliptChunks 插件来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./assets/js/main.js&apos;,</span><br><span class="line">    other: &apos;./assets/js/add.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;js/[name].bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    sliptChunks: &#123;</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 import 方法对文件名进行自定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import(/* webpackChunkName: &apos;自定义文件名&apos; */&apos;文件路径&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="方法3-动态导入"><a href="#方法3-动态导入" class="headerlink" title="方法3: 动态导入"></a>方法3: 动态导入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getComponent() &#123;</span><br><span class="line">  import(&apos;lodash&apos;)</span><br><span class="line">    .then((&#123;default: _&#125;) =&gt; &#123;</span><br><span class="line">      const element = document.createElement(&apos;div&apos;)</span><br><span class="line">      element.innerHTML = _.join([&apos;Hello&apos;, &apos;webpack&apos;, &apos;&apos;])</span><br><span class="line">      return element</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getComponent().then((element) =&gt; &#123;</span><br><span class="line">  document.body.appendChild(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>指的是 JS 文件的懒加载，当事件触发或条件满足后才进行加载。是很好的优化网页或应用的方法。这种方法实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用一些新的代码块。这样加快了应用的初始加载速度，减轻总体体积，因为某些代码块可能永远不会被加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  import(/* webpackChunkName: &apos;filename&apos; */&apos;./filename&apos;).then((&#123; module &#125;) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=44" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=44</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1e7411j7T5?p=26" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=26</a></p>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>等其他资源加载完毕后再进行加载，当事件触发或条件满足后，才会执行。兼容性较差，只能在pc端高版本浏览器中使用，手机端浏览器兼容较差。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  import(/* webpackChunkName: &apos;filename&apos;, webpackPrefetch: true */&apos;./filename&apos;).then((&#123; module &#125;) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="缓存-生产模式"><a href="#缓存-生产模式" class="headerlink" title="缓存 ( 生产模式 )"></a>缓存 ( 生产模式 )</h3><p>使用 hash 值为文件命名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;js/[name].[contenthash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缓存第三方库"><a href="#缓存第三方库" class="headerlink" title="缓存第三方库"></a>缓存第三方库</h4><p>将第三方库提取到单独的 vendor chunk 文件中。利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server 代码版本一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      vendor: &#123;</span><br><span class="line">        test: /[\\/]node_modules[\\/]/,</span><br><span class="line">        name: &apos;vendors&apos;,</span><br><span class="line">        chunks: &apos;all&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p><a href="https://www.bilibili.com/video/BV1e7411j7T5?p=27" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=27</a></p>
<p>渐进式网络应用开发程序，可实现网页离线访问，兼容性较差</p>
<p>下载插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i workbox-webpack-plugin -D</span><br><span class="line">// 引入插件</span><br><span class="line">const WorkboxWebpackPlugin = require(&apos;workbox-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">// 配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">      // 帮组 serviceworkder 快速启动</span><br><span class="line">      clientsClaim: true,</span><br><span class="line">      // 删除旧的 serviceworker</span><br><span class="line">      skipWaiting: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js 文件中注册</span><br><span class="line">if( &apos;serviceWorker&apos; in navigator ) &#123;</span><br><span class="line">  window.addEventListener(&apos;load&apos;, () =&gt; &#123;</span><br><span class="line">    navigator.serviceworker.register(&apos;/service-worker.js&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>会和eslint 产生冲突，需要修改 package.json 中 eslintConfig 配置</li>
<li>必须运行在服务器上</li>
</ul>
<h3 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h3><p>通常给 babel 使用，只有工作消耗时间较长时才建议使用。</p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure>
<h3 id="Externals"><a href="#Externals" class="headerlink" title="Externals"></a>Externals</h3><p>为了减小打包后的文件体积，从而把一些第三方库用 cdn 的形式引入进来，如 jQuery。Externals 就是用来防止将某些文件打包到最终生成的文件包中。</p>
<p>定义外部第三方包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  // 定义标签类型</span><br><span class="line">  externalsType: &apos;script&apos;,</span><br><span class="line">  // 定义第三方包</span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: [</span><br><span class="line">      &apos;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&apos;,</span><br><span class="line">      &apos;jQuery&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JS 文件中使用 import 方式引入，这里 from 后的名称需和定义时的名称进行对应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &apos;jQuery&apos;</span><br></pre></td></tr></table></figure>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=65" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=65</a></p>
<h3 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=78" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=78</a></p>
<h3 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h3><p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=80" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=80</a></p>
<h3 id="Dll"><a href="#Dll" class="headerlink" title="Dll"></a>Dll</h3><p><a href="https://www.bilibili.com/video/BV1e7411j7T5?p=30" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=30</a></p>
<p>动态连接库，dll会对某些库（第三方）进行单独打包。</p>
<p>1、下载好第三方库后，使用 import 语法在 JS 文件中引入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; gsap &#125; from &apos;gsap&apos;;</span><br></pre></td></tr></table></figure>
<p>2、在根目录中创建 webpack.dll.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const Webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 需要单独打包的库</span><br><span class="line">    gsap: [&apos;gsap&apos;],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 输出文件名称</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    // 输出文件路径</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dll&apos;),</span><br><span class="line">    // 导出库名称</span><br><span class="line">    library: &apos;[name]&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 引入插件</span><br><span class="line">    new Webpack.DllPlugin(&#123;</span><br><span class="line">      // 对应导出的库名称</span><br><span class="line">      name: &apos;[name]&apos;,</span><br><span class="line">      // 生成 manifest 文件</span><br><span class="line">      path: path.resolve(__dirname, &apos;../dll/manifest.json&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在 package.json 中编辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dll&quot;: &quot;webpack --config ./webpack.dll.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、执行指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dll</span><br></pre></td></tr></table></figure>
<p>5、然后配置 webpack.config.js 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const Webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    // 告诉 webpack 哪些库布参与打包，以及使用的名称</span><br><span class="line">    new Webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: path.resolve(__dirname, &apos;dll/manifest.json&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、如需在页面中自动引用，需安装一个插件 add-asset-html-webpack-plugin，再在 webpack.config.js 文件中进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i add-asset-html-webpack-plugin -D</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const AddAssetHtmlWebpackPlugin = require(&apos;add-asset-html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    // 在html中自动引入</span><br><span class="line">    new AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">      filepath: path.resolve(__dirname, &apos;dll/gsap.js&apos;),</span><br><span class="line">      publicPath: &apos;./&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=70" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=70</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1YU4y1g745?p=90" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745?p=90</a></p>
<h3 id="依赖图-Dependency-graph"><a href="#依赖图-Dependency-graph" class="headerlink" title="依赖图 Dependency graph"></a>依赖图 Dependency graph</h3><p>每当一个文件依赖另一个文件时，webpack 会直接将文件视为存在依赖关系。这使 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把他们作为依赖提供给应用程序。当 webpack 开始工作时，它会根据我们写好的配置，从入口 (Entry) 开始，webpack 会递归的构建一个依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为输出文件。</p>
<h4 id="bundle-分析工具"><a href="#bundle-分析工具" class="headerlink" title="bundle 分析工具"></a>bundle 分析工具</h4><ul>
<li>webpack-chart：webpack stats 可交互饼图；</li>
<li>webpack-visualizer：可视化并分析你的bundle，检查哪些模块占用空间，哪些可能使重复使用的；</li>
<li>webpack-bundle-analyzer：一个 plugin 和 CLI 工具，它将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式；</li>
<li>webpack bundle optimize helper：分析你的bundle并提供可操作的改进措施，减少 bundle 的大小；</li>
<li>bundle-stats：生成一个 bundle 报告 ( bundle大小、资源、模块 )，并比较不同构建之间的结果。</li>
</ul>
<h2 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h2><h3 id="entry-配置"><a href="#entry-配置" class="headerlink" title="entry 配置"></a>entry 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &#123;</span><br><span class="line">      // 将多个文件打包合成一个文件</span><br><span class="line">      import: [&apos;app1.js&apos;, &apos;app2.js&apos;],</span><br><span class="line">      dependOn: &apos;jquery&apos;,</span><br><span class="line">      filename: &apos;[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    main2: &#123;</span><br><span class="line">      import: &apos;app3.js&apos;,</span><br><span class="line">      dependOn: &apos;jquery&apos;,</span><br><span class="line">      filename: &apos;page/[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 第三方库依赖</span><br><span class="line">    jquery: &apos;jQuery&apos;,</span><br><span class="line">    finename: &apos;[name].js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引用插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &apos;./index.html&apos;,</span><br><span class="line">      inject: &apos;body&apos;,</span><br><span class="line">      chunks: [</span><br><span class="line">        &apos;main&apos;,</span><br><span class="line">        &apos;jquery&apos;,</span><br><span class="line">      ],</span><br><span class="line">      filename: &apos;index.html&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &apos;./page.html&apos;,</span><br><span class="line">      inject: &apos;body&apos;,</span><br><span class="line">      chunks: [</span><br><span class="line">        &apos;main2&apos;,</span><br><span class="line">        &apos;jquery&apos;,</span><br><span class="line">      ],</span><br><span class="line">      filename: &apos;page/page.html&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-Library"><a href="#创建-Library" class="headerlink" title="创建 Library"></a>创建 Library</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &apos;./mylib.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname. &apos;dist&apos;),</span><br><span class="line">    filename: &apos;mylib.js&apos;,</span><br><span class="line">    // 防止文件被 tree shaking</span><br><span class="line">    library: &apos;mylib&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置 *"></a>完整配置 *</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p><a href="https://www.bilibili.com/video/BV1e7411j7T5?p=18" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5?p=18</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line"></span><br><span class="line">const CommonCssLoader = [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    &#123;</span><br><span class="line">        loader: &apos;css-loader&apos;,</span><br><span class="line">        options: &#123; importLoaders: 1 &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        loader: &apos;postcss-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            postcssOptions: &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    [</span><br><span class="line">                        &apos;postcss-preset-env&apos;</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV = &apos;development&apos;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./assets/js/main.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;js/app.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                oneOf:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 处理 css 资源</span><br><span class="line">                        test: /\.css$/i,</span><br><span class="line">                        use: [...CommonCssLoader]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 处理 scss 资源</span><br><span class="line">                        test: /\.s[ac]ss$/i,</span><br><span class="line">                        use: [...CommonCssLoader, &apos;sass-loader&apos;]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 处理图片资源</span><br><span class="line">                        test: /\.(jpg|jpeg|png|gif)$/i,</span><br><span class="line">                        loader: &apos;url-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 8 * 1024,</span><br><span class="line">                            name: &apos;[hash:12].[ext]&apos;,</span><br><span class="line">                            esModule: false,</span><br><span class="line">                            outputPath: &apos;images&apos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 处理 html 中的图片资源</span><br><span class="line">                        test: /\.html$/i,</span><br><span class="line">                        loader: &apos;html-loader&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        // 处理 html 资源</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./index.html&apos;,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                collapseWhitespace: true,</span><br><span class="line">                removeComments: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            // 对输出结果重命名</span><br><span class="line">            filename: &apos;css/app.css&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        static: &#123;</span><br><span class="line">            directory: path.join(__dirname, &apos;build&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: true,</span><br><span class="line">        port: 3000,</span><br><span class="line">        liveReload: true,</span><br><span class="line">        watchFiles: &#123;</span><br><span class="line">            paths: [</span><br><span class="line">                &apos;./assets/*/*&apos;,</span><br><span class="line">                &apos;./*.html&apos;</span><br><span class="line">            ],</span><br><span class="line">            options: &#123;</span><br><span class="line">                usePolling: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        open: true,</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 生产环境</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line"></span><br><span class="line">const CommonCssLoader = [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    &#123;</span><br><span class="line">        loader: &apos;css-loader&apos;,</span><br><span class="line">        options: &#123; importLoaders: 1 &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        loader: &apos;postcss-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            postcssOptions: &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    [</span><br><span class="line">                        &apos;postcss-preset-env&apos;</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// process.env.NODE_ENV = &apos;development&apos;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./assets/js/main.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;js/app.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                // 处理 css 资源</span><br><span class="line">                test: /\.css$/i,</span><br><span class="line">                use: [...CommonCssLoader]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                // 处理 scss 资源</span><br><span class="line">                test: /\.s[ac]ss$/i,</span><br><span class="line">                use: [...CommonCssLoader, &apos;sass-loader&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                // 处理图片资源</span><br><span class="line">                test: /\.(jpg|jpeg|png|gif)$/i,</span><br><span class="line">                loader: &apos;url-loader&apos;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    limit: 8 * 1024,</span><br><span class="line">                    name: &apos;[hash:12].[ext]&apos;,</span><br><span class="line">                    esModule: false,</span><br><span class="line">                    outputPath: &apos;images&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                // 处理 html 中的图片资源</span><br><span class="line">                test: /\.html$/i,</span><br><span class="line">                loader: &apos;html-loader&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        // 处理 html 资源</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./index.html&apos;,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                collapseWhitespace: true,</span><br><span class="line">                removeComments: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            // 对输出结果重命名</span><br><span class="line">            filename: &apos;css/app.css&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件 *"></a>插件 *</h2><p>官方列举了可在 Webpack 5 中所有可使用的插件。</p>
<p><a href="https://webpack.docschina.org/plugins/" target="_blank" rel="noopener">https://webpack.docschina.org/plugins/</a></p>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧 *"></a>使用技巧 *</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 忽略警告（包含注释）</span><br><span class="line">// eslint-disable-next-line</span><br><span class="line"></span><br><span class="line">// 输出 ES6 版本代码</span><br><span class="line">output.ecmaVersion: 2015</span><br><span class="line"></span><br><span class="line">// 删除全局 webpack</span><br><span class="line">npm uninstall webpack webpack-cli --global</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>Bilibili 视频教程：<br><a href="https://www.bilibili.com/video/BV1e7411j7T5" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1e7411j7T5</a></p>
<p>Bilibili 视频教程：<br><a href="https://www.bilibili.com/video/BV1YU4y1g745" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YU4y1g745</a></p>
<p>官方文档（中文）<br><a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">https://webpack.docschina.org/concepts/</a></p>
<p><a href="https://stackoverflow.com/questions/49348365/webpack-4-size-exceeds-the-recommended-limit-244-kib" target="_blank" rel="noopener">https://stackoverflow.com/questions/49348365/webpack-4-size-exceeds-the-recommended-limit-244-kib</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title>tsconfig.json配置</title>
    <url>/2021/09/06/tsconfig.json%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="TS笔记"><a href="#TS笔记" class="headerlink" title="TS笔记"></a>TS笔记</h2><h4 id="tsconfig-json配置文件"><a href="#tsconfig-json配置文件" class="headerlink" title="tsconfig.json配置文件"></a>tsconfig.json配置文件</h4><p>include:[“./src/<em> </em>/ <em>“,”…….”]用来指定那些ts文件需要被编译{**代表任意目录  </em>代表任意文件}</p><p>exclude:[“…”]不需要被编译的文件目录                  默认值:[“node_modules”,”bower_components”,”jspm_packages”]</p><a id="more"></a>

<p>extends:”./configs/base” 当前配置文件会自动包含config目录下base.json中的所有配置信息 </p>
<p>files:[“tsc.ts”,” binder.ts”]  指定被编译文件的列表 只有需要编译的文件少时才会用到</p>
<p><strong>compilerOptions编译器选项</strong></p>
<p>target:”ES3|ES5|ES6|es2015|es2016|es2017|es2018|es2019|es2020|esnext”   指定ts被编译的js版本</p>
<p>module:”none|commonjs|amd|system|umd|es6|es2015|es2020|esnext”指定使用的模块化规范</p>
<p>lib:[“……”] 用来指定项目中要使用的库  一般情况下在浏览器环境不需要改！！</p>
<p>outDir:”./dist” 指定编译后文件所在的目录</p>
<p>outFile:”./dist/app.js” 将代码合并为一个文件 所有的全局作用域的代码会合并一个文件</p>
<p>allowJs:false 是否对js文件进行编译 默认false</p>
<p>checkJs:false 是否检查js代码是否符合语法规范 默认false</p>
<p>removeComments:false 是否移除注释</p>
<p>noEmit:false 不生成编译后的文件</p>
<p>noEmitOnError:false 当有错误时不生成编译后的文件</p>
<p><strong>语法检查相关</strong></p>
<p>alwaysStrict:false 设置编译后的文件是否使用严格模式</p>
<p>noImplicitAny:false 不允许隐式的any类型</p>
<p>noImplicitThis:false 不允许不明确类型的this</p>
<p>strictNullChecks:false 严格检查空值</p>
<p>strict:false 所有严格模式的总开关</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>ts泛型、接口</title>
    <url>/2021/09/06/ts%E6%B3%9B%E5%9E%8B%E3%80%81%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；</p><p>此时泛型便能够发挥作用；</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(arg: any): any&#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；</p><a id="more"></a>




<p>由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的：</p>
<p>首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><h4 id="创建泛型函数"><a href="#创建泛型函数" class="headerlink" title="创建泛型函数"></a>创建泛型函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test&lt;T&gt;(arg: T): T&#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>&lt;T&gt;</code>就是泛型；</p>
<p>T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；</p>
<p>所以泛型其实很好理解，就表示某个类型；</p>
<p>那么如何使用上边的函数呢？</p>
<h4 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h4><h5 id="方式一（直接使用）："><a href="#方式一（直接使用）：" class="headerlink" title="方式一（直接使用）："></a>方式一（直接使用）：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test(10)</span><br></pre></td></tr></table></figure>
<p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p>
<h5 id="方式二（指定类型）："><a href="#方式二（指定类型）：" class="headerlink" title="方式二（指定类型）："></a>方式二（指定类型）：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test&lt;number&gt;(10)</span><br></pre></td></tr></table></figure>
<p>也可以在函数后手动指定泛型；</p>
<h4 id="函数中声明多个泛型"><a href="#函数中声明多个泛型" class="headerlink" title="函数中声明多个泛型"></a>函数中声明多个泛型</h4><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test&lt;T, K&gt;(a: T, b: K): K&#123;</span><br><span class="line">  return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;number, string&gt;(10, &quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p>使用泛型时，完全可以将泛型当成是一个普通的类去使用；</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类中同样可以使用泛型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass&lt;T&gt;&#123;</span><br><span class="line">  prop: T;</span><br><span class="line"></span><br><span class="line">  constructor(prop: T)&#123;</span><br><span class="line">      this.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>除此之外，也可以对泛型的范围进行约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MyInter&#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test&lt;T extends MyInter&gt;(arg: T): number&#123;</span><br><span class="line">  return arg.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；</p>
<h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；</p>
<p>接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；</p>
<p>同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性；</p>
<p>示例（检查对象类型）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    sayHello():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(per: Person)&#123;</span><br><span class="line">    per.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(&#123;name:&apos;孙悟空&apos;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>示例（实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">   name: string;</span><br><span class="line">   sayHello():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Person&#123;</span><br><span class="line">   constructor(public name: string) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sayHello() &#123;</span><br><span class="line">       console.log(&apos;大家好，我是&apos;+this.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TS面向对象"><a href="#TS面向对象" class="headerlink" title="TS面向对象"></a>TS面向对象</h2><p>要想面向对象，操作对象，首先便要拥有对象；</p>
<p>要创建对象，必须要先定义类，所谓的类可以理解为对象的模型；</p>
<p>程序中可以根据类创建指定类型的对象；</p>
<p>举例来说：</p>
<p>可以通过Person类来创建人的对象，通过Dog类创建狗的对象，不同的类可以用来创建不同的对象；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">    属性名: 类型;</span><br><span class="line">    </span><br><span class="line">    constructor(参数: 类型)&#123;</span><br><span class="line">        this.属性名 = 参数;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    方法名()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p = new Person(&apos;孙悟空&apos;, 18);</span><br><span class="line">p.sayHello();</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>可以使用<code>constructor</code>定义一个构造器方法；</p>
<blockquote>
<p><strong>注1：在TS中只能有一个构造器方法！</strong></p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时也可以直接将属性定义在构造函数中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    constructor(public name: string, public age: number) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种定义方法是完全相同的！</p>
<p><strong>注2：子类继承父类时，必须调用父类的构造方法（如果子类中也定义了构造方法）！</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    protected num: number;</span><br><span class="line">    constructor(num: number) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class X extends A &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(num: number, name: string) &#123;</span><br><span class="line">        super(num);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在X类中不调用<code>super</code>将会报错！</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p>
<p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p>
<ul>
<li>静态属性（static）：<ul>
<li>声明为static的属性或方法不再属于实例，而是属于类的属性；</li>
</ul>
</li>
<li>只读属性（readonly）：<ul>
<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>
</ul>
</li>
<li>TS中属性具有三种修饰符：<ul>
<li>public（默认值），可以在类、子类和对象中修改</li>
<li>protected ，可以在类、子类中修改</li>
<li>private ，可以在类中修改</li>
</ul>
</li>
</ul>
<p>示例：</p>
<p>public：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    public name: string; // 写或什么都不写都是public</span><br><span class="line">    public age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name; // 可以在类中修改</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.name = name; //子类中可以修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Person(&apos;孙悟空&apos;, 18);</span><br><span class="line">p.name = &apos;猪八戒&apos;;// 可以通过对象修改</span><br></pre></td></tr></table></figure>
<p>protected：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    protected age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name; // 可以修改</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.name = name; //子类中可以修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Person(&apos;孙悟空&apos;, 18);</span><br><span class="line">p.name = &apos;猪八戒&apos;;// 不能修改</span><br></pre></td></tr></table></figure>
<p>private：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    private age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name; // 可以修改</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.name = name; //子类中不能修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Person(&apos;孙悟空&apos;, 18);</span><br><span class="line">p.name = &apos;猪八戒&apos;;// 不能修改</span><br></pre></td></tr></table></figure>
<h3 id="属性存取器"><a href="#属性存取器" class="headerlink" title="属性存取器"></a>属性存取器</h3><p>对于一些不希望被任意修改的属性，可以将其设置为private</p>
<p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>
<p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>
<p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private _name: string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string)&#123;</span><br><span class="line">        this._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get name()&#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set name(name: string)&#123;</span><br><span class="line">        this._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p1 = new Person(&apos;孙悟空&apos;);</span><br><span class="line">// 实际通过调用getter方法读取name属性</span><br><span class="line">console.log(p1.name);</span><br><span class="line">// 实际通过调用setter方法修改name属性 </span><br><span class="line">p1.name = &apos;猪八戒&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>
<p>静态属性（方法）使用static开头</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Tools&#123;</span><br><span class="line">    static PI = 3.1415926;</span><br><span class="line">    </span><br><span class="line">    static sum(num1: number, num2: number)&#123;</span><br><span class="line">        return num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Tools.PI);</span><br><span class="line">console.log(Tools.sum(123, 456));</span><br></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在类中，使用this表示当前对象</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承时面向对象中的又一个特性</p>
<p>通过继承可以将其他类中的属性和方法引入到当前类中</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    bark()&#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;在汪汪叫！`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&apos;旺财&apos;, 4);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure>
<p>通过继承可以在不修改类的情况下完成对类的扩展</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(`父类中的run方法！`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    bark()&#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;在汪汪叫！`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(`子类中的run方法，会重写父类中的run方法！`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&apos;旺财&apos;, 4);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure>
<p><strong>在子类中可以使用super来完成对父类的引用</strong></p>
<h3 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h3><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal&#123;</span><br><span class="line">  abstract run(): void;</span><br><span class="line">  bark()&#123;</span><br><span class="line">      console.log(&apos;动物在叫~&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animals&#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">      console.log(&apos;狗在跑~&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现;</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs</title>
    <url>/2022/09/11/nodejs/</url>
    <content><![CDATA[<h2 id="Nodejs复习手册"><a href="#Nodejs复习手册" class="headerlink" title="Nodejs复习手册"></a>Nodejs复习手册</h2><h3 id="初识-Nodejs"><a href="#初识-Nodejs" class="headerlink" title="初识 Nodejs"></a>初识 Nodejs</h3><blockquote>
<p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine</p>
<p>Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境</p>
</blockquote><ul>
<li>基于 <a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express 框架 (opens new window)</a>，可以快速构建 Web 应用</li>
<li>基于 <a href="https://electronjs.org/" target="_blank" rel="noopener">Electron 框架 (opens new window)</a>，可以构建跨平台的桌面应用</li>
<li>基于 <a href="http://restify.com/" target="_blank" rel="noopener">restify 框架 (opens new window)</a>，可以快速构建 API 接口项目</li>
<li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li>
</ul><a id="more"></a>

<h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><ul>
<li>fs 模块中所有的操作都有两种形式可供选择:同步和异步</li>
<li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li>
<li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li>
<li><p>实际开发很少用同步方式，因此只介绍异步方式</p>
<p>打开模式： </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>读取文件，文件不存在抛异常</td>
</tr>
<tr>
<td>r+</td>
<td>读写文件，文件不存在抛异常</td>
</tr>
<tr>
<td>rs</td>
<td>同步模式下打开文件用于读取</td>
</tr>
<tr>
<td>rs+</td>
<td>同步模式下打开文件用于读写</td>
</tr>
<tr>
<td>w</td>
<td>写文件，不存在则创建，存在则覆盖原有内容</td>
</tr>
<tr>
<td>wx</td>
<td>写文件，文件存在打开失败</td>
</tr>
<tr>
<td>w+</td>
<td>读写文件，不存在创建，存在截断</td>
</tr>
<tr>
<td>wx+</td>
<td>读写，存在打开失败</td>
</tr>
<tr>
<td>a</td>
<td>追加，不存在创建</td>
</tr>
<tr>
<td>ax</td>
<td>追加，存在失败</td>
</tr>
<tr>
<td>a+</td>
<td>追加和读取，不存在创建</td>
</tr>
<tr>
<td>ax+</td>
<td>追加和读取，存在失败</td>
</tr>
</tbody>
</table>
<p><strong>读取文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.readFile(path,[options],callback)</span><br></pre></td></tr></table></figure>
<p>path:文件路径</p>
<p>options：配置选项，若是字符串则指定编码格式                   encoding：编码格式</p>
<p>​            flag：打开方式    </p>
<p>callbakc：回调函数</p>
<p>​            err：错误信息    </p>
<p>​            data：读取的数据，如果未指定编码格式则返回一个Buffer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./files/1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'failed!'</span> + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'content:'</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件内容</span></span><br><span class="line">fs.readFile(<span class="string">"C:/Users/笔记.mp3"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">		<span class="comment">// 将data写入到文件中</span></span><br><span class="line">		fs.writeFile(<span class="string">"C:/Users/hello.jpg"</span>, data, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!err)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">"文件写入成功"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>流式文件读取</strong></p>
<ul>
<li>简单文件读取的方式会一次性读取文件内容到内存中，若文件较大，会占用过多内存影响系统性能，且读取速度慢</li>
<li>大文件适合用流式文件读取，它会分多次将文件读取到内存中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">// 创建一个可读流</span><br><span class="line">var rs = fs.createReadStream(&apos;C:/Users/笔记.mp3&apos;)</span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&apos;a.mp3&apos;)</span><br><span class="line"></span><br><span class="line">// 监听流的开启和关闭</span><br><span class="line">// 这几个监听不是必须的</span><br><span class="line">rs.once(&apos;open&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;可读流打开了~~&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.once(&apos;close&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;可读流关闭了~~&apos;)</span><br><span class="line">  //数据读取完毕，关闭可写流</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;open&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;可写流打开了~~&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;close&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;可写流关闭了~~&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//要读取一个可读流中的数据，要为可读流绑定一个data事件，data事件绑定完毕自动开始读取数据</span><br><span class="line">rs.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">  //将读取到的数据写入到可写流中</span><br><span class="line">  ws.write(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 简便方式： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'C:/Users/lilichao/Desktop/笔记.mp3'</span>)</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'b.mp3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe()可以将可读流中的内容，直接输出到可写流中</span></span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure>
<p><strong>写入文件</strong></p>
<p>简单文件写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.writeFile(file,data,[options],callback)</span><br></pre></td></tr></table></figure>
<p>file：文件路径</p>
<p>data：写入内容</p>
<p>options：配置选项，包含 encoding，mode，flag；若是字符串则指定编码格式</p>
<p>callback：回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">fs.writeFile(&apos;./files/2.txt&apos;, &apos;Hello Nodejs&apos;, function (err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(&apos;failed!&apos; + err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&apos;success!&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.writeFile(&apos;C:/Users/hello.txt&apos;, &apos;通过 writeFile 写入的内容&apos;, &#123; flag: &apos;w&apos; &#125;, function (err) &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    console.log(&apos;写入成功！&apos;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>流式文件写入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">// 创建一个可写流</span><br><span class="line">var ws = fs.createWriteStream(&apos;hello3.txt&apos;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;open&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;流打开了~~&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;close&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;流关闭了~~&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过ws向文件中输出内容</span><br><span class="line">ws.write(&apos;通过可写流写入文件的内容&apos;)</span><br><span class="line">ws.write(&apos;1&apos;)</span><br><span class="line">ws.write(&apos;2&apos;)</span><br><span class="line">ws.write(&apos;3&apos;)</span><br><span class="line">ws.write(&apos;4&apos;)</span><br><span class="line"></span><br><span class="line">// 关闭流</span><br><span class="line">ws.end()</span><br></pre></td></tr></table></figure>
<h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题 __dirname"></a>路径动态拼接问题 <code>__dirname</code></h3><ul>
<li>在使用 fs 模块操作文件时，如果提供的操作路径是以 <code>./</code> 或 <code>../</code> 开头的相对路径时，容易出现路径动态拼接错误的问题</li>
<li>原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li>
<li>解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li>
<li><code>__dirname</code> 获取文件所处的绝对路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.readFile(__dirname + &apos;/files/1.txt&apos;, &apos;utf8&apos;, function(err, data) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><p>验证路径是否存在：</p>
<ul>
<li><code>fs.exists(path, callback)</code></li>
<li><code>fs.existsSync(path)</code></li>
</ul>
<p>获取文件信息：</p>
<ul>
<li><code>fs.stat(path, callback)</code></li>
<li><code>fs.stat(path)</code></li>
</ul>
<p>删除文件：</p>
<ul>
<li><code>fs.unlink(path, callback)</code></li>
<li><code>fs.unlinkSync(path)</code></li>
</ul>
<p>列出文件：</p>
<ul>
<li><code>fs.readdir(path[,options], callback)</code></li>
<li><code>fs.readdirSync(path[, options])</code></li>
</ul>
<p>截断文件：</p>
<ul>
<li><code>fs.truncate(path, len, callback)</code></li>
<li><code>fs.truncateSync(path, len)</code></li>
</ul>
<p>建立目录：</p>
<ul>
<li><code>fs.mkdir(path[, mode], callback)</code></li>
<li><code>fs.mkdirSync(path[, mode])</code></li>
</ul>
<p>删除目录：</p>
<ul>
<li><code>fs.rmdir(path, callback)</code></li>
<li><code>fs.rmdirSync(path)</code></li>
</ul>
<p>重命名文件和目录：</p>
<ul>
<li><code>fs.rename(oldPath, newPath, callback)</code></li>
<li><code>fs.renameSync(oldPath, newPath)</code></li>
</ul>
<p>监视文件更改：</p>
<ul>
<li><code>fs.watchFile(filename[, options], listener)</code></li>
</ul>
<h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p>
<h3 id="路径拼接-path-join"><a href="#路径拼接-path-join" class="headerlink" title="路径拼接 path.join()"></a>路径拼接 <code>path.join()</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">// 注意 ../ 会抵消前面的路径</span><br><span class="line">// ./ 会被忽略</span><br><span class="line">const pathStr = path.join(&apos;/a&apos;, &apos;/b/c&apos;, &apos;../../&apos;, &apos;./d&apos;, &apos;e&apos;)</span><br><span class="line">console.log(pathStr) // \a\d\e</span><br><span class="line"></span><br><span class="line">fs.readFile(path.join(__dirname, &apos;./files/1.txt&apos;), &apos;utf8&apos;, function (err, dataStr) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    return console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="获取路径中文件名-path-basename"><a href="#获取路径中文件名-path-basename" class="headerlink" title="获取路径中文件名 path.basename()"></a>获取路径中文件名 <code>path.basename()</code></h3><p> 使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.basename(path[, ext])</span><br></pre></td></tr></table></figure>
<ul>
<li>path: 文件路径</li>
<li>ext: 文件扩展名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">// 定义文件的存放路径</span><br><span class="line">const fpath = &apos;/a/b/c/index.html&apos;</span><br><span class="line"></span><br><span class="line">const fullName = path.basename(fpath)</span><br><span class="line">console.log(fullName) // index.html</span><br><span class="line"></span><br><span class="line">const nameWithoutExt = path.basename(fpath, &apos;.html&apos;)</span><br><span class="line">console.log(nameWithoutExt) // index</span><br></pre></td></tr></table></figure>
<h3 id="获取路径中文件扩展名-path-extname"><a href="#获取路径中文件扩展名-path-extname" class="headerlink" title="获取路径中文件扩展名 path.extname()"></a>获取路径中文件扩展名 <code>path.extname()</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">'/a/b/c/index.html'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fext = path.extname(fpath)</span><br><span class="line"><span class="built_in">console</span>.log(fext) <span class="comment">// .html</span></span><br></pre></td></tr></table></figure>
<h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><p> http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。 </p>
<h3 id="创建基本-Web-服务器"><a href="#创建基本-Web-服务器" class="headerlink" title="创建基本 Web 服务器"></a>创建基本 Web 服务器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 web 服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为服务器实例绑定 request 事件，监听客户端的请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url</span><br><span class="line">  <span class="keyword">const</span> method = req.method</span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`Your request url is <span class="subst">$&#123;url&#125;</span>, and request method is <span class="subst">$&#123;method&#125;</span>`</span></span><br><span class="line">  <span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 Content-Type 响应头，解决中文乱码的问题</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">  <span class="comment">// 向客户端响应内容</span></span><br><span class="line">  res.end(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server running at http://127.0.0.1:8080'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="实现简陋路由效果"><a href="#实现简陋路由效果" class="headerlink" title="实现简陋路由效果"></a>实现简陋路由效果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.url</span><br><span class="line">  <span class="comment">// 设置默认的响应内容为 404 Not found</span></span><br><span class="line">  <span class="keyword">let</span> content = <span class="string">'&lt;h1&gt;404 Not found!&lt;/h1&gt;'</span></span><br><span class="line">  <span class="comment">// 判断用户请求的是否为 / 或 /index.html 首页</span></span><br><span class="line">  <span class="comment">// 判断用户请求的是否为 /about.html 关于页面</span></span><br><span class="line">  <span class="keyword">if</span> (url === <span class="string">'/'</span> || url === <span class="string">'/index.html'</span>) &#123;</span><br><span class="line">    content = <span class="string">'&lt;h1&gt;首页&lt;/h1&gt;'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url === <span class="string">'/about.html'</span>) &#123;</span><br><span class="line">    content = <span class="string">'&lt;h1&gt;关于页面&lt;/h1&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">  res.end(content)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">80</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server running at http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul>
<li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li>
<li>模块化可提高代码的复用性和可维护性，实现按需加载。</li>
<li>模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li>
</ul>
<h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><ul>
<li>内置模块</li>
<li>自定义模块</li>
<li>第三方模块</li>
</ul>
<h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><ul>
<li>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li>
<li>防止全局变量污染</li>
</ul>
<h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul>
<li>自定义模块中都有一个 <code>module</code> 对象，存储了和当前模块有关的信息</li>
<li>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 <code>module.exports</code> 指向的对象。</li>
<li>默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。最终共享的结果，以 <code>module.exports</code> 指向的对象为准。</li>
</ul>
<h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><ul>
<li>每个模块内部，<code>module</code> 变量代表当前模块</li>
<li><code>module</code> 变量是一个对象，<code>module.exports</code> 是对外的接口</li>
<li>加载某个模块即加载该模块的 <code>module.exports</code> 属性</li>
</ul>
<h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 <code>require()</code> 不会导致模块的代码被执行多次，提高模块加载效率。</p>
<h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p>
<h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 <code>./</code> 或 <code>../</code> 开头，否则会作为内置模块或第三方模块加载。</p>
<p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p>
<ul>
<li>按确切的文件名加载</li>
<li>补全 <code>.js</code> 扩展名加载</li>
<li>补全 <code>.json</code> 扩展名加载</li>
<li>补全 <code>.node</code> 扩展名加载</li>
<li>报错</li>
</ul>
<h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul>
<li>若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</li>
<li>如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li>
</ul>
<p>例如，假设在 <code>C:\Users\bruce\project\foo.js</code> 文件里调用了 <code>require(&#39;tools&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li><code>C:\Users\bruce\project\node_modules\tools</code></li>
<li><code>C:\Users\bruce\node_modules\tools</code></li>
<li><code>C:\Users\node_modules\tools</code></li>
<li><code>C:\node_modules\tools</code></li>
</ul>
<h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p>
<ul>
<li>在被加载的目录下查找 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口</li>
<li>如果没有 <code>package.json</code> 文件，或者 <code>main</code> 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js</code> 文件。</li>
<li>若失败则报错</li>
</ul>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><blockquote>
<p>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</p>
</blockquote>
<p>Express 是用于快速创建服务器的第三方模块。</p>
<h2 id="Express-初体验"><a href="#Express-初体验" class="headerlink" title="Express 初体验"></a>Express 初体验</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 Express：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>
<p> 创建服务器，监听客户端请求，并返回内容： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建 web 服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span></span><br><span class="line">app.get(<span class="string">'/user'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&#123; <span class="attr">name</span>: <span class="string">'zs'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'男'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.post(<span class="string">'/user'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'请求成功'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 通过 req.query 可以获取到客户端发送过来的查询参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.query)</span><br><span class="line">  res.send(req.query)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 :id 是一个动态的参数</span></span><br><span class="line">app.get(<span class="string">'/user/:ids/:username'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// req.params 是动态匹配到的 URL 参数，默认是一个空对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.params)</span><br><span class="line">  res.send(req.params)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'express server running at http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul>
<li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li>
<li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中</li>
<li>访问静态资源时，会根据托管顺序查找文件</li>
<li>可为静态资源访问路径添加前缀</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>))</span><br><span class="line">app.use(express.static(<span class="string">'files'</span>))</span><br><span class="line">app.use(<span class="string">'/bruce'</span>, express.static(<span class="string">'bruce'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可直接访问 public, files 目录下的静态资源</span></span><br><span class="line"><span class="comment">http://localhost:3000/images/bg.jpg</span></span><br><span class="line"><span class="comment">http://localhost:3000/css/style.css</span></span><br><span class="line"><span class="comment">http://localhost:3000/js/login.js</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span></span><br><span class="line"><span class="comment">http://localhost:8080/bruce/images/logo.png</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>创建路由模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载具体路由</span></span><br><span class="line">router.get(<span class="string">'/user/list'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Get user list.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.post(<span class="string">'/user/add'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Add new user.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外导出路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p> 注册路由模块： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'./router'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册路由模块，添加访问前缀</span></span><br><span class="line">app.use(<span class="string">'/api'</span>, router)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><ul>
<li>中间件是指流程的中间处理环节</li>
<li>服务器收到请求后，可先调用中间件进行预处理</li>
<li>中间件是一个函数，包含 <code>req, res, next</code> 三个参数，<code>next()</code> 参数把流转关系交给下一个中间件或路由</li>
</ul>
<p>中间件注意事项；</p>
<ul>
<li>在注册路由之前注册中间件（错误级别中间件除外）</li>
<li>中间件可连续调用多个</li>
<li>别忘记调用 <code>next()</code> 函数</li>
<li><code>next()</code> 函数后别写代码</li>
<li>多个中间件共享 <code>req</code>、 <code>res</code>对象</li>
</ul>
<h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><ul>
<li>通过 <code>app.use()</code> 定义的中间件为全局中间件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第一个全局中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用了第1个全局中间件'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义第二个全局中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用了第2个全局中间件'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'User page.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw1 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用了第一个局部生效的中间件'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mw2 = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用了第二个局部生效的中间件'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种定义局部中间件的方式</span></span><br><span class="line">app.get(<span class="string">'/hello'</span>, mw2, mw1, (req, res) =&gt; res.send(<span class="string">'hello page.'</span>))</span><br><span class="line">app.get(<span class="string">'/about'</span>, [mw1, mw2], (req, res) =&gt; res.send(<span class="string">'about page.'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user'</span>, (req, res) =&gt; res.send(<span class="string">'User page.'</span>))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Express server running at http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><ol>
<li>应用级别的中间件</li>
</ol>
<ul>
<li>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 <code>app</code> 实例上的中间件</li>
</ul>
<p>2.路由级别的中间件</p>
<ul>
<li>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 <code>app</code> 实例上，路由级别中间件绑定到 <code>router</code> 实例上。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, router)</span><br></pre></td></tr></table></figure>
<p>3.错误级别的中间件</p>
<ul>
<li>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li>
<li>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 <code>(err, req, res, next)</code> 。</li>
<li>错误级别的中间件必须注册在所有路由之后</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'服务器内部发生了错误！'</span>)</span><br><span class="line">  res.send(<span class="string">'Home page.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生了错误！'</span> + err.message)</span><br><span class="line">  res.send(<span class="string">'Error：'</span> + err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Express server running at http://127.0.0.1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4.Express 内置中间件</p>
<p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p>
<ul>
<li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li>
<li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li>
<li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure>
<p>5.第三方中间件</p>
<h2 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h2><h3 id="cors-中间件解决跨域"><a href="#cors-中间件解决跨域" class="headerlink" title="cors 中间件解决跨域"></a>cors 中间件解决跨域</h3><ul>
<li>安装中间件：<code>npm install cors</code></li>
<li>导入中间件：<code>const cors = require(&#39;cors&#39;)</code></li>
<li>配置中间件：<code>app.use(cors())</code></li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul>
<li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li>
<li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li>
<li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li>
<li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li>
</ul>
<h3 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h3><ul>
<li><code>Access-Control-Allow-Origin</code>：制定了允许访问资源的外域 URL</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://bruceblog.io'</span>)</span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Access-Control-Allow-Headers</code></li>
<li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</code></li>
<li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 A<code>ccess-Control-Allow-Headers</code> 对额外的请求头进行声明，否则这次请求会失败！</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, X-Custom-Header'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Access-Control-Allow-Methods</code></li>
<li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code> 来指明实际请求所允许使用的 HTTP 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'POST, GET, DELETE, HEAD'</span>)</span><br><span class="line">res.setHEader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul>
<li>请求方式：GET、POST、HEAD 三者之一</li>
<li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain）</li>
</ul>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><ul>
<li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li>
<li>请求头中包含自定义头部字段</li>
<li>向服务器发送了 application/json 格式的数据</li>
</ul>
<p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p>
<h1 id="数据库和身份认证"><a href="#数据库和身份认证" class="headerlink" title="数据库和身份认证"></a>数据库和身份认证</h1><h2 id="Node-操作-mysql"><a href="#Node-操作-mysql" class="headerlink" title="Node 操作 mysql"></a>Node 操作 mysql</h2><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><p>1、安装 mysql 模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure>
<p>2、建立连接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = mysql.createPool(&#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  user: <span class="string">'root'</span>,</span><br><span class="line">  password: <span class="string">'root'</span>,</span><br><span class="line">  database: <span class="string">'test'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3、测试是否正常工作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(<span class="string">'select 1'</span>, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err.message)</span><br><span class="line">  <span class="built_in">console</span>.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="操作-mysql-数据库"><a href="#操作-mysql-数据库" class="headerlink" title="操作 mysql 数据库"></a>操作 mysql 数据库</h3><p>1、查询数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(<span class="string">'select * from users'</span>, (err, results) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>2、插入数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ? 表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">'insert into users values(?, ?)'</span></span><br><span class="line"><span class="comment">// 使用数组的形式为占位符指定具体的值</span></span><br><span class="line">db.query(sql, [username, password], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err.message)</span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows === <span class="number">1</span>) <span class="built_in">console</span>.log(<span class="string">'插入成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>:<span class="string">'Bruce'</span>, <span class="attr">password</span>:<span class="string">'55520'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">'insert into users set ?'</span></span><br><span class="line">db.query(sql, user, (err, results) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3、更新数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">'update users set username=?, password=? where id=?'</span></span><br><span class="line">db.query(sql, [username, password, id], (err, results) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 快捷方式： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>:<span class="number">7</span>,<span class="attr">username</span>:<span class="string">'Bruce'</span>,<span class="attr">password</span>:<span class="string">'55520'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">'update users set ? where id=?'</span></span><br><span class="line">db.query(sql, [user, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4、删除数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">'delete from users where id=?'</span></span><br><span class="line">db.query(sql, id, (err, results) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 使用 delete 语句会真正删除数据，保险起见，使用标记删除的形式，模拟删除的动作。即在表中设置状态字段，标记当前的数据是否被删除。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(<span class="string">'update users set status=1 where id=?'</span>, <span class="number">7</span>, (err, results) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Web-开发模式"><a href="#Web-开发模式" class="headerlink" title="Web 开发模式"></a>Web 开发模式</h2><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接动态生成的。因此客户端不需要使用 Ajax 额外请求页面的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/index.html'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'Bruce'</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`&lt;h1&gt;username:<span class="subst">$&#123;user.name&#125;</span>, age:<span class="subst">$&#123;user.age&#125;</span>&lt;/h1&gt;`</span></span><br><span class="line">  res.send(html)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>前端耗时短。浏览器只需直接渲染页面，无需额外请求数据。</li>
<li>有利于 SEO。服务器响应的是完整的 HTML 页面内容，有利于爬虫爬取信息。</li>
</ul>
<p>缺点：</p>
<ul>
<li>占用服务器资源。服务器需要完成页面内容的拼接，若请求比较多，会对服务器造成一定访问压力。</li>
<li>不利于前后端分离，开发效率低。</li>
</ul>
<h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口。</p>
<p>优点：</p>
<ul>
<li>开发体验好。前端专业页面开发，后端专注接口开发。</li>
<li>用户体验好。页面局部刷新，无需重新请求页面。</li>
<li>减轻服务器的渲染压力。页面最终在浏览器里生成。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于 SEO。完整的 HTML 页面在浏览器拼接完成，因此爬虫无法爬取页面的有效信息。Vue、React 等框架的 SSR（server side render）技术能解决 SEO 问题。</li>
</ul>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul>
<li>企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染</li>
<li>后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离</li>
<li>为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式</li>
</ul>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="Session-认证机制"><a href="#Session-认证机制" class="headerlink" title="Session 认证机制"></a>Session 认证机制</h3><p>服务端渲染推荐使用 Session 认证机制</p>
<h4 id="Session-工作原理"><a href="#Session-工作原理" class="headerlink" title="Session 工作原理"></a>Session 工作原理</h4><p> <img src="https://brucecai55520.gitee.io/bruceblog/assets/img/Session.c66d5499.png" alt="session"> </p>
<h4 id="Express-中使用-Session-认证"><a href="#Express-中使用-Session-认证" class="headerlink" title="Express 中使用 Session 认证"></a>Express 中使用 Session 认证</h4><p>1、安装 express-session 中间件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure>
<p>2、配置中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: <span class="string">'Bruce'</span>, <span class="comment">// secret 的值为任意字符串</span></span><br><span class="line">    resave: <span class="literal">false</span>,</span><br><span class="line">    saveUninitalized: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>3、向 session 中存数据</p>
<p>中间件配置成功后，可通过 <code>req.session</code> 访问 session 对象，存储用户信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/api/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  req.session.user = req.body</span><br><span class="line">  req.session.isLogin = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  res.send(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">'login done'</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4、从 session 取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/api/username'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!req.session.isLogin) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">'fail'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">'success'</span>, <span class="attr">username</span>: req.session.user.username &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>5、清空 session</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/api/logout'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 清空当前客户端的session信息</span></span><br><span class="line">  req.session.destroy()</span><br><span class="line">  res.send(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">'logout done'</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="JWT-认证机制"><a href="#JWT-认证机制" class="headerlink" title="JWT 认证机制"></a>JWT 认证机制</h3><p>前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案</p>
<h4 id="JWT-工作原理"><a href="#JWT-工作原理" class="headerlink" title="JWT 工作原理"></a>JWT 工作原理</h4><p>Session 认证的局限性：</p>
<ul>
<li>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</li>
<li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li>
<li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li>
</ul>
<p>JWT 工作原理图：</p>
<p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p>
<p> <img src="https://brucecai55520.gitee.io/bruceblog/assets/img/JWT.6a82c41d.png" alt="JWT"> </p>
<p>JWT 组成部分：</p>
<ul>
<li>Header、Payload、Signature</li>
<li>Payload 是真正的用户信息，加密后的字符串</li>
<li>Header 和 Signature 是安全性相关部分，保证 Token 安全性</li>
<li>三者使用 <code>.</code> 分隔</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Header.Payload.Signature</span><br><span class="line"></span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c</span><br></pre></td></tr></table></figure>
<p>JWT 使用方式：</p>
<ul>
<li>客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</li>
<li>此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</li>
<li>加上 Bearer 前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Express-使用-JWT"><a href="#Express-使用-JWT" class="headerlink" title="Express 使用 JWT"></a>Express 使用 JWT</h4><p>1、安装</p>
<ul>
<li>jsonwebtoken 用于生成 JWT 字符串</li>
<li>express-jwt 用于将 JWT 字符串解析还原成 JSON 对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jsonwebtoken express-jwt</span><br></pre></td></tr></table></figure>
<p>2、定义 secret 密钥</p>
<ul>
<li>为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</li>
<li>生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</li>
<li>把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">'express-jwt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥为任意字符串</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">'Bruce'</span></span><br></pre></td></tr></table></figure>
<p>3、生成 JWT 字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/api/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: <span class="number">200</span>,</span><br><span class="line">    message: <span class="string">'登录成功'</span>,</span><br><span class="line">    <span class="comment">// jwt.sign() 生成 JWT 字符串</span></span><br><span class="line">    <span class="comment">// 参数：用户信息对象、加密密钥、配置对象-token有效期</span></span><br><span class="line">    <span class="comment">// 尽量不保存敏感信息，因此只有用户名，没有密码</span></span><br><span class="line">    token: jwt.sign(&#123;<span class="attr">username</span>: userInfo.username&#125;, secretKey, &#123;<span class="attr">expiresIn</span>: <span class="string">'10h'</span>&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4、JWT 字符串还原为 JSON 对象</p>
<ul>
<li>客户端访问有权限的接口时，需通过请求头的 <code>Authorization</code> 字段，将 Token 字符串发送到服务器进行身份认证</li>
<li>服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口无需访问权限</span></span><br><span class="line">app.use(expressJWT(&#123; <span class="attr">secret</span>: secretKey &#125;).unless(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure>
<p>5、获取用户信息</p>
<ul>
<li>当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 <code>req.user</code> 对象，来访问从 JWT 字符串中解析出来的用户信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/admin/getinfo'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.user)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: <span class="number">200</span>,</span><br><span class="line">    message: <span class="string">'获取信息成功'</span>,</span><br><span class="line">    data: req.user,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>6、捕获解析 JWT 失败后产生的错误</p>
<ul>
<li>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</li>
<li>通过 Express 的错误中间件，捕获这个错误并进行相关的处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.name === <span class="string">'UnauthorizedError'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">401</span>, <span class="attr">message</span>: <span class="string">'Invalid token'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(&#123; <span class="attr">status</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">'Unknown error'</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="大事件后台-API-项目"><a href="#大事件后台-API-项目" class="headerlink" title="大事件后台 API 项目"></a>大事件后台 API 项目</h1><blockquote>
<p><a href="https://www.showdoc.cc/escook?page_id=3707158761215217" target="_blank" rel="noopener">API 接口文档(opens new window)</a></p>
</blockquote>
<h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1. 项目初始化"></a>1. 项目初始化</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>新建 <code>api_server</code> 文件夹作为项目根目录，并在项目根目录中运行如下的命令，初始化包管理配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
<p>运行如下的命令，安装特定版本的 <code>express</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i express@4.17.1</span><br></pre></td></tr></table></figure>
<p>在项目根目录中新建 <code>app.js</code> 作为整个项目的入口文件，并初始化如下的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建 express 的服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// write your code here...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span></span><br><span class="line">app.listen(<span class="number">3007</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'api server running at http://127.0.0.1:3007'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="配置-cors-跨域"><a href="#配置-cors-跨域" class="headerlink" title="配置 cors 跨域"></a>配置 cors 跨域</h3><p>运行如下的命令，安装 <code>cors</code> 中间件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i cors@2.8.5</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中导入并配置 <code>cors</code> 中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'cors'</span>)</span><br><span class="line"></span><br><span class="line">app.use(cors())</span><br></pre></td></tr></table></figure>
<h3 id="配置解析表单数据的中间件"><a href="#配置解析表单数据的中间件" class="headerlink" title="配置解析表单数据的中间件"></a>配置解析表单数据的中间件</h3><p>通过如下的代码，配置解析 <code>application/x-www-form-urlencoded</code> 格式的表单数据的中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure>
<h3 id="初始化路由相关的文件夹"><a href="#初始化路由相关的文件夹" class="headerlink" title="初始化路由相关的文件夹"></a>初始化路由相关的文件夹</h3><p>在项目根目录中，新建 <code>router</code> 文件夹，用来存放所有的<code>路由</code>模块</p>
<blockquote>
<p>路由模块中，只存放客户端的请求与处理函数之间的映射关系</p>
</blockquote>
<p>在项目根目录中，新建 <code>router_handler</code> 文件夹，用来存放所有的 <code>路由处理函数模块</code></p>
<blockquote>
<p>路由处理函数模块中，专门负责存放每个路由对应的处理函数</p>
</blockquote>
<h3 id="初始化用户路由模块"><a href="#初始化用户路由模块" class="headerlink" title="初始化用户路由模块"></a>初始化用户路由模块</h3><p>在 <code>router</code> 文件夹中，新建 <code>user.js</code> 文件，作为用户的路由模块，并初始化代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新用户</span></span><br><span class="line">router.post(<span class="string">'/reguser'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'reguser OK'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'login OK'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中，导入注册用户路由模块 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">'./router/user'</span>)</span><br><span class="line">app.use(<span class="string">'/api'</span>, userRouter)</span><br></pre></td></tr></table></figure>
<h3 id="抽离用户路由模块中的处理函数"><a href="#抽离用户路由模块中的处理函数" class="headerlink" title="抽离用户路由模块中的处理函数"></a>抽离用户路由模块中的处理函数</h3><blockquote>
<p>目的：为了保证 <code>路由模块</code> 的纯粹性，所有的 <code>路由处理函数</code>，必须抽离到对应的 <code>路由处理函数模块</code> 中</p>
</blockquote>
<p>在 <code>/router_handler/user.js</code> 中，使用 <code>exports</code> 对象，分别向外共享如下两个 <code>路由处理函数</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在这里定义和用户相关的路由处理函数，供 /router/user.js 模块进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册用户的处理函数</span></span><br><span class="line">exports.regUser = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'reguser OK'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录的处理函数</span></span><br><span class="line">exports.login = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'login OK'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>/router/user.js</code> 中的代码修改为如下结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入用户路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> userHandler = <span class="built_in">require</span>(<span class="string">'../router_handler/user'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新用户</span></span><br><span class="line">router.post(<span class="string">'/reguser'</span>, userHandler.regUser)</span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, userHandler.login)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<h2 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h2><h3 id="新建-ev-users-表"><a href="#新建-ev-users-表" class="headerlink" title="新建 ev_users 表"></a>新建 ev_users 表</h3><p>在 <code>test</code> 数据库中，新建 <code>ev_users</code> 表如下：</p>
<p><img src="https://brucecai55520.gitee.io/bruceblog/assets/img/ev_users.77f8cdd3.png" alt="ev_users表结构"></p>
<h3 id="安装并配置-mysql-模块"><a href="#安装并配置-mysql-模块" class="headerlink" title="安装并配置 mysql 模块"></a>安装并配置 mysql 模块</h3><blockquote>
<p>在 API 接口项目中，需要安装并配置 <code>mysql</code> 这个第三方模块，来连接和操作 MySQL 数据库</p>
</blockquote>
<p>运行如下命令，安装 <code>mysql</code> 模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mysql@2.18.1</span><br></pre></td></tr></table></figure>
<p>在项目根目录中新建 <code>/db/index.js</code> 文件，在此自定义模块中创建数据库的连接对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库连接对象</span></span><br><span class="line"><span class="keyword">const</span> db = mysql.createPool(&#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  user: <span class="string">'root'</span>,</span><br><span class="line">  password: <span class="string">'admin123'</span>,</span><br><span class="line">  database: <span class="string">'my_db_01'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享 db 数据库连接对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = db</span><br></pre></td></tr></table></figure>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>检测表单数据是否合法</li>
<li>检测用户名是否被占用</li>
<li>对密码进行加密处理</li>
<li>插入新用户</li>
</ol>
<h4 id="检测表单数据是否合法"><a href="#检测表单数据是否合法" class="headerlink" title="检测表单数据是否合法"></a>检测表单数据是否合法</h4><p>判断用户名和密码是否为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收表单数据</span></span><br><span class="line"><span class="keyword">const</span> userinfo = req.body</span><br><span class="line"><span class="comment">// 判断数据是否合法</span></span><br><span class="line"><span class="keyword">if</span> (!userinfo.username || !userinfo.password) &#123;</span><br><span class="line">  <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'用户名或密码不能为空！'</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测用户名是否被占用"><a href="#检测用户名是否被占用" class="headerlink" title="检测用户名是否被占用"></a>检测用户名是否被占用</h4><p>导入数据库操作模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../db/index'</span>)</span><br></pre></td></tr></table></figure>
<p>定义 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_users where username=?`</span></span><br></pre></td></tr></table></figure>
<p>执行 SQL 语句并根据结果判断用户名是否被占用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, [userinfo.username], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: err.message &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用户名被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'用户名被占用，请更换其他用户名！'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 用户名可用，继续后续流程...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="对密码进行加密处理"><a href="#对密码进行加密处理" class="headerlink" title="对密码进行加密处理"></a>对密码进行加密处理</h4><blockquote>
<p>为了保证密码的安全性，不建议在数据库以 <code>明文</code> 的形式保存用户密码，推荐对密码进行 <code>加密存储</code></p>
</blockquote>
<hr>
<p>在当前项目中，使用 <code>bcryptjs</code> 对用户密码进行加密，优点：</p>
<ul>
<li>加密之后的密码，<strong>无法被逆向破解</strong></li>
<li>同一明文密码多次加密，得到的<strong>加密结果各不相同</strong>，保证了安全性</li>
</ul>
<hr>
<p>运行如下命令，安装指定版本的 <code>bcryptjs</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i bcryptjs@2.4.3</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/user.js</code> 中，导入 <code>bcryptjs</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcryptjs'</span>)</span><br></pre></td></tr></table></figure>
<p>在注册用户的处理函数中，确认用户名可用之后，调用 <code>bcrypt.hashSync(明文密码, 随机盐的长度)</code> 方法，对用户的密码进行加密处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对用户的密码,进行 bcrype 加密，返回值是加密之后的密码字符串</span></span><br><span class="line">userinfo.password = bcrypt.hashSync(userinfo.password, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="插入新用户"><a href="#插入新用户" class="headerlink" title="插入新用户"></a>插入新用户</h4><p>定义插入用户的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">'insert into ev_users set ?'</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句，插入新用户：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, &#123; <span class="attr">username</span>: userinfo.username, <span class="attr">password</span>: userinfo.password &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: err.message &#125;)</span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但影响行数不为 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.send(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">message</span>: <span class="string">'注册用户失败，请稍后再试！'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册成功</span></span><br><span class="line">  res.send(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">message</span>: <span class="string">'注册成功！'</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="优化-res-send-代码"><a href="#优化-res-send-代码" class="headerlink" title="优化 res.send() 代码"></a>优化 res.send() 代码</h3><blockquote>
<p>在处理函数中，需要多次调用 <code>res.send()</code> 向客户端响应 <code>处理失败</code> 的结果，为了简化代码，可以手动封装一个 res.cc() 函数</p>
</blockquote>
<p>在 <code>app.js</code> 中，所有路由之前，声明一个全局中间件，为 res 对象挂载一个 <code>res.cc()</code> 函数 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应数据的中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况</span></span><br><span class="line">  res.cc = <span class="function"><span class="keyword">function</span> (<span class="params">err, status = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">      <span class="comment">// 状态</span></span><br><span class="line">      status,</span><br><span class="line">      <span class="comment">// 状态描述，判断 err 是 错误对象 还是 字符串</span></span><br><span class="line">      message: err <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? err.message : err,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="优化表单数据验证"><a href="#优化表单数据验证" class="headerlink" title="优化表单数据验证"></a>优化表单数据验证</h3><blockquote>
<p>表单验证的原则：前端验证为辅，后端验证为主，后端<strong>永远不要相信</strong>前端提交过来的<strong>任何内容</strong></p>
</blockquote>
<p>在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，<strong>后端做为数据合法性验证的最后一个关口</strong>，在拦截非法数据方面，起到了至关重要的作用。</p>
<p>单纯的使用 <code>if...else...</code> 的形式对数据合法性进行验证，效率低下、出错率高、维护性差。因此，推荐使用<strong>第三方数据验证模块</strong>，来降低出错率、提高验证的效率与可维护性，<strong>让后端程序员把更多的精力放在核心业务逻辑的处理上</strong>。</p>
<p>安装 <code>joi</code> 包，为表单中携带的每个数据项，定义验证规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install joi</span><br></pre></td></tr></table></figure>
<p>安装 <code>@escook/express-joi</code> 中间件，来实现自动对表单数据进行验证的功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @escook/express-joi</span><br></pre></td></tr></table></figure>
<p>新建 <code>/schema/user.js</code> 用户信息验证规则模块，并初始化代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">'joi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * string() 值必须是字符串</span></span><br><span class="line"><span class="comment"> * alphanum() 值只能是包含 a-zA-Z0-9 的字符串</span></span><br><span class="line"><span class="comment"> * min(length) 最小长度</span></span><br><span class="line"><span class="comment"> * max(length) 最大长度</span></span><br><span class="line"><span class="comment"> * required() 值是必填项，不能为 undefined</span></span><br><span class="line"><span class="comment"> * pattern(正则表达式) 值必须符合正则表达式的规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户名的验证规则</span></span><br><span class="line"><span class="keyword">const</span> username = joi.string().alphanum().min(<span class="number">1</span>).max(<span class="number">10</span>).required()</span><br><span class="line"><span class="comment">// 密码的验证规则</span></span><br><span class="line"><span class="keyword">const</span> password = joi</span><br><span class="line">  .string()</span><br><span class="line">  .pattern(<span class="regexp">/^[\S]&#123;6,12&#125;$/</span>)</span><br><span class="line">  .required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册和登录表单的验证规则对象</span></span><br><span class="line">exports.reg_login_schema = &#123;</span><br><span class="line">  <span class="comment">// 表示需要对 req.body 中的数据进行验证</span></span><br><span class="line">  body: &#123;</span><br><span class="line">    username,</span><br><span class="line">    password,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>/router/user.js</code> 中的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入用户路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> userHandler = <span class="built_in">require</span>(<span class="string">'../router_handler/user'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">'@escook/express-joi'</span>)</span><br><span class="line"><span class="comment">// 2. 导入需要的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; reg_login_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/user'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新用户</span></span><br><span class="line"><span class="comment">// 3. 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证</span></span><br><span class="line"><span class="comment">// 3.1 数据验证通过后，会把这次请求流转给后面的路由处理函数</span></span><br><span class="line"><span class="comment">// 3.2 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理</span></span><br><span class="line">router.post(<span class="string">'/reguser'</span>, expressJoi(reg_login_schema), userHandler.regUser)</span><br><span class="line"><span class="comment">// 登录</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, userHandler.login)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">'joi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 数据验证失败</span></span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> joi.ValidationError) <span class="keyword">return</span> res.cc(err)</span><br><span class="line">  <span class="comment">// 未知错误</span></span><br><span class="line">  res.cc(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>检测表单数据是否合法</li>
<li>根据用户名查询用户的数据</li>
<li>判断用户输入的密码是否正确</li>
<li>生成 JWT 的 Token 字符串</li>
</ol>
<h4 id="检测登录表单的数据是否合法"><a href="#检测登录表单的数据是否合法" class="headerlink" title="检测登录表单的数据是否合法"></a>检测登录表单的数据是否合法</h4><p>将 <code>/router/user.js</code> 中 <code>登录</code> 的路由代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录的路由</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, expressJoi(reg_login_schema), userHandler.login)</span><br></pre></td></tr></table></figure>
<h4 id="根据用户名查询用户的数据"><a href="#根据用户名查询用户的数据" class="headerlink" title="根据用户名查询用户的数据"></a>根据用户名查询用户的数据</h4><p>接收表单数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userinfo = req.body</span><br></pre></td></tr></table></figure>
<p>定义 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_users where username=?`</span></span><br></pre></td></tr></table></figure>
<p>执行 SQL 语句，查询用户的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, userinfo.username, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是查询到数据条数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.length !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'登录失败！'</span>)</span><br><span class="line">  <span class="comment">// TODO：判断用户输入的登录密码是否和数据库中的密码一致</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="判断用户输入的密码是否正确"><a href="#判断用户输入的密码是否正确" class="headerlink" title="判断用户输入的密码是否正确"></a>判断用户输入的密码是否正确</h4><blockquote>
<p>核心实现思路：调用 <code>bcrypt.compareSync(用户提交的密码, 数据库中的密码)</code> 方法比较密码是否一致</p>
</blockquote>
<blockquote>
<p>返回值是布尔值（true 一致、false 不一致）</p>
</blockquote>
<p>具体的实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿着用户输入的密码,和数据库中存储的密码进行对比</span></span><br><span class="line"><span class="keyword">const</span> compareResult = bcrypt.compareSync(userinfo.password, results[<span class="number">0</span>].password)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对比的结果等于 false, 则证明用户输入的密码错误</span></span><br><span class="line"><span class="keyword">if</span> (!compareResult) &#123;</span><br><span class="line">  <span class="keyword">return</span> res.cc(<span class="string">'登录失败！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO：登录成功，生成 Token 字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="生成-JWT-的-Token-字符串"><a href="#生成-JWT-的-Token-字符串" class="headerlink" title="生成 JWT 的 Token 字符串"></a>生成 JWT 的 Token 字符串</h4><blockquote>
<p>核心注意点：在生成 Token 字符串的时候，一定要剔除 <strong>密码</strong> 和 <strong>头像</strong> 的值</p>
</blockquote>
<p>通过 ES6 的高级语法，快速剔除 <code>密码</code> 和 <code>头像</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剔除完毕之后，user 中只保留了用户的 id, username, nickname, email 这四个属性的值</span></span><br><span class="line"><span class="keyword">const</span> user = &#123; ...results[<span class="number">0</span>], <span class="attr">password</span>: <span class="string">''</span>, <span class="attr">user_pic</span>: <span class="string">''</span> &#125;</span><br></pre></td></tr></table></figure>
<p>运行如下的命令，安装生成 Token 字符串的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i jsonwebtoken@8.5.1</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/user.js</code> 模块的头部区域，导入 <code>jsonwebtoken</code> 包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用这个包来生成 Token 字符串</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br></pre></td></tr></table></figure>
<p>创建 <code>config.js</code> 文件，并向外共享 <strong>加密</strong> 和 <strong>还原</strong> Token 的 <code>jwtSecretKey</code> 字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  jwtSecretKey: <span class="string">'Bruce'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将用户信息对象加密成 Token 字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 Token 字符串</span></span><br><span class="line"><span class="keyword">const</span> tokenStr = jwt.sign(user, config.jwtSecretKey, &#123;</span><br><span class="line">  expiresIn: <span class="string">'10h'</span>, <span class="comment">// token 有效期为 10 个小时</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>将生成的 Token 字符串响应给客户端：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(&#123;</span><br><span class="line">  status: <span class="number">0</span>,</span><br><span class="line">  message: <span class="string">'登录成功！'</span>,</span><br><span class="line">  <span class="comment">// 为了方便客户端使用 Token，在服务器端直接拼接上 Bearer 的前缀</span></span><br><span class="line">  token: <span class="string">'Bearer '</span> + tokenStr,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="配置解析-Token-的中间件"><a href="#配置解析-Token-的中间件" class="headerlink" title="配置解析 Token 的中间件"></a>配置解析 Token 的中间件</h3><p>运行如下的命令，安装解析 Token 的中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i express-jwt@<span class="number">5.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中注册路由之前，配置解析 Token 的中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入配置文件</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 token 的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">'express-jwt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 .unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口不需要进行 Token 的身份认证</span></span><br><span class="line">app.use(expressJWT(&#123; <span class="attr">secret</span>: config.jwtSecretKey &#125;).unless(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中的 <code>错误级别中间件</code> 里面，捕获并处理 Token 认证失败后的错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 捕获身份认证失败的错误</span></span><br><span class="line">  <span class="keyword">if</span> (err.name === <span class="string">'UnauthorizedError'</span>) <span class="keyword">return</span> res.cc(<span class="string">'身份认证失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未知错误...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h2><h3 id="获取用户的基本信息"><a href="#获取用户的基本信息" class="headerlink" title="获取用户的基本信息"></a>获取用户的基本信息</h3><h4 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>初始化 <strong>路由</strong> 模块</li>
<li>初始化 <strong>路由处理函数</strong> 模块</li>
<li>获取用户的基本信息</li>
</ol>
<h4 id="初始化路由模块"><a href="#初始化路由模块" class="headerlink" title="初始化路由模块"></a>初始化路由模块</h4><p>创建 <code>/router/userinfo.js</code> 路由模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户的基本信息</span></span><br><span class="line">router.get(<span class="string">'/userinfo'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中导入并使用个人中心的路由模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入并使用用户信息路由模块</span></span><br><span class="line"><span class="keyword">const</span> userinfoRouter = <span class="built_in">require</span>(<span class="string">'./router/userinfo'</span>)</span><br><span class="line"><span class="comment">// 注意：以 /my 开头的接口，都是有权限的接口，需要进行 Token 身份认证</span></span><br><span class="line">app.use(<span class="string">'/my'</span>, userinfoRouter)</span><br></pre></td></tr></table></figure>
<h4 id="初始化路由处理函数模块"><a href="#初始化路由处理函数模块" class="headerlink" title="初始化路由处理函数模块"></a>初始化路由处理函数模块</h4><p>创建 <code>/router_handler/userinfo.js</code> 路由处理函数模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户基本信息的处理函数</span></span><br><span class="line">exports.getUserInfo = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>/router/userinfo.js</code> 中的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入用户信息的处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> userinfo_handler = <span class="built_in">require</span>(<span class="string">'../router_handler/userinfo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户的基本信息</span></span><br><span class="line">router.get(<span class="string">'/userinfo'</span>, userinfo_handler.getUserInfo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<h4 id="获取用户的基本信息-1"><a href="#获取用户的基本信息-1" class="headerlink" title="获取用户的基本信息"></a>获取用户的基本信息</h4><p>在 <code>/router_handler/userinfo.js</code> 头部导入数据库操作模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../db/index'</span>)</span><br></pre></td></tr></table></figure>
<p>定义 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据用户的 id，查询用户的基本信息</span></span><br><span class="line"><span class="comment">// 注意：为了防止用户的密码泄露，需要排除 password 字段</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select id, username, nickname, email, user_pic from ev_users where id=?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：req 对象上的 user 属性，是 Token 解析成功，express-jwt 中间件帮我们挂载上去的</span></span><br><span class="line">db.query(sql, req.user.id, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 执行 SQL 语句成功，但是查询到的数据条数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.length !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'获取用户信息失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将用户信息响应给客户端</span></span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: <span class="number">0</span>,</span><br><span class="line">    message: <span class="string">'获取用户基本信息成功！'</span>,</span><br><span class="line">    data: results[<span class="number">0</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="更新用户的基本信息"><a href="#更新用户的基本信息" class="headerlink" title="更新用户的基本信息"></a>更新用户的基本信息</h3><h4 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现更新用户基本信息的功能</li>
</ol>
<h4 id="定义路由和处理函数"><a href="#定义路由和处理函数" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/userinfo.js</code> 模块中，新增 <code>更新用户基本信息</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新用户的基本信息</span></span><br><span class="line">router.post(<span class="string">'/userinfo'</span>, userinfo_handler.updateUserInfo)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/userinfo.js</code> 模块中，定义并向外共享 <code>更新用户基本信息</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新用户基本信息的处理函数</span></span><br><span class="line">exports.updateUserInfo = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据"><a href="#验证表单数据" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><p>在 <code>/schema/user.js</code> 验证规则模块中，定义 <code>id</code>，<code>nickname</code>，<code>email</code> 的验证规则如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 id, nickname, emial 的验证规则</span></span><br><span class="line"><span class="keyword">const</span> id = joi.number().integer().min(<span class="number">1</span>).required()</span><br><span class="line"><span class="keyword">const</span> nickname = joi.string().required()</span><br><span class="line"><span class="keyword">const</span> email = joi.string().email().required()</span><br></pre></td></tr></table></figure>
<p>并使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证规则对象 - 更新用户基本信息</span></span><br><span class="line">exports.update_userinfo_schema = &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    id,</span><br><span class="line">    nickname,</span><br><span class="line">    email,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/userinfo.js</code> 模块中，导入验证数据合法性的中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入验证数据合法性的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">'@escook/express-joi'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/userinfo.js</code> 模块中，导入需要的验证规则对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; update_userinfo_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/user'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/userinfo.js</code> 模块中，修改 <code>更新用户的基本信息</code> 的路由如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新用户的基本信息</span></span><br><span class="line">router.post(<span class="string">'/userinfo'</span>, expressJoi(update_userinfo_schema), userinfo_handler.updateUserInfo)</span><br></pre></td></tr></table></figure>
<h4 id="实现更新用户基本信息的功能"><a href="#实现更新用户基本信息的功能" class="headerlink" title="实现更新用户基本信息的功能"></a>实现更新用户基本信息的功能</h4><p>定义待执行的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_users set ? where id=?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句并传参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, [req.body, req.body.id], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但影响行数不为 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'修改用户基本信息失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改用户信息成功</span></span><br><span class="line">  <span class="keyword">return</span> res.cc(<span class="string">'修改用户基本信息成功！'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><h4 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现重置密码的功能</li>
</ol>
<h4 id="定义路由和处理函数-1"><a href="#定义路由和处理函数-1" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/userinfo.js</code> 模块中，新增 <code>重置密码</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置密码的路由</span></span><br><span class="line">router.post(<span class="string">'/updatepwd'</span>, userinfo_handler.updatePassword)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/userinfo.js</code> 模块中，定义并向外共享 <code>重置密码</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置密码的处理函数</span></span><br><span class="line">exports.updatePassword = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-1"><a href="#验证表单数据-1" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><blockquote>
<p>核心验证思路：旧密码与新密码，必须符合密码的验证规则，并且新密码不能与旧密码一致！</p>
</blockquote>
<p>在 <code>/schema/user.js</code> 模块中，使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证规则对象 - 重置密码</span></span><br><span class="line">exports.update_password_schema = &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    <span class="comment">// 使用 password 这个规则，验证 req.body.oldPwd 的值</span></span><br><span class="line">    oldPwd: password,</span><br><span class="line">    <span class="comment">// 使用 joi.not(joi.ref('oldPwd')).concat(password) 规则，验证 req.body.newPwd 的值</span></span><br><span class="line">    <span class="comment">// 解读：</span></span><br><span class="line">    <span class="comment">// 1. joi.ref('oldPwd') 表示 newPwd 的值必须和 oldPwd 的值保持一致</span></span><br><span class="line">    <span class="comment">// 2. joi.not(joi.ref('oldPwd')) 表示 newPwd 的值不能等于 oldPwd 的值</span></span><br><span class="line">    <span class="comment">// 3. .concat() 用于合并 joi.not(joi.ref('oldPwd')) 和 password 这两条验证规则</span></span><br><span class="line">    newPwd: joi.not(joi.ref(<span class="string">'oldPwd'</span>)).concat(password),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/userinfo.js</code> 模块中，导入需要的验证规则对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; update_userinfo_schema, update_password_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/user'</span>)</span><br></pre></td></tr></table></figure>
<p>并在 <code>重置密码的路由</code> 中，使用 <code>update_password_schema</code> 规则验证表单的数据，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/updatepwd'</span>, expressJoi(update_password_schema), userinfo_handler.updatePassword)</span><br></pre></td></tr></table></figure>
<h4 id="实现重置密码的功能"><a href="#实现重置密码的功能" class="headerlink" title="实现重置密码的功能"></a>实现重置密码的功能</h4><p>根据 <code>id</code> 查询用户是否存在：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义根据 id 查询用户数据的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_users where id=?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句查询用户是否存在</span></span><br><span class="line">db.query(sql, req.user.id, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查指定 id 的用户是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (results.length !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'用户不存在！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：判断提交的旧密码是否正确</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>判断提交的 <strong>旧密码</strong> 是否正确：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在头部区域导入 bcryptjs 后，</span></span><br><span class="line"><span class="comment">// 即可使用 bcrypt.compareSync(提交的密码，数据库中的密码) 方法验证密码是否正确</span></span><br><span class="line"><span class="comment">// compareSync() 函数的返回值为布尔值，true 表示密码正确，false 表示密码错误</span></span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcryptjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断提交的旧密码是否正确</span></span><br><span class="line"><span class="keyword">const</span> compareResult = bcrypt.compareSync(req.body.oldPwd, results[<span class="number">0</span>].password)</span><br><span class="line"><span class="keyword">if</span> (!compareResult) <span class="keyword">return</span> res.cc(<span class="string">'原密码错误！'</span>)</span><br></pre></td></tr></table></figure>
<p>对新密码进行 <code>bcrypt</code> 加密之后，更新到数据库中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义更新用户密码的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_users set password=? where id=?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对新密码进行 bcrypt 加密处理</span></span><br><span class="line"><span class="keyword">const</span> newPwd = bcrypt.hashSync(req.body.newPwd, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句，根据 id 更新用户的密码</span></span><br><span class="line">db.query(sql, [newPwd, req.user.id], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// SQL 语句执行失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'更新密码失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新密码成功</span></span><br><span class="line">  res.cc(<span class="string">'更新密码成功！'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="更新用户头像"><a href="#更新用户头像" class="headerlink" title="更新用户头像"></a>更新用户头像</h3><h4 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现更新用户头像的功能</li>
</ol>
<h4 id="定义路由和处理函数-2"><a href="#定义路由和处理函数-2" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/userinfo.js</code> 模块中，新增 <code>更新用户头像</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新用户头像的路由</span></span><br><span class="line">router.post(<span class="string">'/update/avatar'</span>, userinfo_handler.updateAvatar)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/userinfo.js</code> 模块中，定义并向外共享 <code>更新用户头像</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新用户头像的处理函数</span></span><br><span class="line">exports.updateAvatar = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-2"><a href="#验证表单数据-2" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><p>在 <code>/schema/user.js</code> 验证规则模块中，定义 <code>avatar</code> 的验证规则如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataUri() 指的是如下格式的字符串数据：</span></span><br><span class="line"><span class="comment">// data:image/png;base64,VE9PTUFOWVNFQ1JFVFM=</span></span><br><span class="line"><span class="keyword">const</span> avatar = joi.string().dataUri().required()</span><br></pre></td></tr></table></figure>
<p>并使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证规则对象 - 更新头像</span></span><br><span class="line">exports.update_avatar_schema = &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    avatar,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/userinfo.js</code> 模块中，导入需要的验证规则对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; update_avatar_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/user'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/userinfo.js</code> 模块中，修改 <code>更新用户头像</code> 的路由如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/update/avatar'</span>, expressJoi(update_avatar_schema), userinfo_handler.updateAvatar)</span><br></pre></td></tr></table></figure>
<h4 id="实现更新用户头像的功能"><a href="#实现更新用户头像的功能" class="headerlink" title="实现更新用户头像的功能"></a>实现更新用户头像的功能</h4><p>定义更新用户头像的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">'update ev_users set user_pic=? where id=?'</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句，更新对应用户的头像：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, [req.body.avatar, req.user.id], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'更新头像失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新用户头像成功</span></span><br><span class="line">  <span class="keyword">return</span> res.cc(<span class="string">'更新头像成功！'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="文章分类管理"><a href="#文章分类管理" class="headerlink" title="文章分类管理"></a>文章分类管理</h2><h3 id="新建-ev-article-cate-表"><a href="#新建-ev-article-cate-表" class="headerlink" title="新建 ev_article_cate 表"></a>新建 ev_article_cate 表</h3><p><img src="https://brucecai55520.gitee.io/bruceblog/assets/img/ev_article_cate.f52fe7ce.png" alt="文章分类表结构"></p>
<h3 id="获取文章分类列表"><a href="#获取文章分类列表" class="headerlink" title="获取文章分类列表"></a>获取文章分类列表</h3><h4 id="实现步骤-6"><a href="#实现步骤-6" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>初始化路由模块</li>
<li>初始化路由处理函数模块</li>
<li>获取文章分类列表数据</li>
</ol>
<h4 id="初始化路由模块-1"><a href="#初始化路由模块-1" class="headerlink" title="初始化路由模块"></a>初始化路由模块</h4><p>创建 <code>/router/artcate.js</code> 路由模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文章分类的列表数据</span></span><br><span class="line">router.get(<span class="string">'/cates'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中导入并使用文章分类的路由模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入并使用文章分类路由模块</span></span><br><span class="line"><span class="keyword">const</span> artCateRouter = <span class="built_in">require</span>(<span class="string">'./router/artcate'</span>)</span><br><span class="line"><span class="comment">// 为文章分类的路由挂载统一的访问前缀 /my/article</span></span><br><span class="line">app.use(<span class="string">'/my/article'</span>, artCateRouter)</span><br></pre></td></tr></table></figure>
<h4 id="初始化路由处理函数模块-1"><a href="#初始化路由处理函数模块-1" class="headerlink" title="初始化路由处理函数模块"></a>初始化路由处理函数模块</h4><p>创建 <code>/router_handler/artcate.js</code> 路由处理函数模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文章分类列表数据的处理函数</span></span><br><span class="line">exports.getArticleCates = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>/router/artcate.js</code> 中的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入文章分类的路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> artcate_handler = <span class="built_in">require</span>(<span class="string">'../router_handler/artcate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文章分类的列表数据</span></span><br><span class="line">router.get(<span class="string">'/cates'</span>, artcate_handler.getArticleCates)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<h4 id="获取文章分类列表数据"><a href="#获取文章分类列表数据" class="headerlink" title="获取文章分类列表数据"></a>获取文章分类列表数据</h4><p>在 <code>/router_handler/artcate.js</code> 头部导入数据库操作模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../db/index'</span>)</span><br></pre></td></tr></table></figure>
<p>定义 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据分类的状态，获取所有未被删除的分类列表数据</span></span><br><span class="line"><span class="comment">// is_delete 为 0 表示没有被 标记为删除 的数据</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">'select * from ev_article_cate where is_delete=0 order by id asc'</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 1. 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 执行 SQL 语句成功</span></span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: <span class="number">0</span>,</span><br><span class="line">    message: <span class="string">'获取文章分类列表成功！'</span>,</span><br><span class="line">    data: results,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="新增文章分类"><a href="#新增文章分类" class="headerlink" title="新增文章分类"></a>新增文章分类</h3><h4 id="实现步骤-7"><a href="#实现步骤-7" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>查询 <code>分类名称</code> 与 <code>分类别名</code> 是否被占用</li>
<li>实现新增文章分类的功能</li>
</ol>
<h4 id="定义路由和处理函数-3"><a href="#定义路由和处理函数-3" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/artcate.js</code> 模块中，添加 <code>新增文章分类</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增文章分类的路由</span></span><br><span class="line">router.post(<span class="string">'/addcates'</span>, artcate_handler.addArticleCates)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>新增文章分类</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增文章分类的处理函数</span></span><br><span class="line">exports.addArticleCates = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-3"><a href="#验证表单数据-3" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><p>创建 <code>/schema/artcate.js</code> 文章分类数据验证模块，并定义如下的验证规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入定义验证规则的模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">'joi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 分类名称 和 分类别名 的校验规则</span></span><br><span class="line"><span class="keyword">const</span> name = joi.string().required()</span><br><span class="line"><span class="keyword">const</span> alias = joi.string().alphanum().required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验规则对象 - 添加分类</span></span><br><span class="line">exports.add_cate_schema = &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    name,</span><br><span class="line">    alias,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/artcate.js</code> 模块中，使用 <code>add_cate_schema</code> 对数据进行验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入验证数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">'@escook/express-joi'</span>)</span><br><span class="line"><span class="comment">// 导入文章分类的验证模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; add_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/artcate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增文章分类的路由</span></span><br><span class="line">router.post(<span class="string">'/addcates'</span>, expressJoi(add_cate_schema), artcate_handler.addArticleCates)</span><br></pre></td></tr></table></figure>
<h4 id="查询分类名称与别名是否被占用"><a href="#查询分类名称与别名是否被占用" class="headerlink" title="查询分类名称与别名是否被占用"></a>查询分类名称与别名是否被占用</h4><p>定义查重的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_article_cate where name=? or alias=?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行查重的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行查重操作</span></span><br><span class="line">db.query(sql, [req.body.name, req.body.alias], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 分类名称 和 分类别名 是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.length === <span class="number">2</span>) <span class="keyword">return</span> res.cc(<span class="string">'分类名称与别名被占用，请更换后重试！'</span>)</span><br><span class="line">  <span class="comment">// 分别判断 分类名称 和 分类别名 是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.length === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].name === req.body.name) <span class="keyword">return</span> res.cc(<span class="string">'分类名称被占用，请更换后重试！'</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.length === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].alias === req.body.alias) <span class="keyword">return</span> res.cc(<span class="string">'分类别名被占用，请更换后重试！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：新增文章分类</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="实现新增文章分类的功能"><a href="#实现新增文章分类的功能" class="headerlink" title="实现新增文章分类的功能"></a>实现新增文章分类的功能</h4><p>定义新增文章分类的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`insert into ev_article_cate set ?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行新增文章分类的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, req.body, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// SQL 语句执行失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'新增文章分类失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增文章分类成功</span></span><br><span class="line">  res.cc(<span class="string">'新增文章分类成功！'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="根据-Id-删除文章分类"><a href="#根据-Id-删除文章分类" class="headerlink" title="根据 Id 删除文章分类"></a>根据 Id 删除文章分类</h3><h4 id="实现步骤-8"><a href="#实现步骤-8" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现删除文章分类的功能</li>
</ol>
<h4 id="定义路由和处理函数-4"><a href="#定义路由和处理函数-4" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/artcate.js</code> 模块中，添加 <code>删除文章分类</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除文章分类的路由</span></span><br><span class="line">router.get(<span class="string">'/deletecate/:id'</span>, artcate_handler.deleteCateById)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>删除文章分类</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除文章分类的处理函数</span></span><br><span class="line">exports.deleteCateById = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-4"><a href="#验证表单数据-4" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><p>在 <code>/schema/artcate.js</code> 验证规则模块中，定义 id 的验证规则如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 分类Id 的校验规则</span></span><br><span class="line"><span class="keyword">const</span> id = joi.number().integer().min(<span class="number">1</span>).required()</span><br></pre></td></tr></table></figure>
<p>并使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验规则对象 - 删除分类</span></span><br><span class="line">exports.delete_cate_schema = &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    id,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/artcate.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入删除分类的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; delete_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/artcate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文章分类的路由</span></span><br><span class="line">router.get(<span class="string">'/deletecate/:id'</span>, expressJoi(delete_cate_schema), artcate_handler.deleteCateById)</span><br></pre></td></tr></table></figure>
<h4 id="实现删除文章分类的功能"><a href="#实现删除文章分类的功能" class="headerlink" title="实现删除文章分类的功能"></a>实现删除文章分类的功能</h4><p>定义删除文章分类的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_article_cate set is_delete=1 where id=?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行删除文章分类的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, req.params.id, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'删除文章分类失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除文章分类成功</span></span><br><span class="line">  res.cc(<span class="string">'删除文章分类成功！'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="根据-Id-获取文章分类数据"><a href="#根据-Id-获取文章分类数据" class="headerlink" title="根据 Id 获取文章分类数据"></a>根据 Id 获取文章分类数据</h3><h4 id="实现步骤-9"><a href="#实现步骤-9" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>实现获取文章分类的功能</li>
</ol>
<h4 id="定义路由和处理函数-5"><a href="#定义路由和处理函数-5" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/artcate.js</code> 模块中，添加 <code>根据 Id 获取文章分类</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/cates/:id'</span>, artcate_handler.getArticleById)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>根据 Id 获取文章分类</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 Id 获取文章分类的处理函数</span></span><br><span class="line">exports.getArticleById = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-5"><a href="#验证表单数据-5" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><p>在 <code>/schema/artcate.js</code> 验证规则模块中，使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验规则对象 - 根据 Id 获取分类</span></span><br><span class="line">exports.get_cate_schema = &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    id,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/artcate.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入根据 Id 获取分类的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; get_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/artcate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Id 获取文章分类的路由</span></span><br><span class="line">router.get(<span class="string">'/cates/:id'</span>, expressJoi(get_cate_schema), artcate_handler.getArticleById)</span><br></pre></td></tr></table></figure>
<h4 id="实现获取文章分类的功能"><a href="#实现获取文章分类的功能" class="headerlink" title="实现获取文章分类的功能"></a>实现获取文章分类的功能</h4><p>定义根据 Id 获取文章分类的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_article_cate where id=?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, req.params.id, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是没有查询到任何数据</span></span><br><span class="line">  <span class="keyword">if</span> (results.length !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'获取文章分类数据失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数据响应给客户端</span></span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: <span class="number">0</span>,</span><br><span class="line">    message: <span class="string">'获取文章分类数据成功！'</span>,</span><br><span class="line">    data: results[<span class="number">0</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="根据-Id-更新文章分类数据"><a href="#根据-Id-更新文章分类数据" class="headerlink" title="根据 Id 更新文章分类数据"></a>根据 Id 更新文章分类数据</h3><h4 id="实现步骤-10"><a href="#实现步骤-10" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>定义路由和处理函数</li>
<li>验证表单数据</li>
<li>查询 <code>分类名称</code> 与 <code>分类别名</code> 是否被占用</li>
<li>实现更新文章分类的功能</li>
</ol>
<h4 id="定义路由和处理函数-6"><a href="#定义路由和处理函数-6" class="headerlink" title="定义路由和处理函数"></a>定义路由和处理函数</h4><p>在 <code>/router/artcate.js</code> 模块中，添加 <code>更新文章分类</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新文章分类的路由</span></span><br><span class="line">router.post(<span class="string">'/updatecate'</span>, artcate_handler.updateCateById)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/artcate.js</code> 模块中，定义并向外共享 <code>更新文章分类</code> 的路由处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新文章分类的处理函数</span></span><br><span class="line">exports.updateCateById = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-6"><a href="#验证表单数据-6" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><p>在 <code>/schema/artcate.js</code> 验证规则模块中，使用 <code>exports</code> 向外共享如下的 <code>验证规则对象</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验规则对象 - 更新分类</span></span><br><span class="line">exports.update_cate_schema = &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    Id: id,</span><br><span class="line">    name,</span><br><span class="line">    alias,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/artcate.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入更新文章分类的验证规则对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; update_cate_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/artcate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新文章分类的路由</span></span><br><span class="line">router.post(<span class="string">'/updatecate'</span>, expressJoi(update_cate_schema), artcate_handler.updateCateById)</span><br></pre></td></tr></table></figure>
<h4 id="查询分类名称与别名是否被占用-1"><a href="#查询分类名称与别名是否被占用-1" class="headerlink" title="查询分类名称与别名是否被占用"></a>查询分类名称与别名是否被占用</h4><p>定义查重的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">`select * from ev_article_cate where Id&lt;&gt;? and (name=? or alias=?)`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行查重的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行查重操作</span></span><br><span class="line">db.query(sql, [req.body.Id, req.body.name, req.body.alias], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 分类名称 和 分类别名 是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (results.length === <span class="number">2</span>) <span class="keyword">return</span> res.cc(<span class="string">'分类名称与别名被占用，请更换后重试！'</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.length === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].name === req.body.name) <span class="keyword">return</span> res.cc(<span class="string">'分类名称被占用，请更换后重试！'</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.length === <span class="number">1</span> &amp;&amp; results[<span class="number">0</span>].alias === req.body.alias) <span class="keyword">return</span> res.cc(<span class="string">'分类别名被占用，请更换后重试！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：更新文章分类</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="实现更新文章分类的功能"><a href="#实现更新文章分类的功能" class="headerlink" title="实现更新文章分类的功能"></a>实现更新文章分类的功能</h4><p>定义更新文章分类的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`update ev_article_cate set ? where Id=?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.query(sql, [req.body, req.body.Id], (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SQL 语句执行成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'更新文章分类失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新文章分类成功</span></span><br><span class="line">  res.cc(<span class="string">'更新文章分类成功！'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="文章管理"><a href="#文章管理" class="headerlink" title="文章管理"></a>文章管理</h2><h3 id="新建-ev-articles-表"><a href="#新建-ev-articles-表" class="headerlink" title="新建 ev_articles 表"></a>新建 ev_articles 表</h3><p><img src="https://brucecai55520.gitee.io/bruceblog/assets/img/ev_articles.01220b03.png" alt="ev_articles表结构"></p>
<h3 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h3><h4 id="实现步骤-11"><a href="#实现步骤-11" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>初始化路由模块</li>
<li>初始化路由处理函数模块</li>
<li>使用 multer 解析表单数据</li>
<li>验证表单数据</li>
<li>实现发布文章的功能</li>
</ol>
<h4 id="初始化路由模块-2"><a href="#初始化路由模块-2" class="headerlink" title="初始化路由模块"></a>初始化路由模块</h4><p>创建 <code>/router/article.js</code> 路由模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新文章</span></span><br><span class="line">router.post(<span class="string">'/add'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中导入并使用文章的路由模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入并使用文章路由模块</span></span><br><span class="line"><span class="keyword">const</span> articleRouter = <span class="built_in">require</span>(<span class="string">'./router/article'</span>)</span><br><span class="line"><span class="comment">// 为文章的路由挂载统一的访问前缀 /my/article</span></span><br><span class="line">app.use(<span class="string">'/my/article'</span>, articleRouter)</span><br></pre></td></tr></table></figure>
<h4 id="初始化路由处理函数模块-2"><a href="#初始化路由处理函数模块-2" class="headerlink" title="初始化路由处理函数模块"></a>初始化路由处理函数模块</h4><p>创建 <code>/router_handler/article.js</code> 路由处理函数模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的处理函数</span></span><br><span class="line">exports.addArticle = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>/router/article.js</code> 中的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入文章的路由处理函数模块</span></span><br><span class="line"><span class="keyword">const</span> article_handler = <span class="built_in">require</span>(<span class="string">'../router_handler/article'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新文章</span></span><br><span class="line">router.post(<span class="string">'/add'</span>, article_handler.addArticle)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<h4 id="使用-multer-解析表单数据"><a href="#使用-multer-解析表单数据" class="headerlink" title="使用 multer 解析表单数据"></a>使用 multer 解析表单数据</h4><blockquote>
<p>注意：使用 <code>express.urlencoded()</code> 中间件无法解析 <code>multipart/form-data</code> 格式的请求体数据。</p>
</blockquote>
<blockquote>
<p>当前项目，推荐使用 multer 来解析 <code>multipart/form-data</code> 格式的表单数据。<a href="https://www.npmjs.com/package/multer" target="_blank" rel="noopener">https://www.npmjs.com/package/multer</a></p>
</blockquote>
<p>运行如下的终端命令，在项目中安装 <code>multer</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i multer@1.4.2</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/article.js</code> 模块中导入并配置 <code>multer</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入解析 formdata 格式表单数据的包</span></span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"><span class="comment">// 导入处理路径的核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 multer 的实例对象，通过 dest 属性指定文件的存放路径</span></span><br><span class="line"><span class="keyword">const</span> upload = multer(&#123; <span class="attr">dest</span>: path.join(__dirname, <span class="string">'../uploads'</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>修改 <code>发布新文章</code> 的路由如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的路由</span></span><br><span class="line"><span class="comment">// upload.single() 是一个局部生效的中间件，用来解析 FormData 格式的表单数据</span></span><br><span class="line"><span class="comment">// 将文件类型的数据，解析并挂载到 req.file 属性中</span></span><br><span class="line"><span class="comment">// 将文本类型的数据，解析并挂载到 req.body 属性中</span></span><br><span class="line">router.post(<span class="string">'/add'</span>, upload.single(<span class="string">'cover_img'</span>), article_handler.addArticle)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/article.js</code> 模块中的 <code>addArticle</code> 处理函数中，将 <code>multer</code> 解析出来的数据进行打印：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的处理函数</span></span><br><span class="line">exports.addArticle = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.body) <span class="comment">// 文本类型的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--------分割线----------'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(req.file) <span class="comment">// 文件类型的数据</span></span><br><span class="line"></span><br><span class="line">  res.send(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="验证表单数据-7"><a href="#验证表单数据-7" class="headerlink" title="验证表单数据"></a>验证表单数据</h4><blockquote>
<p>实现思路：通过 express-joi <strong>自动验证</strong> req.body 中的文本数据；通过 if 判断<strong>手动验证</strong> req.file 中的文件数据；</p>
</blockquote>
<p>创建 <code>/schema/article.js</code> 验证规则模块，并初始化如下的代码结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入定义验证规则的模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">'joi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 标题、分类Id、内容、发布状态 的验证规则</span></span><br><span class="line"><span class="keyword">const</span> title = joi.string().required()</span><br><span class="line"><span class="keyword">const</span> cate_id = joi.number().integer().min(<span class="number">1</span>).required()</span><br><span class="line"><span class="keyword">const</span> content = joi.string().required().allow(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> state = joi.string().valid(<span class="string">'已发布'</span>, <span class="string">'草稿'</span>).required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证规则对象 - 发布文章</span></span><br><span class="line">exports.add_article_schema = &#123;</span><br><span class="line">  body: &#123;</span><br><span class="line">    title,</span><br><span class="line">    cate_id,</span><br><span class="line">    content,</span><br><span class="line">    state,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>/router/article.js</code> 模块中，导入需要的验证规则对象，并在路由中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入验证数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">'@escook/express-joi'</span>)</span><br><span class="line"><span class="comment">// 导入文章的验证模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; add_article_schema &#125; = <span class="built_in">require</span>(<span class="string">'../schema/article'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新文章的路由</span></span><br><span class="line"><span class="comment">// 注意：在当前的路由中，先后使用了两个中间件：</span></span><br><span class="line"><span class="comment">//       先使用 multer 解析表单数据</span></span><br><span class="line"><span class="comment">//       再使用 expressJoi 对解析的表单数据进行验证</span></span><br><span class="line">router.post(<span class="string">'/add'</span>, upload.single(<span class="string">'cover_img'</span>), expressJoi(add_article_schema), article_handler.addArticle)</span><br></pre></td></tr></table></figure>
<p>在 <code>/router_handler/article.js</code> 模块中的 <code>addArticle</code> 处理函数中，通过 <code>if</code> 判断客户端是否提交了 <code>封面图片</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布新文章的处理函数</span></span><br><span class="line">exports.addArticle = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 手动判断是否上传了文章封面</span></span><br><span class="line">  <span class="keyword">if</span> (!req.file || req.file.fieldname !== <span class="string">'cover_img'</span>) <span class="keyword">return</span> res.cc(<span class="string">'文章封面是必选参数！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO：表单数据合法，继续后面的处理流程...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="实现发布文章的功能"><a href="#实现发布文章的功能" class="headerlink" title="实现发布文章的功能"></a>实现发布文章的功能</h4><p>整理要插入数据库的文章信息对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的 path 核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> articleInfo = &#123;</span><br><span class="line">  <span class="comment">// 标题、内容、状态、所属的分类Id</span></span><br><span class="line">  ...req.body,</span><br><span class="line">  <span class="comment">// 文章封面在服务器端的存放路径</span></span><br><span class="line">  cover_img: path.join(<span class="string">'/uploads'</span>, req.file.filename),</span><br><span class="line">  <span class="comment">// 文章发布时间</span></span><br><span class="line">  pub_date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  <span class="comment">// 文章作者的Id</span></span><br><span class="line">  author_id: req.user.id,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义发布文章的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`insert into ev_articles set ?`</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>db.query()</code> 执行发布文章的 SQL 语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入数据库操作模块</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../db/index'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句</span></span><br><span class="line">db.query(sql, articleInfo, (err, results) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行 SQL 语句失败</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> res.cc(err)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 SQL 语句成功，但是影响行数不等于 1</span></span><br><span class="line">  <span class="keyword">if</span> (results.affectedRows !== <span class="number">1</span>) <span class="keyword">return</span> res.cc(<span class="string">'发布文章失败！'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布文章成功</span></span><br><span class="line">  res.cc(<span class="string">'发布文章成功'</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 <code>app.js</code> 中，使用 <code>express.static()</code> 中间件，将 <code>uploads</code> 目录中的图片托管为静态资源：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 托管静态资源文件</span></span><br><span class="line">app.use(<span class="string">'/uploads'</span>, express.static(<span class="string">'./uploads'</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>react复习笔记</title>
    <url>/2022/09/06/react%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="React复习手册"><a href="#React复习手册" class="headerlink" title="React复习手册"></a>React复习手册</h1><p>前言：本文取自社区大佬的文章，从头至尾整理一下React知识点，当做再复习一遍啦，冲冲冲！！！</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>React是一个用于构建用户界面的JavaScript库。主要用来写HTML页面或构建Web应用。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>声明式：只需要去描述UI看起来是什么样子，就和写HTML一样；</li>
<li>基于组件：组件是React中最重要的内容，组件表示页面中部分内容，通过组合、服用多个组件来完成这页面。</li>
<li><p>学习一次，随处使用：可以开发Web应用，移动端原生应用（react-navive）、虚拟现实应用等。 React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物</p>
</li>
<li><p>高效 (优秀的Diffing算法)</p>
</li>
</ul><a id="more"></a>


<h3 id="react-高效的原因"><a href="#react-高效的原因" class="headerlink" title="react 高效的原因"></a>react 高效的原因</h3><ol>
<li>使用虚拟 DOM，不总是直接操作页面真实 DOM</li>
<li>DOM Diffing 算法，最小化页面重绘</li>
<li>React并不会提高渲染速度，反而可能会增加渲染时间，真正高效的原因是他能有效减少渲染次数</li>
</ol>
<h3 id="创建虚拟DOM的两种方式"><a href="#创建虚拟DOM的两种方式" class="headerlink" title="创建虚拟DOM的两种方式"></a>创建虚拟DOM的两种方式</h3><ol>
<li><p>js 创建虚拟DOM(不推荐)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建虚拟DOM 创建嵌套格式的doms</span><br><span class="line">const VDOM=React.createElement(&apos;h1&apos;,&#123;id:&apos;title&apos;&#125;,React.createElement(&apos;span&apos;,&#123;&#125;,&apos;hello React&apos;))</span><br><span class="line">//渲染虚拟DOM到页面</span><br><span class="line">ReactDOM.render(VDOM,document.getElementById(&apos;test&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​    2.jsx创建虚拟DOM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建虚拟DOM</span><br><span class="line">const VDOM = (</span><br><span class="line">	&lt;h1 id=&quot;title&quot;&gt;</span><br><span class="line">		&lt;span&gt;Hello,React&lt;/span&gt;</span><br><span class="line">	&lt;/h1&gt;</span><br><span class="line">)</span><br><span class="line">//渲染虚拟DOM到页面</span><br><span class="line">ReactDOM.render(VDOM,document.getElementById(&apos;test&apos;))</span><br><span class="line">//打印真实DOM与虚拟DOM，这一步不是jsx创建虚拟DOM必须</span><br><span class="line">const TDOM = document.getElementById(&apos;demo&apos;)</span><br><span class="line">console.log(&apos;虚拟DOM&apos;,VDOM);</span><br><span class="line">console.log(&apos;真实DOM&apos;,TDOM);</span><br></pre></td></tr></table></figure>
<p>可以看到，两种方式，明显jsx的写法更符合我们的习惯，当出现多重嵌套时，js创建方法会使我们编程出现很大麻烦</p>
<p>但是jsx其实也只是帮我们做了一层编译，写完jsx代码后，最终我们的代码也会被编译成js的书写方式</p>
<h3 id="关于虚拟DOM"><a href="#关于虚拟DOM" class="headerlink" title="关于虚拟DOM"></a>关于虚拟DOM</h3><ul>
<li>本质是Object类型的对象（一般对象）</li>
<li>虚拟DOM比较’轻’，真实DOM比较重，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性（只有React需要的属性）</li>
<li>虚拟DOM最终会被React转化为真实DOM，呈现在页面上</li>
</ul>
<h2 id="三个API"><a href="#三个API" class="headerlink" title="三个API"></a>三个API</h2><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><p>用于创建React元素，React元素无法修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const button =React.createElement(&apos;button&apos;,&#123;</span><br><span class="line">id:&apos;btn&apos;,</span><br><span class="line">type:&apos;button&apos;,</span><br><span class="line">className:&apos;hello&apos;,</span><br><span class="line">onClick:()=&gt;&#123;alert(&apos;Clicked&apos;)&#125;</span><br><span class="line">&#125;,&apos;Click Me&apos;);</span><br><span class="line">const div=React.createElement(&apos;div&apos;,null,&apos;Content&apos;,button)</span><br></pre></td></tr></table></figure>
<ul>
<li>html标签必须小写</li>
<li>标签中的属性属性名：属性值</li>
<li>类的属性建议使用className，和js中的class关键字作区分</li>
<li>在设置事件属性时，属性名需修改为小驼峰命名法，属性值为函数</li>
<li>元素内容可以是文本内容，也可以加上子标签</li>
<li>React创建的元素一旦创建不可修改</li>
</ul>
<h3 id="ReactDOM-createRoot"><a href="#ReactDOM-createRoot" class="headerlink" title="ReactDOM.createRoot"></a>ReactDOM.createRoot</h3><p>创建React的根容器，用于放置React元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const root = ReactDOM.createRoot(document.querySelector(&apos;#root&apos;))</span><br></pre></td></tr></table></figure>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root.render(div)</span><br></pre></td></tr></table></figure>
<p>当首次调用时，容器节点里的所有DOM元素都会替换，后续的调用则会使用React 的DOM差分算法（DOM diffing algorithm）进行高效的更新。</p>
<p>不会修改容器节点（只会修改容器的子节点)。可以在不覆盖现有子节点的情况下，将组建插入已有的DOM节点中。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX是一种JavaScript的语法扩展、是一种嵌入式的类似XML的语法,常应用于React架构中,但也不仅限于此.应该说JSX因React框架而流行,但也存在其他的实现.只要你够厉害,甚至能在单片机上实现(当然你要自己写出它的实现方式)</p>
<p>JSX是JavaScript XML的简写，是js的语法扩展，JSX使得我们可以以类似于html的形式去使用js。JSX便是React中声明式编程的体现方式。声明式编程，简单理解就是以结果为导向的编程。使用JSX将我们所期望的网页结构编写出来，然后React再根据JSX自动生成js代码。所以我们所编写的JSx代码，最终都会转为以调用 React.cteateElement()创建元素的代码。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>引用babel</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;./assets/js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置js代码被babel处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用JSX语法创建React元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const button = &lt;button id=&quot;btn&quot;&gt;Click Me&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建根元素并渲染</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const root = ReactDOM.createRoot(document.querySelector(&apos;#root&apos;))</span><br><span class="line">root.render(button)</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h3><ol>
<li><p>JSX 不是字符串，外面不要加引号</p>
</li>
<li><p>JSX 中 html 标签应该小写开头，React 组件大写开头</p>
</li>
<li><p>有且只有一个跟标签</p>
</li>
<li><p>JSX 的标签必须正确结束（自结束标签必须写 / ）</p>
</li>
<li><p>如果元素没有子节点，React 元素可以通过 / （自闭合标签）结束，如<span></span></p>
</li>
<li><p>可以使用 {} 嵌入表达式（有值的语句），表达式中的数组会自动遍历</p>
</li>
<li><p>如果表达式中的值是 null，boolean，undefined 将不显示</p>
</li>
<li><p>内联样式,要用style={ {key:value} }的形式(双{  }代表对象,单{    }代表表达式)去写</p>
</li>
<li><p>属性可直接在标签中设置，属性名采用的是驼峰命名法</p>
</li>
<li><p>特殊属性名 class -&gt; className</p>
</li>
<li><p>style 必须使用对象的方式，命名使用小驼峰命名法 style={   {backgroundColor:’blue’}   }</p>
</li>
<li><p>推荐使用小括号包裹 JSX，避免 JS 中的自动插入分号陷阱</p>
</li>
<li><p>若小写字母开头,则将该标签转为html中同名元素,若html中无该标签对应的同名元素,则<code>报错</code></p>
<p>若大写字母开头,ract就去渲染对应组件,若组件没有定义,则报错</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const title=(</span><br><span class="line">	&lt;h1&gt;hello JSX</span><br><span class="line">		&lt;span /&gt;</span><br><span class="line">	&lt;/h1&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="JSX-中使用-js-表达式"><a href="#JSX-中使用-js-表达式" class="headerlink" title="JSX 中使用 js 表达式"></a>JSX 中使用 js 表达式</h3><p>嵌入js表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const name=&apos;wayne&apos;</span><br><span class="line">const title=(</span><br><span class="line">	&lt;h1&gt;Hello JSX &#123;name&#125;&lt;/h1&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用单花括号 {} 包裹 js 表达式进行使用</li>
<li>单花括号中可以使用任意的 js 表达式</li>
<li>JSX 自身也是一个 js 表达式，所以也可以把 JSX 写入花括号中</li>
<li>js 中的对象是一个例外，一般只会出现在 style 属性中</li>
<li>不能在花括号中出现语句（if / for 等）</li>
</ul>
<h3 id="JSX-的条件渲染"><a href="#JSX-的条件渲染" class="headerlink" title="JSX 的条件渲染"></a>JSX 的条件渲染</h3><p>根据条件渲染特定的 JSX 结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isLoading = true;</span><br><span class="line">const loadData=()=&gt;&#123;</span><br><span class="line">	if(isLoading)&#123;</span><br><span class="line">		return&lt;div&gt;loading...&lt;/div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	return &lt;div&gt;loaded&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSX的列表渲染"><a href="#JSX的列表渲染" class="headerlink" title="JSX的列表渲染"></a>JSX的列表渲染</h3><p>可以使用 if / else 或三元表达式或逻辑与运算符来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list = &lt;ul&gt;</span><br><span class="line">				&#123;arr.map(item=&gt;&lt;li&gt;&#123;item&#125;&lt;/li&gt;)&#125;</span><br><span class="line">			&lt;ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JSX的样式处理"><a href="#JSX的样式处理" class="headerlink" title="JSX的样式处理"></a>JSX的样式处理</h3><p>行内样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const title=(&lt;h1 style=&#123;&#123;color:&apos;blue&apos;,backgroundColor:&apos;yellow&apos;&#125;&#125;&gt;文本内容&lt;/h1&gt;)</span><br></pre></td></tr></table></figure>
<p>类名 className</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const title = (&lt;h1 className=&quot;title&quot;&gt;文本&lt;/h1&gt;)</span><br></pre></td></tr></table></figure>
<p>引入 css 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;./css/style.css&apos;</span><br></pre></td></tr></table></figure>
<h2 id="react组件"><a href="#react组件" class="headerlink" title="react组件"></a>react组件</h2><h3 id="函数式声明组件"><a href="#函数式声明组件" class="headerlink" title="函数式声明组件"></a>函数式声明组件</h3><p>执行了ReactDOM.render(<mycomponent>…….之后，发生了什么？</mycomponent></p>
<p>1.React解析组件标签，找到了MyComponent组件。</p>
<p>2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</p>
<h3 id="类式组件-下面的实例都是指类组件"><a href="#类式组件-下面的实例都是指类组件" class="headerlink" title="类式组件(下面的实例都是指类组件)"></a>类式组件(下面的实例都是指类组件)</h3><p>执行了ReactDOM.render(<mycomponent>…….之后，发生了什么？</mycomponent></p>
<p>​    1.React解析组件标签，找到了MyComponent组件。</p>
<p>​    2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</p>
<p>​    3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</p>
<p>组件中的render是放在哪里的？</p>
<p>​    MyComponent的原型对象上，供实例使用。</p>
<p>组件中的render中的this是谁？</p>
<p>​    MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</p>
<h3 id="模块与模块化"><a href="#模块与模块化" class="headerlink" title="模块与模块化"></a>模块与模块化</h3><p>① 模块</p>
<blockquote>
<ol>
<li>理解:向外提供特定功能的js程序,一般就是一个js文件</li>
<li>为什么要拆成模块:随着业务逻辑增加,代码越来越多且复杂</li>
<li>作用:复用js,简化js的编写,提高js运行效率</li>
</ol>
</blockquote>
<p>② 模块化</p>
<blockquote>
<p>当应用的js都以模块来编写,这个应用就是一个模块化的应用</p>
</blockquote>
<h3 id="组件与组件化"><a href="#组件与组件化" class="headerlink" title="组件与组件化"></a>组件与组件化</h3><p>① 组件</p>
<blockquote>
<ol>
<li><p>理解:用来实现局部功能效果的代码和资源的集合(html/css/js/img等等)</p>
</li>
<li><p>为什么要用组件:一个界面的功能复杂</p>
</li>
<li>作用:复用编码,简化项目编码,提高运行效率</li>
</ol>
</blockquote>
<p>② 组件化</p>
<blockquote>
<p>当应用是以多组件的方式实现,这个应用就是组件化的应用</p>
</blockquote>
<h2 id="React面向组件编程"><a href="#React面向组件编程" class="headerlink" title="React面向组件编程"></a>React面向组件编程</h2><ol>
<li><p>使用React开发者工具调试</p>
<p><code>React Developer Tools</code></p>
</li>
<li><p>注意</p>
<p>a) 组件名必须是首字母大写</p>
<p>b) 虚拟DOM元素只能有一个根元素</p>
<p>c) 虚拟DOM元素必须有结束标签 &lt; /&gt;</p>
</li>
<li><p>渲染类组件标签的基本流程</p>
<p>a) React内部会创建组件实例对象</p>
<p>b) 调用render()得到虚拟DOM,并解析为真实DOM</p>
<p>c) 插入到指定的页面元素内部</p>
</li>
</ol>
<h3 id="组件三大属性-state"><a href="#组件三大属性-state" class="headerlink" title="组件三大属性 state"></a>组件三大属性 state</h3><p> ①理解</p>
<blockquote>
<ol>
<li>state是组件对象最重要的属性,值是对象(可以包含多个key:value的组合)</li>
<li>组件被称为<code>状态机</code>,通过更新组件的state来更新对应的页面显示(重新渲染组件)</li>
</ol>
</blockquote>
<p>② 强烈注意</p>
<blockquote>
<ol>
<li><p>组件中的render方法中的this为组件实例对象</p>
</li>
<li><p>组件自定义方法中this为undefined,如何解决?</p>
</li>
</ol>
<p>a) 强制绑定this:通过函数对象的bind()</p>
<p>b) 箭头函数<code>推荐</code></p>
<ol start="3">
<li>状态数据,不能直接修改或者更新</li>
</ol>
</blockquote>
<p>代码示例 </p>
<p>正常的用函数对象的bind()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.创建组件</span><br><span class="line">		class Weather extends React.Component&#123;</span><br><span class="line">			//构造器调用几次？ ———— 1次</span><br><span class="line">			constructor(props)&#123;</span><br><span class="line">				console.log(&apos;constructor&apos;);</span><br><span class="line">				super(props)</span><br><span class="line">				//初始化状态</span><br><span class="line">				this.state = &#123;isHot:false,wind:&apos;微风&apos;&#125;</span><br><span class="line">				//解决changeWeather中this指向问题,也可以在调用出直接使用</span><br><span class="line">				this.changeWeather = this.changeWeather.bind(this)</span><br><span class="line">			&#125;</span><br><span class="line">			//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数</span><br><span class="line">			render()&#123;</span><br><span class="line">				console.log(&apos;render&apos;);</span><br><span class="line">				//读取状态</span><br><span class="line">				const &#123;isHot,wind&#125; = this.state</span><br><span class="line">				return &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &apos;炎热&apos; : &apos;凉爽&apos;&#125;，&#123;wind&#125;&lt;/h1&gt;</span><br><span class="line">			&#125;</span><br><span class="line">			//changeWeather调用几次？ ———— 点几次调几次</span><br><span class="line">			changeWeather()&#123;</span><br><span class="line">				//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用</span><br><span class="line">				//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span><br><span class="line">				//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined</span><br><span class="line">				console.log(&apos;changeWeather&apos;);</span><br><span class="line">				//获取原来的isHot值</span><br><span class="line">				const isHot = this.state.isHot</span><br><span class="line">				//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。</span><br><span class="line">				this.setState(&#123;isHot:!isHot&#125;)</span><br><span class="line">				console.log(this);</span><br><span class="line"></span><br><span class="line">				//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！</span><br><span class="line">				//this.state.isHot = !isHot //这是错误的写法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//2.渲染组件到页面</span><br><span class="line">		ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&apos;test&apos;))</span><br></pre></td></tr></table></figure>
<p>简写方式:赋值语句的形式+箭头函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="comment">//初始化状态</span></span><br><span class="line">	state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">'微风'</span>&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="keyword">this</span>.state</span><br><span class="line">		<span class="keyword">return</span> &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? '炎热' : '凉爽'&#125;，&#123;wind&#125;&lt;/h1&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//自定义方法————要用赋值语句的形式+箭头函数</span></span><br><span class="line">	changeWeather = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> isHot = <span class="keyword">this</span>.state.isHot</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染组件到页面</span></span><br><span class="line">ReactDOM.render(&lt;Weather/&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="组件三大属性-props"><a href="#组件三大属性-props" class="headerlink" title="组件三大属性 props"></a>组件三大属性 props</h3><p>①理解</p>
<blockquote>
<ol>
<li>每个组件对象都会有props(properties的简写)属性</li>
<li>组件标签的所有属性都保存在props中</li>
</ol>
</blockquote>
<p>② 作用</p>
<blockquote>
<ol>
<li>通过标签属性从组件外向组件内传递变化的数据</li>
<li>注意:组件内部不要修改props数据</li>
</ol>
</blockquote>
<p>代码示例:</p>
<p>类组件使用props</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建组件</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">			render()&#123;</span><br><span class="line">				<span class="comment">// console.log(this);</span></span><br><span class="line">				<span class="keyword">const</span> &#123;name,age,sex&#125; = <span class="keyword">this</span>.props</span><br><span class="line">				<span class="keyword">return</span> (</span><br><span class="line">					&lt;ul&gt;</span><br><span class="line">						&lt;li&gt;姓名：&#123;name&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">						&lt;li&gt;性别：&#123;sex&#125;&lt;/</span>li&gt;</span><br><span class="line">						&lt;li&gt;年龄：&#123;age+<span class="number">1</span>&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;/u</span>l&gt;</span><br><span class="line">				)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//渲染组件到页面</span></span><br><span class="line">		ReactDOM.render(&lt;Person name="jerry" age=&#123;19&#125;  sex="男"/&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'test1'</span>))</span><br><span class="line">		ReactDOM.render(&lt;Person name="tom" age=&#123;18&#125; sex="女"/&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'test2'</span>))</span><br><span class="line">		<span class="keyword">const</span> p = &#123;<span class="attr">name</span>:<span class="string">'老刘'</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">'女'</span>&#125;</span><br><span class="line">		<span class="comment">// console.log('@',...p);</span></span><br><span class="line">		<span class="comment">// ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125; sex=&#123;p.sex&#125;/&gt;,document.getElementById('test3'))</span></span><br><span class="line">        <span class="comment">//此处使用赋值解构方式,使得代码更简洁</span></span><br><span class="line">		ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'test3'</span>))</span><br></pre></td></tr></table></figure>
<p>函数组件使用props</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建组件</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">props</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">const</span> &#123;name,age,sex&#125; = props</span><br><span class="line">			<span class="keyword">return</span> (</span><br><span class="line">					&lt;ul&gt;</span><br><span class="line">						&lt;li&gt;姓名：&#123;name&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">						&lt;li&gt;性别：&#123;sex&#125;&lt;/</span>li&gt;</span><br><span class="line">						&lt;li&gt;年龄：&#123;age&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">					&lt;/u</span>l&gt;</span><br><span class="line">				)</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//此处限制可以换成typrScript</span></span><br><span class="line">		Person.propTypes = &#123;</span><br><span class="line">			name:PropTypes.string.isRequired, <span class="comment">//限制name必传，且为字符串</span></span><br><span class="line">			sex:PropTypes.string,<span class="comment">//限制sex为字符串</span></span><br><span class="line">			age:PropTypes.number,<span class="comment">//限制age为数值</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//指定默认标签属性值</span></span><br><span class="line">		Person.defaultProps = &#123;</span><br><span class="line">			sex:<span class="string">'男'</span>,<span class="comment">//sex默认值为男</span></span><br><span class="line">			age:<span class="number">18</span> <span class="comment">//age默认值为18</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//渲染组件到页面</span></span><br><span class="line">		ReactDOM.render(&lt;Person name="jerry"/&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'test1'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="组件三大属性-refs"><a href="#组件三大属性-refs" class="headerlink" title="组件三大属性 refs"></a>组件三大属性 refs</h3><p>①理解</p>
<blockquote>
<p>组件内的标签可以定义ref来标识自己</p>
</blockquote>
<p>代码示例:</p>
<p>字符串形式的ref(<code>不推荐,将被淘汰</code>)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//展示左侧输入框的数据</span></span><br><span class="line">	showData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;input1&#125; = <span class="keyword">this</span>.refs</span><br><span class="line">		alert(input1.value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示右侧输入框的数据</span></span><br><span class="line">	showData2 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;input2&#125; = <span class="keyword">this</span>.refs</span><br><span class="line">		alert(input2.value)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input ref=<span class="string">"input1"</span> type=<span class="string">"text"</span> placeholder=<span class="string">"点击按钮提示数据"</span>/&gt;&amp;nbsp;</span><br><span class="line">				&lt;button onClick=&#123;<span class="keyword">this</span>.showData&#125;&gt;点我提示左侧的数据&lt;<span class="regexp">/button&gt;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">				&lt;input ref="input2" onBlur=&#123;this.showData2&#125; type="text" placeholder="失去焦点提示数据"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		)</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>回调形式的ref</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**下面的this指的是组件实例,我直接this.input1 = c 意思是给实例上的input1赋值,之后直接通过调用打印得到*/</span></span><br><span class="line"><span class="comment">//展示左侧输入框的数据</span></span><br><span class="line">	showData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;input1&#125; = <span class="keyword">this</span></span><br><span class="line">		alert(input1.value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示右侧输入框的数据</span></span><br><span class="line">	showData2 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;input2&#125; = <span class="keyword">this</span></span><br><span class="line">		alert(input2.value)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input ref=&#123;c =&gt; <span class="keyword">this</span>.input1 = c &#125; type=<span class="string">"text"</span> placeholder=<span class="string">"点击按钮提示数据"</span>/&gt;&amp;nbsp;</span><br><span class="line">				&lt;button onClick=&#123;<span class="keyword">this</span>.showData&#125;&gt;点我提示左侧的数据&lt;<span class="regexp">/button&gt;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">				&lt;input onBlur=&#123;this.showData2&#125; ref=&#123;c =&gt; this.input2 = c &#125; type="text" placeholder="失去焦点提示数据"/</span>&gt;&amp;nbsp;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		)</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>createRef创建ref容器<code>最推荐的</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的*/</span></span><br><span class="line">myRef = React.createRef()</span><br><span class="line">myRef2 = React.createRef()</span><br><span class="line"><span class="comment">//展示左侧输入框的数据</span></span><br><span class="line">showData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.myRef.current.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示右侧输入框的数据</span></span><br><span class="line">showData2 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.myRef2.current.value);</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">	<span class="keyword">return</span>(</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;input ref=&#123;<span class="keyword">this</span>.myRef&#125; type=<span class="string">"text"</span> placeholder=<span class="string">"点击按钮提示数据"</span>/&gt;&amp;nbsp;</span><br><span class="line">			&lt;button onClick=&#123;<span class="keyword">this</span>.showData&#125;&gt;点我提示左侧的数据&lt;<span class="regexp">/button&gt;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">			&lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type="text" placeholder="失去焦点提示数据"/</span>&gt;&amp;nbsp;</span><br><span class="line">		&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="事件处理与收集表单数据"><a href="#事件处理与收集表单数据" class="headerlink" title="事件处理与收集表单数据"></a>事件处理与收集表单数据</h3><p><strong>事件处理</strong></p>
<blockquote>
<ol>
<li>通过onXxx属性指定事件处理函数(注意大小写)</li>
</ol>
<p>a)React使用的是自定义(合成事件,而不是使用的原生DOM事件) —-为了更好的兼容性</p>
<p>b)React中的事件是通过事件委托的方式处理的(委托给组件最外层的元素)—-为了更高效</p>
<ol start="2">
<li>通过event.target得到发生事件的DOM元素对象 —–不要过度使用ref</li>
</ol>
</blockquote>
<p><strong>Ⅱ-表单组件的分类</strong></p>
<blockquote>
<p>就形式上来说，<strong><code>受控组件</code>就是为某个form表单组件添加<code>value</code>属性；<code>非受控组件</code>就是没有添加<code>value</code>属性的组件</strong></p>
</blockquote>
<p>1、受控组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">state = &#123;<span class="comment">//初始化状态</span></span><br><span class="line">	username:<span class="string">''</span>, <span class="comment">//用户名</span></span><br><span class="line">	password:<span class="string">''</span> <span class="comment">//密码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存用户名到状态中</span></span><br><span class="line">saveUsername = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.setState(&#123;<span class="attr">username</span>:event.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存密码到状态中</span></span><br><span class="line">savePassword = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.setState(&#123;<span class="attr">password</span>:event.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表单提交的回调</span></span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">	event.preventDefault() <span class="comment">//阻止表单提交</span></span><br><span class="line">	<span class="keyword">const</span> &#123;username,password&#125; = <span class="keyword">this</span>.state</span><br><span class="line">	alert(<span class="string">`你输入的用户名是：<span class="subst">$&#123;username&#125;</span>,你输入的密码是：<span class="subst">$&#123;password&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">	<span class="keyword">return</span>(</span><br><span class="line">		&lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">			用户名：&lt;input onChange=&#123;<span class="keyword">this</span>.saveUsername&#125; type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;</span><br><span class="line">			密码：&lt;input onChange=&#123;<span class="keyword">this</span>.savePassword&#125; type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;</span><br><span class="line">			&lt;button&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>form&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、非受控组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">		event.preventDefault() <span class="comment">//阻止表单提交</span></span><br><span class="line">		<span class="keyword">const</span> &#123;username,password&#125; = <span class="keyword">this</span></span><br><span class="line">		alert(<span class="string">`你输入的用户名是：<span class="subst">$&#123;username.value&#125;</span>,你输入的密码是：<span class="subst">$&#123;password.value&#125;</span>`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			&lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">				用户名：&lt;input ref=&#123;c =&gt; <span class="keyword">this</span>.username = c&#125; type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;</span><br><span class="line">				密码：&lt;input ref=&#123;c =&gt; <span class="keyword">this</span>.password = c&#125; type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;</span><br><span class="line">				&lt;button&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>form&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数与函数柯里化"><a href="#高阶函数与函数柯里化" class="headerlink" title="高阶函数与函数柯里化"></a>高阶函数与函数柯里化</h3><p><strong>高阶函数:</strong></p>
<blockquote>
<p>如果一个函数符合下面两个规范中的任何一个,那该函数就是高阶函数</p>
<ol>
<li>若A函数,接受的参数是一个函数,那么A就可以称之为高阶函数</li>
<li>若A函数,调用的返回值依然是一个函数,那么A就可以称之为高阶函数</li>
</ol>
<p>常见的高阶函数有:Promise、setTimeout、arr.map()等等 </p>
</blockquote>
<p> <strong>函数的柯里化</strong></p>
<blockquote>
<p>通过函数调用继续返回函数的方式,实现对此接受参数最后统一处理的函数编码形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123; <span class="keyword">return</span> <span class="function">(<span class="params">b</span>)=&gt;</span>&#123;<span class="keyword">return</span> <span class="function"><span class="params">c</span>=&gt;</span>&#123; <span class="keyword">return</span> a+b+c&#125; &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>不用函数柯里化实现事件的绑定</strong></p>
<blockquote>
<p>直接使用回调函数,因为他本身就是以一个函数为返回值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;&lt;input onChange=&#123;event =&gt; this.saveFormData('username',event) &#125; type="text" name="username"/&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote>
<ol>
<li>组件从创建到死亡它会经历一些特定的阶段</li>
<li>React组件中包含一系列钩子函数(生命周期回调函数),会在特定的时刻调用</li>
<li>我们在定义组件时,会在特定的生命周期回调函数中,做特定的工作</li>
</ol>
</blockquote>
<h3 id="旧生命周期-react16前"><a href="#旧生命周期-react16前" class="headerlink" title="旧生命周期 react16前"></a><strong>旧生命周期 react16前</strong></h3><p>各生命周期钩子调用顺序</p>
<ol>
<li><p>初始化阶段：ReactDOM.render()触发—————————初次渲染</p>
<p>​                        constructor()</p>
<p>​                        compinentWillMount()</p>
<p>​                        render()</p>
<p>​                        componentDidMount =&gt;常用 组件将要渲染   一般在这个钩子中做一些初始化的事情，如开启定时器、发送网络请求、订阅消息等</p>
</li>
</ol>
<p>2.更新阶段：由组件内部的this.setState()或者父组件render触发</p>
<p>​                               shouldComponentUpdate()组件应该更新</p>
<p>​                                componentWillUpdate()组件将要更新</p>
<p>​                                render()</p>
<p>​                                componentDidUpdate()组件更新</p>
<p>3.卸载阶段</p>
<p>​                                由ReactDOM.unmountComponentAtNode（卸载节点上的组件）触发</p>
<p>​                                componentWillUnmount()常用 组件将要卸载 一般在这个钩子中做一些收尾的事情 关闭定时器、取消订阅等。</p>
<h3 id="生命周期新"><a href="#生命周期新" class="headerlink" title="生命周期新"></a><strong>生命周期新</strong></h3><p>1、初始化阶段 ：ReactDOM.render()触发—————————初次渲染</p>
<p>​                                constructor()</p>
<p>​                                getDerivedStateFromProps() 从props获得派生状态</p>
<p>​                                render()</p>
<p>​                                componentDidMount()    常用</p>
<p>2、更新阶段   由组件内部的this.setState()或者父组件的render触发</p>
<p>​                                getDerivedStateFromProps()  从Props获得派生状态</p>
<p>​                                shouldComponentUpdate() 组件应该更新</p>
<p>​                                render()</p>
<p>​                                getSnapshotBeforeUpdate() 在更新前获得快照</p>
<p>​                                componentDidUpdate()</p>
<p>3、卸载组件:由ReactDOM.unmountComponentAtNode()触发</p>
<p>​                                componentWillUnmount() ===&gt;<code>常用</code> 一般在这个钩子中做一些收尾的事情,如:关闭定时器、取消订阅消息</p>
<h3 id="重要的钩子"><a href="#重要的钩子" class="headerlink" title="重要的钩子"></a>重要的钩子</h3><blockquote>
<ol>
<li>render:初始化渲染或者更新渲染调用</li>
<li>componentDidMount() :开启监听,发送ajax请求</li>
<li>componentWillUnmount(): 做一些收尾工作,如:清理定时器</li>
</ol>
</blockquote>
<h3 id="即将废弃的钩子"><a href="#即将废弃的钩子" class="headerlink" title="即将废弃的钩子"></a>即将废弃的钩子</h3><blockquote>
<ol>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ol>
<p><code>ps</code>:现在使用会出现警告,之后版本可能需要加上UNSAFE_前缀才能使用,以后可能会被彻底废弃,不建议使用</p>
<p>推测React团队认为提高使用成本将会间接影响我们,让我们去适应新的钩子,所以加上这个</p>
</blockquote>
<h2 id="react中的key"><a href="#react中的key" class="headerlink" title="react中的key"></a>react中的key</h2><blockquote>
<p>经典面试题:</p>
<p>1). react/vue中的key有什么作用？（key的内部原理是什么？）</p>
<p>2). 为什么遍历列表时，key最好不要用index?</p>
</blockquote>
<p> <strong>虚拟DOM中key的作用</strong></p>
<blockquote>
<ol>
<li><p>简单的说:key是虚拟DOM对象的标识,在更新显示时key起着极其重要的作用</p>
</li>
<li><p>详细的说:当状态当中的数据发生变化时,react会根据<code>新数据</code>生成<code>新的虚拟DOM</code>,随后React进行<code>新虚拟DOM</code>与<code>旧虚拟DOM</code>的diff比较,比较规则如下:</p>
<ol start="3">
<li>旧虚拟DOM中找到了与新虚拟DOM相同的key：</li>
</ol>
<p>a)若虚拟DOM中内容没变,直接使用之前的真实DOM</p>
<p>b)若虚拟DON中的内容变了,则生成新的真实DOM,随后替换掉页面中之前的真实DOM</p>
<ol start="4">
<li>旧虚拟DOM中未找到与新虚拟DOM相同的key</li>
</ol>
<p>根据数据创建新的真实DOM,随后渲染到页面</p>
</li>
</ol>
</blockquote>
<p><strong>用index作为key可能会引发的问题</strong></p>
<blockquote>
<ol>
<li>若对数据进行:逆序添加,逆序删除等破坏顺序操作:</li>
</ol>
<p>会产生没有必要的真实DOM更新 ==&gt;界面效果没问题,但是效率低</p>
<ol start="2">
<li>如果结构中还包含输入类的DOM:</li>
</ol>
<p>会产生错误DOM更新 ===&gt;界面有问题</p>
<ol start="3">
<li>注意:</li>
</ol>
<p>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作,仅用于渲染列表用于展示,使用index作为key是没有问题的</p>
</blockquote>
<p><strong>开发中如何选择key?</strong></p>
<blockquote>
<ol>
<li>最好使用每条数据的唯一标识作为key,比如id,手机号,身份证号,学号等</li>
<li>如果确定只是简单的展示诗句,用index也是可以的</li>
</ol>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//慢动作回放----使用index索引值作为key</span></span><br><span class="line">		初始数据：</span><br><span class="line">				&#123;id:1,name:'小张',age:18&#125;,</span><br><span class="line">				&#123;id:2,name:'小李',age:19&#125;,</span><br><span class="line">		初始的虚拟DOM：</span><br><span class="line">				&lt;li key=0&gt;小张---18&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li key=1&gt;小李---19&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">		更新后的数据：</span><br><span class="line">				&#123;id:3,name:'小王',age:20&#125;,</span><br><span class="line">				&#123;id:1,name:'小张',age:18&#125;,</span><br><span class="line">				&#123;id:2,name:'小李',age:19&#125;,</span><br><span class="line">		更新数据后的虚拟DOM：</span><br><span class="line">				&lt;li key=0&gt;小王---20&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li key=1&gt;小张---18&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li key=2&gt;小李---19&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">//慢动作回放----使用id唯一标识作为key</span></span><br><span class="line"></span><br><span class="line">		初始数据：</span><br><span class="line">				&#123;id:1,name:'小张',age:18&#125;,</span><br><span class="line">				&#123;id:2,name:'小李',age:19&#125;,</span><br><span class="line">		初始的虚拟DOM：</span><br><span class="line">				&lt;li key=1&gt;小张---18&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li key=2&gt;小李---19&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">		更新后的数据：</span><br><span class="line">				&#123;id:3,name:'小王',age:20&#125;,</span><br><span class="line">				&#123;id:1,name:'小张',age:18&#125;,</span><br><span class="line">				&#123;id:2,name:'小李',age:19&#125;,</span><br><span class="line">		更新数据后的虚拟DOM：</span><br><span class="line">				&lt;li key=3&gt;小王---20&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li key=1&gt;小张---18&lt;input type="text"/&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li key=2&gt;小李---19&lt;input type="text"/&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<h2 id="React脚手架"><a href="#React脚手架" class="headerlink" title="React脚手架"></a>React脚手架</h2><blockquote>
<ol>
<li><p>xxx脚手架:用来帮助程序原快速创建一个基于xxx库的模板项目</p>
<p>   a) 包含了所有需要的配置(语法检查,jsx编 译,devServer…)</p>
<pre><code>b)下载好了所有相关的依赖
</code></pre></li>
</ol>
<p>​      c) 可以直接运行一个简单效果</p>
<ol start="2">
<li><p>react提供了一个用于创建react项目的脚手架库:create-react-app</p>
</li>
<li><p>项目的整体技术架构为:react+webpack+es6+eslint</p>
</li>
<li><p>使用脚手架开发的项目的特点:模块化,组件化,工程化</p>
</li>
</ol>
</blockquote>
<p><strong>创建项目并启动</strong></p>
<blockquote>
<ol>
<li><p>全局安装:<code>npm i -g create-react-app</code></p>
</li>
<li><p>切换到想创建项目的目录,使用命令:<code>create-react-arr hello-react</code></p>
</li>
<li>进入项目文件夹</li>
<li>启动项目:<code>npm start</code></li>
</ol>
</blockquote>
<p><strong>react脚手架项目结构</strong></p>
<blockquote>
<p>public —- 静态资源文件夹</p>
<p>​            favicon.icon —— 网站页签图标</p>
<p>​            <strong>index.html ——–</strong> <strong>主页面</strong></p>
<p>​            logo192.png ——- logo图</p>
<p>​            logo512.png ——- logo图</p>
<p>​            manifest.json —– 应用加壳的配置文件</p>
<p>​            robots.txt ——– 爬虫协议文件</p>
<p>src —- 源码文件夹</p>
<p>​            App.css ——– App组件的样式</p>
<p>​            <strong>App.js ——— App**</strong>组件**</p>
<p>​            App.test.js —- 用于给App做测试</p>
<p>​            index.css —— 样式</p>
<p>​            <strong>index.js ——-</strong> <strong>入口文件</strong></p>
<p>​            logo.svg ——- logo图</p>
<p>​            reportWebVitals.js</p>
<p>​                    — 页面性能分析文件(需要web-vitals库的支持)</p>
<p>​            setupTests.js</p>
<p>​                    —- 组件单元测试的文件(需要jest-dom库的支持)</p>
</blockquote>
<p><strong>功能界面的组件化编码流程</strong></p>
<blockquote>
<ol>
<li><p>拆分组件: 拆分界面,抽取组件</p>
</li>
<li><p>实现静态组件: 使用组件实现静态页面效果</p>
</li>
<li><p>实现动态组件</p>
</li>
</ol>
<p>​    3.1 动态显示初始化数据</p>
<p>​        3.1.1 数据类型</p>
<p>​        3.1.2 数据名称</p>
<p>​        3.1.2 保存在哪个组件?</p>
<p>​    3.2 交互(从绑定事件监听开始)</p>
</blockquote>
<p><strong>TodoList部分代码</strong></p>
<blockquote>
<p>1、更新时可以利用赋值解构后再传入重复字段会自动覆盖的方式进行更新数据</p>
<p>​    –&gt;if(todoObj.id === id) return <code>{...todoObj,done}</code></p>
<p>2、数组批量删除可以用filter过滤实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//updateTodo用于更新一个todo对象</span></span><br><span class="line">updateTodo = <span class="function">(<span class="params">id,done</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//获取状态中的todos</span></span><br><span class="line">		<span class="keyword">const</span> &#123;todos&#125; = <span class="keyword">this</span>.state</span><br><span class="line">		<span class="comment">//匹配处理数据</span></span><br><span class="line">		<span class="keyword">const</span> newTodos = todos.map(<span class="function">(<span class="params">todoObj</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(todoObj.id === id) <span class="keyword">return</span> &#123;...todoObj,done&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> todoObj</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">todos</span>:newTodos&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//deleteTodo用于删除一个todo对象</span></span><br><span class="line">	deleteTodo = <span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//获取原来的todos</span></span><br><span class="line">		<span class="keyword">const</span> &#123;todos&#125; = <span class="keyword">this</span>.state</span><br><span class="line">		<span class="comment">//删除指定id的todo对象</span></span><br><span class="line">		<span class="keyword">const</span> newTodos = todos.filter(<span class="function">(<span class="params">todoObj</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> todoObj.id !== id</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">//更新状态</span></span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">todos</span>:newTodos&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//checkAllTodo用于全选</span></span><br><span class="line">	checkAllTodo = <span class="function">(<span class="params">done</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//获取原来的todos</span></span><br><span class="line">		<span class="keyword">const</span> &#123;todos&#125; = <span class="keyword">this</span>.state</span><br><span class="line">		<span class="comment">//加工数据</span></span><br><span class="line">		<span class="keyword">const</span> newTodos = todos.map(<span class="function">(<span class="params">todoObj</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;...todoObj,done&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">//更新状态</span></span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">todos</span>:newTodos&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="React-ajax"><a href="#React-ajax" class="headerlink" title="React ajax"></a>React ajax</h2><h3 id="React中配置代理-proxy"><a href="#React中配置代理-proxy" class="headerlink" title="React中配置代理(proxy)"></a>React中配置代理(<code>proxy</code>)</h3><p>方法一：<code>简单代理</code>:在package.json中追加如下配置 :<code>&quot;proxy&quot;:http://localhost:5000</code></p>
<ul>
<li>ps:当你请求<code>http://localhost:5000</code>产生跨域(本身在3000端口)时,添加此代码, 之后你请求时用<code>http://localhost:3000</code>进行请求,当其在<code>3000</code>端口中找不到资源时将会自动转发至<code>5000</code>端口进行请求,不产生跨域问题</li>
<li>优点：配置简单，前端请求资源时可以不加任何前缀。</li>
<li>缺点：不能配置多个代理</li>
<li>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</li>
</ul>
<p>方法二：在src下创建配置文件：<code>src/setupProxy.js</code></p>
<ul>
<li>ps:必须是这个文件名,react项目运行的时候会自动查找这个文件,并将其加入webpack的配置中,所以当你修改此文件后,你需要重新启动项目</li>
<li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li>
<li>缺点：配置繁琐，前端请求资源时必须加前缀。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"> <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">   app.use(</span><br><span class="line">     proxy(<span class="string">'/api1'</span>, &#123;  <span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line">       target: <span class="string">'http://localhost:5000'</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line">       changeOrigin: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">       	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">       	changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       pathRewrite: &#123;<span class="string">'^/api1'</span>: <span class="string">''</span>&#125; <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">     &#125;),</span><br><span class="line">     proxy(<span class="string">'/api2'</span>, &#123; </span><br><span class="line">       target: <span class="string">'http://localhost:5001'</span>,</span><br><span class="line">       changeOrigin: <span class="literal">true</span>,</span><br><span class="line">       pathRewrite: &#123;<span class="string">'^/api2'</span>: <span class="string">''</span>&#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充知识点-消息订阅与发布机制等"><a href="#补充知识点-消息订阅与发布机制等" class="headerlink" title="补充知识点 消息订阅与发布机制等"></a>补充知识点 消息订阅与发布机制等</h3><p><strong>连续赋值解构+重命名</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;a&#125; = obj; <span class="comment">//传统解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;b&#125;&#125; = obj; <span class="comment">//连续解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:value&#125;&#125; = obj; <span class="comment">//连续解构赋值+重命名</span></span><br></pre></td></tr></table></figure>
<p><strong>消息订阅与发布机制 —&gt;  工具库: PubSubJS</strong></p>
<blockquote>
<p>1.先订阅，再发布（理解：有一种隔空对话的感觉）</p>
<p>2.适用于任意组件间通信</p>
<p>3.要在组件的componentWillUnmount中取消订阅</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下载: npm install pubsub-js --save</span></span><br><span class="line"><span class="comment">//使用举例</span></span><br><span class="line"><span class="number">1</span>)	<span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">'pubsub-js'</span> <span class="comment">//引入</span></span><br><span class="line"><span class="number">2</span>)	PubSub.subscribe(<span class="string">'delete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; &#125;); <span class="comment">//订阅</span></span><br><span class="line"><span class="number">3</span>)	PubSub.publish(<span class="string">'delete'</span>, data) <span class="comment">//发布消息</span></span><br><span class="line"><span class="comment">//*------------------------------使用----------------------------------------------------</span></span><br><span class="line">	componentDidMount()&#123;</span><br><span class="line">		<span class="keyword">this</span>.token = PubSub.subscribe(<span class="string">'atguigu'</span>,(_,stateObj)=&gt;&#123;</span><br><span class="line">			<span class="keyword">this</span>.setState(stateObj)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	componentWillUnmount()&#123;</span><br><span class="line">		PubSub.unsubscribe(<span class="keyword">this</span>.token)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//----------------------------------使用---------------------------------------------------</span></span><br><span class="line">		<span class="comment">//发送请求前通知List更新状态</span></span><br><span class="line">		PubSub.publish(<span class="string">'atguigu'</span>,&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">isLoading</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">		<span class="comment">//发送网络请求---使用fetch发送（优化）</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> response= <span class="keyword">await</span> fetch(<span class="string">`/api1/search/users2?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>)</span><br><span class="line">			<span class="keyword">const</span> data = <span class="keyword">await</span> response.json()</span><br><span class="line">			<span class="built_in">console</span>.log(data);</span><br><span class="line">			PubSub.publish(<span class="string">'atguigu'</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">users</span>:data.items&#125;)</span><br><span class="line">		&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'请求出错'</span>,error);</span><br><span class="line">			PubSub.publish(<span class="string">'atguigu'</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">err</span>:error.message&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消息订阅与发布机制 —&gt;  工具库: mitt</strong></p>
<p>此方法用的是[<code>mitt</code>]实现,其实本质上就是注册一个全局变量进行监听 –&gt; <a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt源码地址</a></p>
<p>可以自己实现,此处因为人家写的不错了,就以此作为例子</p>
<ol>
<li><p>安装或者直接复制使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save mitt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用示例</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">-------------- 首先要定义一个公用全局变量  --------------------------</span><br><span class="line"> //文件 utils/index.ts</span><br><span class="line"> import mitt from &apos;./mitt&apos;;</span><br><span class="line"> //此处声明,将其变为全局变量</span><br><span class="line"> const eventBus = mitt();</span><br><span class="line"> export &#123; eventBus &#125;</span><br><span class="line"> ---------------- 发送值的组件(要修改别人的组件)  ---------------------</span><br><span class="line"> //导入共有变量</span><br><span class="line"> import &#123; eventBus &#125; from &apos;~/utils&apos;;</span><br><span class="line">   &lt;a</span><br><span class="line">   onClick=&#123;() =&gt; &#123;</span><br><span class="line"> 	//延迟发送是本人此之前有一个跳转动作,跳转到接收方组件</span><br><span class="line">     // 防止修改了值的时候但是接收组件未注册  正常情况直接发送即可     </span><br><span class="line">     //setTimeout(() =&gt; &#123;</span><br><span class="line">     // eventBus.emit(&apos;foo&apos;, data);</span><br><span class="line">     //&#125;, 100);</span><br><span class="line">     eventBus.emit(&apos;foo&apos;, data);    </span><br><span class="line">    &#125;&#125;</span><br><span class="line">   /&gt;;</span><br><span class="line"></span><br><span class="line"> ------------------ 接受方组件(接受发送方的组件)  -------------------------------------</span><br><span class="line"></span><br><span class="line"> const Search: FC&lt;IProps&gt; = (props) =&gt; &#123;</span><br><span class="line">   useEffect(() =&gt; &#123;</span><br><span class="line">     //替换为mitt写法,此时已经接收到了</span><br><span class="line">     eventBus.on(&apos;foo&apos;, (searchParams) =&gt; &#123;console.log(&apos;接受到值了&apos;,searchParams) &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;, []);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3.mitt源码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventType = <span class="built_in">string</span> | symbol;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An event handler can take an optional event argument</span></span><br><span class="line"><span class="comment">// and should not return a value</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Handler&lt;T = unknown&gt; = <span class="function">(<span class="params">event: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> WildcardHandler&lt;T = Record&lt;<span class="built_in">string</span>, unknown&gt;&gt; = (</span><br><span class="line">  <span class="keyword">type</span>: keyof T,</span><br><span class="line">  event: T[keyof T]</span><br><span class="line">) =&gt; <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An array of all currently registered event handlers for a type</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventHandlerList&lt;T = unknown&gt; = <span class="built_in">Array</span>&lt;Handler&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> WildCardEventHandlerList&lt;T = Record&lt;<span class="built_in">string</span>, unknown&gt;&gt; = <span class="built_in">Array</span>&lt;</span><br><span class="line">  WildcardHandler&lt;T&gt;</span><br><span class="line">&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A map of event types and their corresponding event handlers.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> EventHandlerMap&lt;Events <span class="keyword">extends</span> Record&lt;EventType, unknown&gt;&gt; = Map&lt;</span><br><span class="line">  keyof Events | <span class="string">'*'</span>,</span><br><span class="line">  EventHandlerList&lt;Events[keyof Events]&gt; | WildCardEventHandlerList&lt;Events&gt;</span><br><span class="line">&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Emitter&lt;Events <span class="keyword">extends</span> Record&lt;EventType, unknown&gt;&gt; &#123;</span><br><span class="line">  all: EventHandlerMap&lt;Events&gt;;</span><br><span class="line"></span><br><span class="line">  on: <span class="function">(<span class="params">&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="params"><span class="keyword">type</span>: Key, handler: Handler&lt;Events[Key]&gt;</span>) =&gt; <span class="built_in">void</span></span>) &amp; (<span class="params">(<span class="params"><span class="keyword">type</span>: '*', handler: WildcardHandler&lt;Events&gt;</span>) =&gt; <span class="built_in">void</span></span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">off</span>: (<span class="params">&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    <span class="keyword">type</span>: Key,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    handler?: Handler&lt;Events[Key]&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">  </span>) =&gt; <span class="built_in">void</span></span>) &amp; (<span class="params">(<span class="params"><span class="keyword">type</span>: '*', handler: WildcardHandler&lt;Events&gt;</span>) =&gt; <span class="built_in">void</span></span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">emit</span>: (<span class="params">&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="params"><span class="keyword">type</span>: Key, event: Events[Key]</span>) =&gt; <span class="built_in">void</span></span>) &amp; (<span class="params">&lt;Key <span class="keyword">extends</span> keyof Events&gt;(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    <span class="keyword">type</span>: <span class="literal">undefined</span> <span class="keyword">extends</span> Events[Key] ? Key : never</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">  </span>) =&gt; <span class="built_in">void</span></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/**</span></span><br><span class="line"><span class="function"> * <span class="params">Mitt</span>: <span class="params">Tiny</span> (<span class="params">~200b</span>) <span class="params">functional</span> <span class="params">event</span> <span class="params">emitter</span> / <span class="params">pubsub</span>.</span></span><br><span class="line"><span class="function"> * @<span class="params">name</span> <span class="params">mitt</span></span></span><br><span class="line"><span class="function"> * @<span class="params">returns</span> &#123;<span class="params">Mitt</span>&#125;</span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"><span class="params">export</span> <span class="params">default</span> <span class="params">function</span> <span class="params">mitt</span>&lt;<span class="params">Events</span> <span class="params">extends</span> <span class="params">Record</span>&lt;<span class="params">EventType</span>, <span class="params">unknown</span>&gt;&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  all?: EventHandlerMap&lt;Events&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="params">Emitter</span>&lt;<span class="params">Events</span>&gt; &#123;</span></span><br><span class="line"><span class="function">  <span class="params">type</span> <span class="params">GenericEventHandler</span> =</span></span><br><span class="line"><span class="function">    | <span class="params">Handler</span>&lt;<span class="params">Events</span>[<span class="params">keyof</span> <span class="params">Events</span>]&gt;</span></span><br><span class="line"><span class="function">    | <span class="params">WildcardHandler</span>&lt;<span class="params">Events</span>&gt;;</span></span><br><span class="line"><span class="function">  <span class="params">all</span> = <span class="params">all</span> || <span class="params">new</span> <span class="params">Map</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> &#123;</span></span><br><span class="line"><span class="function">    /**</span></span><br><span class="line"><span class="function">     * <span class="params">A</span> <span class="params">Map</span> <span class="params">of</span> <span class="params">event</span> <span class="params">names</span> <span class="params">to</span> <span class="params">registered</span> <span class="params">handler</span> <span class="params">functions</span>.</span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function">    <span class="params">all</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /**</span></span><br><span class="line"><span class="function">     * <span class="params">Register</span> <span class="params">an</span> <span class="params">event</span> <span class="params">handler</span> <span class="params">for</span> <span class="params">the</span> <span class="params">given</span> <span class="params">type</span>.</span></span><br><span class="line"><span class="function">     * @<span class="params">param</span> &#123;<span class="params">string</span>|<span class="params">symbol</span>&#125; <span class="params">type</span> <span class="params">Type</span> <span class="params">of</span> <span class="params">event</span> <span class="params">to</span> <span class="params">listen</span> <span class="params">for</span>, <span class="params">or</span> `'*'` <span class="params">for</span> <span class="params">all</span> <span class="params">events</span></span></span><br><span class="line"><span class="function">     * @<span class="params">param</span> &#123;<span class="params">Function</span>&#125; <span class="params">handler</span> <span class="params">Function</span> <span class="params">to</span> <span class="params">call</span> <span class="params">in</span> <span class="params">response</span> <span class="params">to</span> <span class="params">given</span> <span class="params">event</span></span></span><br><span class="line"><span class="function">     * @<span class="params">memberOf</span> <span class="params">mitt</span></span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function">    <span class="params">on</span>&lt;<span class="params">Key</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">Events</span>&gt;(<span class="params"><span class="keyword">type</span>: Key, handler: GenericEventHandler</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">const</span> <span class="params">handlers</span>: <span class="params">Array</span>&lt;<span class="params">GenericEventHandler</span>&gt; | <span class="params">undefined</span> = <span class="params">all</span>!.<span class="params">get</span>(<span class="params"><span class="keyword">type</span></span>);</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">handlers</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">handlers</span>.<span class="params">push</span>(<span class="params">handler</span>);</span></span><br><span class="line"><span class="function">      &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="params">all</span>!.<span class="params">set</span>(<span class="params"><span class="keyword">type</span>, [handler] <span class="keyword">as</span> EventHandlerList&lt;Events[keyof Events]&gt;</span>);</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /**</span></span><br><span class="line"><span class="function">     * <span class="params">Remove</span> <span class="params">an</span> <span class="params">event</span> <span class="params">handler</span> <span class="params">for</span> <span class="params">the</span> <span class="params">given</span> <span class="params">type</span>.</span></span><br><span class="line"><span class="function">     * <span class="params">If</span> `<span class="params">handler</span>` <span class="params">is</span> <span class="params">omitted</span>, <span class="params">all</span> <span class="params">handlers</span> <span class="params">of</span> <span class="params">the</span> <span class="params">given</span> <span class="params">type</span> <span class="params">are</span> <span class="params">removed</span>.</span></span><br><span class="line"><span class="function">     * @<span class="params">param</span> &#123;<span class="params">string</span>|<span class="params">symbol</span>&#125; <span class="params">type</span> <span class="params">Type</span> <span class="params">of</span> <span class="params">event</span> <span class="params">to</span> <span class="params">unregister</span> `<span class="params">handler</span>` <span class="params">from</span>, <span class="params">or</span> `'*'`</span></span><br><span class="line"><span class="function">     * @<span class="params">param</span> &#123;<span class="params">Function</span>&#125; [<span class="params">handler</span>] <span class="params">Handler</span> <span class="params">function</span> <span class="params">to</span> <span class="params">remove</span></span></span><br><span class="line"><span class="function">     * @<span class="params">memberOf</span> <span class="params">mitt</span></span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function">    <span class="params">off</span>&lt;<span class="params">Key</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">Events</span>&gt;(<span class="params"><span class="keyword">type</span>: Key, handler?: GenericEventHandler</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">const</span> <span class="params">handlers</span>: <span class="params">Array</span>&lt;<span class="params">GenericEventHandler</span>&gt; | <span class="params">undefined</span> = <span class="params">all</span>!.<span class="params">get</span>(<span class="params"><span class="keyword">type</span></span>);</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">handlers</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">if</span> (<span class="params">handler</span>) &#123;</span></span><br><span class="line"><span class="function">          <span class="params">handlers</span>.<span class="params">splice</span>(<span class="params">handlers.indexOf(<span class="params">handler</span>) &gt;&gt;&gt; 0, 1</span>);</span></span><br><span class="line"><span class="function">        &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">          <span class="params">all</span>!.<span class="params">set</span>(<span class="params"><span class="keyword">type</span>, []</span>);</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /**</span></span><br><span class="line"><span class="function">     * <span class="params">Invoke</span> <span class="params">all</span> <span class="params">handlers</span> <span class="params">for</span> <span class="params">the</span> <span class="params">given</span> <span class="params">type</span>.</span></span><br><span class="line"><span class="function">     * <span class="params">If</span> <span class="params">present</span>, `'*'` <span class="params">handlers</span> <span class="params">are</span> <span class="params">invoked</span> <span class="params">after</span> <span class="params">type</span>-<span class="params">matched</span> <span class="params">handlers</span>.</span></span><br><span class="line"><span class="function">     *</span></span><br><span class="line"><span class="function">     * <span class="params">Note</span>: <span class="params">Manually</span> <span class="params">firing</span> '*' <span class="params">handlers</span> <span class="params">is</span> <span class="params">not</span> <span class="params">supported</span>.</span></span><br><span class="line"><span class="function">     *</span></span><br><span class="line"><span class="function">     * @<span class="params">param</span> &#123;<span class="params">string</span>|<span class="params">symbol</span>&#125; <span class="params">type</span> <span class="params">The</span> <span class="params">event</span> <span class="params">type</span> <span class="params">to</span> <span class="params">invoke</span></span></span><br><span class="line"><span class="function">     * @<span class="params">param</span> &#123;<span class="params">Any</span>&#125; [<span class="params">evt</span>] <span class="params">Any</span> <span class="params">value</span> (<span class="params">object is recommended and powerful</span>), <span class="params">passed</span> <span class="params">to</span> <span class="params">each</span> <span class="params">handler</span></span></span><br><span class="line"><span class="function">     * @<span class="params">memberOf</span> <span class="params">mitt</span></span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function">    <span class="params">emit</span>&lt;<span class="params">Key</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">Events</span>&gt;(<span class="params"><span class="keyword">type</span>: Key, evt?: Events[Key]</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">let</span> <span class="params">handlers</span> = <span class="params">all</span>!.<span class="params">get</span>(<span class="params"><span class="keyword">type</span></span>);</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">handlers</span>) &#123;</span></span><br><span class="line"><span class="function">        (<span class="params">handlers <span class="keyword">as</span> EventHandlerList&lt;Events[keyof Events]&gt;</span>)</span></span><br><span class="line"><span class="function">          .<span class="params">slice</span><span class="params">()</span></span></span><br><span class="line"><span class="function">          .<span class="params">map</span>(<span class="params">(<span class="params">handler</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            handler(<span class="params">evt!</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">          &#125;</span>);</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      <span class="params">handlers</span> = <span class="params">all</span>!.<span class="params">get</span>(<span class="params">'*'</span>);</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">handlers</span>) &#123;</span></span><br><span class="line"><span class="function">        (<span class="params">handlers <span class="keyword">as</span> WildCardEventHandlerList&lt;Events&gt;</span>)</span></span><br><span class="line"><span class="function">          .<span class="params">slice</span><span class="params">()</span></span></span><br><span class="line"><span class="function">          .<span class="params">map</span>(<span class="params">(<span class="params">handler</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            handler(<span class="params"><span class="keyword">type</span>, evt!</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">          &#125;</span>);</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;,</span></span><br><span class="line"><span class="function">  &#125;;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>defaultChecked 、 checked的区别</strong></p>
<p>注意defaultChecked 和 checked的区别，类似的还有：defaultValue 和 value</p>
<h3 id="fetch发送请求"><a href="#fetch发送请求" class="headerlink" title="fetch发送请求"></a><code>fetch</code>发送请求</h3><blockquote>
<p>概念:<code>关注分离</code>的设计思想</p>
</blockquote>
<blockquote>
<ol>
<li>Fetch 是浏览器提供的原生 AJAX 接口。</li>
</ol>
<p>由于原来的XMLHttpRequest<code>不符合关注分离原则</code>，且基于事件的模型在处理异步上已经没有现代的Promise等那么有优势。因此Fetch出现来解决这种问题。</p>
<ol start="2">
<li><p>特点:</p>
<ul>
<li><p>fetch: <code>原生函数</code>，不再使用XmlHttpRequest对象提交ajax请求</p>
</li>
<li><p><code>老版本浏览器可能不支持</code></p>
</li>
<li><p>使用 fetch 无法<code>取消一个请求</code>。这是因为Fetch API<code>基于 Promise</code>，而Promise无法做到这一点。由于Fetch是典型的异步场景，所以大部分遇到的问题不是 Fetch 的，其实是 Promise 的。</p>
</li>
</ul>
</li>
<li><p>如果直接使用<code>fetch</code>,返回的并不是直接的结果它只是一个<code>HTTP响应</code>，而不是真的数据。想要获取数据,方法有二:</p>
</li>
</ol>
<p>① 使用async+await获取</p>
<p>② 使用promise的链式调用,再第一个then中将其返回,再下个then中在使用</p>
<ol start="4">
<li>代码示例</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line">----------------------------- 未优化:使用then链式调用 ---------------------------------------------------------</span><br><span class="line">fetch(<span class="string">`/api1/search/users2?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).then(</span><br><span class="line">			response =&gt; &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">'联系服务器成功了'</span>);</span><br><span class="line">				<span class="keyword">return</span> response.json()</span><br><span class="line">			&#125;,</span><br><span class="line">			error =&gt; &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">'联系服务器失败了'</span>,error);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		).then(</span><br><span class="line">			response =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'获取数据成功了'</span>,response);&#125;,</span><br><span class="line">			error =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'获取数据失败了'</span>,error);&#125;</span><br><span class="line">) </span><br><span class="line">----------------------------- 优化后:使用<span class="keyword">async</span>+<span class="keyword">await</span> ---------------------------------------------------------</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> response= <span class="keyword">await</span> fetch(<span class="string">`/api1/search/users2?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>)</span><br><span class="line">		<span class="keyword">const</span> data = <span class="keyword">await</span> response.json()</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">		onsole.log(<span class="string">'请求出错'</span>,error);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="React-路由"><a href="#React-路由" class="headerlink" title="React 路由"></a>React 路由</h2><h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><blockquote>
<ol>
<li><p>单页Web应用（single page web application，SPA）。</p>
</li>
<li><p>整个应用只有<strong>一个完整的页面</strong>。</p>
</li>
<li><p>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></p>
</li>
<li><p>数据都需要通过ajax请求获取, 并在前端异步展现。</p>
</li>
</ol>
</blockquote>
<h3 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h3><p><strong>什么是路由?</strong></p>
<blockquote>
<ol>
<li><p>一个路由就是一个映射关系(key:value)</p>
</li>
<li><p>key为路径, value可能是function或component</p>
</li>
</ol>
</blockquote>
<p> <strong>路由分类</strong></p>
<p><strong>1、后端路由</strong></p>
<blockquote>
<p>1)   理解： value是function, 用来处理客户端提交的请求。</p>
<p>2)   注册路由： router.get(path, function(req, res))</p>
<p>3)   工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p>
</blockquote>
<p><strong>2、前端路由</strong></p>
<blockquote>
<p>1)   浏览器端路由，value是component，用于展示页面内容。</p>
<p>2)   注册路由: <code>&lt;Route path=&quot;/test&quot; component={Test}&gt;</code></p>
<p>3)   工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p>
</blockquote>
<h3 id="react-router-dom的理解"><a href="#react-router-dom的理解" class="headerlink" title="react-router-dom的理解"></a>react-router-dom的理解</h3><p><strong>相关概念</strong></p>
<blockquote>
<ol>
<li><p>react的一个插件库。</p>
</li>
<li><p>专门用来实现一个SPA应用。</p>
</li>
<li><p>基于react的项目基本都会用到此库。</p>
</li>
</ol>
</blockquote>
<p><strong>相关api</strong></p>
<p><strong>1、内置组件</strong></p>
<blockquote>
<ol>
<li><p><code>&lt;BrowserRouter&gt;</code></p>
</li>
<li><p><code>&lt;HashRouter&gt;</code></p>
</li>
<li><p><code>&lt;Route&gt;</code></p>
</li>
<li><p><code>&lt;Redirect&gt;</code></p>
</li>
<li><p><code>&lt;Link&gt;</code></p>
</li>
<li><p><code>&lt;NavLink&gt;</code></p>
</li>
<li><p><code>&lt;Switch&gt;</code></p>
</li>
</ol>
</blockquote>
<p><strong>2、其他</strong></p>
<blockquote>
<ol>
<li><p>history对象</p>
</li>
<li><p>match对象</p>
</li>
<li><p>withRouter函数</p>
</li>
</ol>
</blockquote>
<h3 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h3><p>1.明确好界面中的导航区、展示区</p>
<p>2.导航区的a标签改为Link标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/xxxxx"</span>&gt;Demo&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.展示区写Route标签进行路径的匹配 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/xxxx'</span> component=&#123;Demo&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>4.<code>&lt;App&gt;</code>的最外侧包裹了一个<code>&lt;BrowserRouter&gt;或&lt;HashRouter&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;BrowserRouter&gt;</span><br><span class="line">		&lt;App/&gt;</span><br><span class="line">	&lt;/BrowserRouter&gt;,</span><br><span class="line">	document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h3><p><strong>1.写法不同：</strong></p>
<p>​      一般组件：<code>&lt;Demo/&gt;</code></p>
<p>​      路由组件：<code>&lt;Route path=&quot;/demo&quot; component={Demo}/&gt;</code></p>
<p><strong>2.存放位置不同：</strong></p>
<p>​      一般组件：components</p>
<p>​      路由组件：pages</p>
<p><strong>3.接收到的props不同：</strong></p>
<p> 一般组件：写组件标签时传递了什么，就能收到什么</p>
<p> 路由组件：接收到三个固定的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//路由属性打印结果展示</span><br><span class="line">history:</span><br><span class="line">	go: ƒ go(n)</span><br><span class="line">	goBack: ƒ goBack()</span><br><span class="line">	goForward: ƒ goForward()</span><br><span class="line">	push: ƒ push(path, state)</span><br><span class="line">	replace: ƒ replace(path, state)</span><br><span class="line">location:</span><br><span class="line">    pathname: &quot;/about&quot;</span><br><span class="line">	search: &quot;&quot;</span><br><span class="line">	state: undefined</span><br><span class="line">	match:</span><br><span class="line">params: &#123; &#125;</span><br><span class="line">	path: &quot;/about&quot;</span><br><span class="line">	url: &quot;/about&quot;</span><br></pre></td></tr></table></figure>
<h3 id="NavLink使用与封装"><a href="#NavLink使用与封装" class="headerlink" title="NavLink使用与封装"></a>NavLink使用与封装</h3><ol>
<li><p>NavLink可以<code>实现路由链接的高亮</code>，通过<code>activeClassName指定样式名</code></p>
</li>
<li><p>封装</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//封装示例</span><br><span class="line">export default class MyNavLink extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;NavLink activeClassName=&quot;atguigu&quot; className=&quot;list-group-item&quot; &#123;...this.props&#125;/&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用与调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//原生html中，靠&lt;a&gt;跳转不同的页面</span><br><span class="line">&#123;/* &lt;a className=&quot;list-group-item&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;</span><br><span class="line">&lt;a className=&quot;list-group-item active&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; */&#125;</span><br><span class="line"></span><br><span class="line"> &#123;/* 在React中靠路由链接实现切换组件--编写路由链接 */&#125;</span><br><span class="line"> 	&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;</span><br><span class="line"> 	&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a>Switch的使用</h3><p>1.通常情况下，path和component是一一对应的关系。</p>
<p>2.Switch可以提高路由匹配效率(单一匹配) —- 即匹配到一个后将不再往下匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">	&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">	&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">	&lt;Route path=&quot;/home&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a>解决多级路径刷新页面样式丢失的问题</h3><p>1.public/index.html 中 引入样式时不写 ./ 写 / （常用）</p>
<p>2.public/index.html 中 引入样式时不写 ./ 写 <code>%PUBLIC_URL%</code> （常用,但<code>只在react中</code>有效果）</p>
<p>3.使用HashRouter (不常用)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">		&lt;title&gt;react脚手架&lt;/title&gt;</span><br><span class="line">   &lt;!-- 方法二 --&gt;</span><br><span class="line">		&lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;</span><br><span class="line">     &lt;!-- 方法一 --&gt;</span><br><span class="line">		&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h3><ol>
<li><p>默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</p>
</li>
<li><p>开启严格匹配：<route `exact="{true}`path=" about"" component="{About}/">  </route></p>
<p>可以省略<code>exact={true}</code>为<code>exact</code></p>
</li>
<li><p><code>严格匹配不要随便开启</code>，需要再开，有些时候开启会导致无法继续匹配二级路由</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//编写路由链接</span><br><span class="line">	&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;</span><br><span class="line">	&lt;MyNavLink to=&quot;/home/a/b&quot;&gt;Home&lt;/MyNavLink&gt;</span><br><span class="line"></span><br><span class="line">&#123;/* 注册路由 */&#125;</span><br><span class="line">	&lt;Switch&gt;</span><br><span class="line">		&lt;Route exact path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">		&lt;Route exact path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">	&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a><strong>Redirect的使用</strong></h3><ol>
<li><p>一般写在所有路由注册的<code>最下方</code>，当所有路由都<code>无法匹配时</code>，跳转到Redirect指定的路由</p>
</li>
<li><p>具体编码：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">		&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">		&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">		&lt;Redirect to=&quot;/about&quot;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ol>
<li><p>注册子路由时要写上父路由的path值</p>
</li>
<li><p>路由的匹配是按照注册路由的顺序进行的</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------注册一级路由-----------------------------</span><br><span class="line">	&#123;/* 在React中靠路由链接实现切换组件--编写路由链接 */&#125;</span><br><span class="line">	&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;</span><br><span class="line">	&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;</span><br><span class="line">   &#123;/* 注册路由 */&#125;</span><br><span class="line">	&lt;Switch&gt;</span><br><span class="line">		&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">		&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">		&lt;Redirect to=&quot;/about&quot;/&gt;</span><br><span class="line">	&lt;/Switch&gt;</span><br><span class="line">----------------------注册二级路由 :Home组件-----------------------------------</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">		&lt;ul className=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">			&lt;li&gt;</span><br><span class="line">				&lt;MyNavLink to=&quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt;</span><br><span class="line">			&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;</span><br><span class="line">				&lt;MyNavLink to=&quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;</span><br><span class="line">			&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">		&#123;/* 注册路由 */&#125;</span><br><span class="line">		&lt;Switch&gt;</span><br><span class="line">			&lt;Route path=&quot;/home/news&quot; component=&#123;News&#125;/&gt;</span><br><span class="line">			&lt;Route path=&quot;/home/message&quot; component=&#123;Message&#125;/&gt;</span><br><span class="line">			&lt;Redirect to=&quot;/home/news&quot;/&gt;</span><br><span class="line">		&lt;/Switch&gt;</span><br><span class="line">	&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h3><p><strong>params参数</strong></p>
<ol>
<li><p>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test/tom/18&#39;}&gt;详情&lt;/Link&gt;</code></p>
</li>
<li><p>注册路由(声明接收)：<code>&lt;Route path=&quot;/demo/test/:name/:age&quot; component={Test}/&gt;</code></p>
</li>
<li><p>接收参数：this.props.match.params</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------发送参数:父组件----------------------------------------------</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">       &#123;/* 向路由组件传递params参数 */&#125;</span><br><span class="line">       &lt;Link to=&#123;`/home/message/detail/$&#123;msgObj.id&#125;/$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt;</span><br><span class="line">       &lt;hr /&gt;</span><br><span class="line">       &#123;/* 声明接收params参数 */&#125;</span><br><span class="line">       &lt;Route path=&quot;/home/message/detail/:id/:title&quot; component=&#123;Detail&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">	--------------------------------接受参数:子组件-----------------------------------------------------------</span><br><span class="line">    const &#123;id,title&#125; = this.props.match.params</span><br></pre></td></tr></table></figure>
<p><strong>search参数</strong></p>
<ol>
<li>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test?name=tom&amp;age=18&#39;}&gt;详情&lt;/Link&gt;</code></li>
<li>注册路由(<code>无需声明</code>，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component={Test}/&gt;</code></li>
<li>接收参数：this.props.location.search</li>
<li>备注：获取到的search是<code>urlencoded编码字符串</code>，需要<code>借助querystring解析</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------发送参数:父组件----------------------------------------------</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">      	&#123;/* 向路由组件传递search参数 */&#125;</span><br><span class="line">		&lt;Link to=&#123;`/home/message/detail/?id=$&#123;msgObj.id&#125;&amp;title=$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt;</span><br><span class="line">       &lt;hr /&gt;</span><br><span class="line">     	&#123;/* search参数无需声明接收，正常注册路由即可 */&#125;</span><br><span class="line">		&lt;Route path=&quot;/home/message/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">	--------------------------------接受参数:子组件-----------------------------------------------------------</span><br><span class="line">    import qs from &apos;querystring&apos;</span><br><span class="line">	// 接收search参数</span><br><span class="line">	const &#123;search&#125; = this.props.location</span><br><span class="line">	const &#123;id,title&#125; = qs.parse(search.slice(1))</span><br></pre></td></tr></table></figure>
<p><strong>state参数</strong></p>
<ol>
<li>路由链接(携带参数)：[<code>&lt;Link to={ {pathname:&#39;/demo/test&#39;,state:{name:&#39;tom&#39;,age:18} } }&gt;详情&lt;/Link&gt;</code>]</li>
<li>注册路由(无需声明，正常注册即可)：[<code>&lt;Route path=&quot;/demo/test&quot; component={Test}/&gt;</code>]</li>
<li><p>接收参数：this.props.location.state</p>
<ul>
<li>备注：使用<code>BrowserRouter</code>刷新才可以<code>保留住参数</code>,使用<code>HashRouter</code>刷新后state将会没有<code>history</code>来保存参数</li>
<li>子组件接受参数时<code>const {id,title} = this.props.location.state || {   }</code> ,后面添加<code>||{   }</code>是防止使用<code>HashRouter</code>后state为undefined时报错</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------发送参数:父组件----------------------------------------------</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">      	&#123;/* 向路由组件传递state参数 */&#125;</span><br><span class="line">		&lt;Link to=&#123; &#123;pathname:&apos;/home/message/detail&apos;,state:&#123;id:msgObj.id,title:msgObj.title&#125; &#125; &#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">       &lt;hr /&gt;</span><br><span class="line">     	&#123;/* state参数无需声明接收，正常注册路由即可 */&#125;</span><br><span class="line">		&lt;Route path=&quot;/home/message/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">	--------------------------------接受参数:子组件-----------------------------------------------------------</span><br><span class="line">    // 接收state参数,后面添加`||&#123;  &#125;`是防止使用`HashRouter`后state为undefined时报错</span><br><span class="line">	const &#123;id,title&#125; = this.props.location.state || &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><p><code>借助this.prosp.history对象上的API对</code>操作路由跳转、前进、后退  </p>
<ol>
<li><p>-this.prosp.history.push()</p>
<p>将历史记录压入栈</p>
</li>
<li><p>-this.props.history.replace()</p>
<p>替代栈位置,即不会产生历史记录</p>
</li>
<li><p>-this.props.history.goBack()</p>
<p>回退一格</p>
</li>
<li><p>-this.props.history.goForward()</p>
<p>前进一格</p>
</li>
<li><p>-this.props.history.go()</p>
<p>前进或者后退n格(根据传入的数字正负数)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import &#123; Link, Route &#125; from &apos;react-router-dom&apos;</span><br><span class="line">import Detail from &apos;./Detail&apos;</span><br><span class="line"></span><br><span class="line">export default class Message extends Component &#123;</span><br><span class="line"> state = &#123;</span><br><span class="line">   messageArr: [</span><br><span class="line">     &#123; id: &apos;01&apos;, title: &apos;消息1&apos; &#125;,</span><br><span class="line">     &#123; id: &apos;02&apos;, title: &apos;消息2&apos; &#125;,</span><br><span class="line">     &#123; id: &apos;03&apos;, title: &apos;消息3&apos; &#125;,</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> replaceShow = (id, title) =&gt; &#123;</span><br><span class="line">   //replace跳转+携带params参数</span><br><span class="line">   //this.props.history.replace(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)</span><br><span class="line"></span><br><span class="line">   //replace跳转+携带search参数</span><br><span class="line">   // this.props.history.replace(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)</span><br><span class="line"></span><br><span class="line">   //replace跳转+携带state参数</span><br><span class="line">   this.props.history.replace(`/home/message/detail`, &#123; id, title &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> pushShow = (id, title) =&gt; &#123;</span><br><span class="line">   //push跳转+携带params参数</span><br><span class="line">   // this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)</span><br><span class="line"></span><br><span class="line">   //push跳转+携带search参数</span><br><span class="line">   // this.props.history.push(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)</span><br><span class="line"></span><br><span class="line">   //push跳转+携带state参数</span><br><span class="line">   this.props.history.push(`/home/message/detail`, &#123; id, title &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> back = () =&gt; &#123;</span><br><span class="line">   this.props.history.goBack()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> forward = () =&gt; &#123;</span><br><span class="line">   this.props.history.goForward()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> go = () =&gt; &#123;</span><br><span class="line">   this.props.history.go(-2)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   const &#123; messageArr &#125; = this.state</span><br><span class="line">   return (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">         &#123;</span><br><span class="line">           messageArr.map((msgObj) =&gt; &#123;</span><br><span class="line">             return (</span><br><span class="line">               &lt;li key=&#123;msgObj.id&#125;&gt;</span><br><span class="line"></span><br><span class="line">                 &#123;/* 向路由组件传递params参数 */&#125;</span><br><span class="line">                 &#123;/* &lt;Link to=&#123;`/home/message/detail/$&#123;msgObj.id&#125;/$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; */&#125;</span><br><span class="line"></span><br><span class="line">                 &#123;/* 向路由组件传递search参数 */&#125;</span><br><span class="line">                 &#123;/* &lt;Link to=&#123;`/home/message/detail/?id=$&#123;msgObj.id&#125;&amp;title=$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; */&#125;</span><br><span class="line"></span><br><span class="line">                 &#123;/* 向路由组件传递state参数 */&#125;</span><br><span class="line">                 &lt;Link to=&#123;&#123; pathname: &apos;/home/message/detail&apos;, state: &#123; id: msgObj.id, title: msgObj.title &#125; &#125;&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt;</span><br><span class="line">			&amp;nbsp;&lt;button onClick=&#123;() =&gt; this.pushShow(msgObj.id, msgObj.title)&#125;&gt;push查看&lt;/button&gt;</span><br><span class="line">			&amp;nbsp;&lt;button onClick=&#123;() =&gt; this.replaceShow(msgObj.id, msgObj.title)&#125;&gt;replace查看&lt;/button&gt;</span><br><span class="line">               &lt;/li&gt;</span><br><span class="line">             )</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;</span><br><span class="line">       &lt;/ul&gt;</span><br><span class="line">       &lt;hr /&gt;</span><br><span class="line">       &#123;/* 声明接收params参数 */&#125;</span><br><span class="line">       &#123;/* &lt;Route path=&quot;/home/message/detail/:id/:title&quot; component=&#123;Detail&#125;/&gt; */&#125;</span><br><span class="line"></span><br><span class="line">       &#123;/* search参数无需声明接收，正常注册路由即可 */&#125;</span><br><span class="line">       &#123;/* &lt;Route path=&quot;/home/message/detail&quot; component=&#123;Detail&#125;/&gt; */&#125;</span><br><span class="line"></span><br><span class="line">       &#123;/* state参数无需声明接收，正常注册路由即可 */&#125;</span><br><span class="line">       &lt;Route path=&quot;/home/message/detail&quot; component=&#123;Detail&#125; /&gt;</span><br><span class="line"></span><br><span class="line">       &lt;button onClick=&#123;this.back&#125;&gt;回退&lt;/button&gt;&amp;nbsp;</span><br><span class="line">       &lt;button onClick=&#123;this.forward&#125;&gt;前进&lt;/button&gt;&amp;nbsp;</span><br><span class="line">       &lt;button onClick=&#123;this.go&#125;&gt;go&lt;/button&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="withRouter的使用"><a href="#withRouter的使用" class="headerlink" title="withRouter的使用"></a>withRouter的使用</h3><ol>
<li>withRouter可以加工一般组件，让一般组件具备路由组件所特有的API</li>
<li>withRouter的返回值是一个新组件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import &#123; withRouter &#125; from &apos;react-router-dom&apos;</span><br><span class="line">class Header extends Component &#123;</span><br><span class="line"> back = () =&gt; &#123; this.props.history.goBack()&#125;</span><br><span class="line"> forward = () =&gt; &#123;this.props.history.goForward()&#125;</span><br><span class="line"> go = () =&gt; &#123; this.props.history.go(-2)&#125;</span><br><span class="line"> render() &#123;</span><br><span class="line">   console.log(&apos;Header组件收到的props是&apos;, this.props);</span><br><span class="line">   return (</span><br><span class="line">     &lt;div className=&quot;page-header&quot;&gt;</span><br><span class="line">       &lt;h2&gt;React Router Demo&lt;/h2&gt;</span><br><span class="line">       &lt;button onClick=&#123;this.back&#125;&gt;回退&lt;/button&gt;&amp;nbsp;</span><br><span class="line">       &lt;button onClick=&#123;this.forward&#125;&gt;前进&lt;/button&gt;&amp;nbsp;</span><br><span class="line">       &lt;button onClick=&#123;this.go&#125;&gt;go&lt;/button&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default withRouter(Header)</span><br></pre></td></tr></table></figure>
<h3 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h3><p>备注：HashRouter可以用于解决一些路径错误相关的问题。即在<code>问题6</code>中引入文件时可以不进行路径修改</p>
<p><strong>底层原理不一样：</strong></p>
<ol>
<li><p>BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。</p>
<p><code>但一般来说都用的这个</code></p>
</li>
<li><p>HashRouter使用的是URL的哈希值。</p>
</li>
</ol>
<p><strong>path表现形式不一样</strong></p>
<ol>
<li><p>BrowserRouter的路径中没有#,例如：localhost:3000/demo/test</p>
</li>
<li><p>HashRouter的路径包含#,例如：localhost:3000/#/demo/test</p>
</li>
</ol>
<p><strong>刷新后对路由state参数的影响</strong></p>
<ol>
<li><p>BrowserRouter没有任何影响，因为state保存在history对象中。</p>
</li>
<li><p>HashRouter<code>刷新后会导致路由state参数的丢失！！！</code></p>
</li>
</ol>
<h2 id="Ant-Design"><a href="#Ant-Design" class="headerlink" title="Ant Design"></a>Ant Design</h2><blockquote>
<p><strong>ant-design(国内蚂蚁金服)</strong></p>
<ol>
<li>官网: <a href="https://ant.design/index-cn" target="_blank" rel="noopener">https://ant.design/index-cn</a></li>
<li>Github: <a href="https://github.com/ant-design/ant-design/" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/</a></li>
</ol>
<p><strong>material-ui(国外)</strong></p>
<ol>
<li><p>官网: <a href="http://www.material-ui.com/#/" target="_blank" rel="noopener">http://www.material-ui.com/#/</a></p>
</li>
<li><p>github: <a href="https://github.com/callemall/material-ui" target="_blank" rel="noopener">https://github.com/callemall/material-ui</a></p>
</li>
</ol>
</blockquote>
<h3 id="按需引入与自定义主题"><a href="#按需引入与自定义主题" class="headerlink" title="按需引入与自定义主题"></a>按需引入与自定义主题</h3><p><strong>安装依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-app-rewired customize-cra babel-plugin-import less less-loader</span><br></pre></td></tr></table></figure>
<p><strong>修改package.json</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">	&quot;start&quot;: &quot;react-app-rewired start&quot;,</span><br><span class="line">	&quot;build&quot;: &quot;react-app-rewired build&quot;,</span><br><span class="line">	&quot;test&quot;: &quot;react-app-rewired test&quot;,</span><br><span class="line">	&quot;eject&quot;: &quot;react-scripts eject&quot;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>根目录下创建config-overrides.js</strong></p>
<p>注意:如果按照官方文档的自定义主题进行配置可能会报错,需要多加一层<code>lessOptions</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//配置具体的修改规则</span><br><span class="line">const &#123; override, fixBabelImports,addLessLoader&#125; = require(&apos;customize-cra&apos;);</span><br><span class="line">module.exports = override(</span><br><span class="line">	fixBabelImports(&apos;import&apos;, &#123;</span><br><span class="line">		libraryName: &apos;antd&apos;,</span><br><span class="line">		libraryDirectory: &apos;es&apos;,</span><br><span class="line">		style: true,</span><br><span class="line">	&#125;),</span><br><span class="line">	addLessLoader(&#123;</span><br><span class="line">		lessOptions:&#123;</span><br><span class="line">			javascriptEnabled: true,</span><br><span class="line">			modifyVars: &#123; &apos;@primary-color&apos;: &apos;green&apos; &#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;),</span><br><span class="line">-------------------官方方法,会报错-------------------------    </span><br><span class="line">+ addLessLoader(&#123;</span><br><span class="line">+   javascriptEnabled: true,</span><br><span class="line">+   modifyVars: &#123; &apos;@primary-color&apos;: &apos;#1DA57A&apos; &#125;,</span><br><span class="line">+ &#125;),</span><br><span class="line">---------------------------------------------------------   </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>备注：不用在组件里亲自引入样式了，即：import ‘antd/dist/antd.css’应该删掉</p>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p><strong>学习文档</strong></p>
<blockquote>
<ol>
<li><p>英文文档: <a href="https://redux.js.org/" target="_blank" rel="noopener">https://redux.js.org/</a></p>
</li>
<li><p>中文文档: <a href="http://www.redux.org.cn/" target="_blank" rel="noopener">http://www.redux.org.cn/</a></p>
</li>
<li><p>Github: <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">https://github.com/reactjs/redux</a></p>
</li>
</ol>
</blockquote>
<h3 id="redux是什么"><a href="#redux是什么" class="headerlink" title="redux是什么"></a>redux是什么</h3><ol>
<li><p>redux是一个专门用于做<code>状态管理的JS库</code>(不是react插件库)。</p>
</li>
<li><p>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</p>
</li>
<li><p>作用: 集中式管理react应用中多个组件<code>共享</code>的状态。</p>
</li>
</ol>
<h3 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h3><ol>
<li><p>某个组件的状态，需要让其他组件可以随时拿到（共享）。</p>
</li>
<li><p>一个组件需要改变另一个组件的状态（通信）。</p>
</li>
<li><p>总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</p>
</li>
</ol>
<h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220907154305018.png" alt="image-20220907154305018"></p>
<h3 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h3><p><strong>action</strong></p>
<ol>
<li><p><code>动作的对象</code></p>
</li>
<li><p>包含2个属性</p>
<p>type：标识属性, 值为字符串, 唯一, 必要属性</p>
<p>data：数据属性, 值类型任意, 可选属性</p>
</li>
<li><p>例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</p>
</li>
</ol>
<p><strong>reducer</strong></p>
<ol>
<li>用于初始化状态、加工状态。</li>
<li><p>加工时，根据旧的state和action， 产生新的state的<code>纯函数(以下为纯函数概念)`</code></p>
<ul>
<li><code></code>纯函数:`一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</li>
<li>必须遵守以下一些约束<br>1)   不得改写参数数据<br>2)   不会产生任何副作用，例如网络请求，输入和输出设备<br>3)   不能调用Date.now()或者Math.random()等不纯的方法 </li>
</ul>
</li>
<li><p><code>redux的reducer函数必须是一个纯函数</code></p>
</li>
</ol>
<p><strong>store</strong></p>
<ol>
<li><p>将state、action、reducer联系在一起的对象</p>
</li>
<li><p><code>如何得到此对象</code>?</p>
<ul>
<li>import {createStore} from ‘redux’</li>
<li>import reducer from ‘./reducers’<ul>
<li>const store = createStore(reducer)</li>
</ul>
</li>
</ul>
</li>
<li><p>此对象的功能?</p>
<ul>
<li><p>getState(): 得到state</p>
<ul>
<li><p>dispatch(action): 分发action, 触发reducer调用, 产生新的state</p>
</li>
<li><p>subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="redux的核心API"><a href="#redux的核心API" class="headerlink" title="redux的核心API"></a>redux的核心API</h3><p><strong>createstore()与applyMiddleware()</strong></p>
<p>createstore()作用：创建包含指定reducer的store对象</p>
<p>applyMiddleware()作用：应用上基于redux的中间件(插件库)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码示例</span><br><span class="line">---------------------------store.js 部分代码---------------------------------</span><br><span class="line">//引入createStore,专门用于创建redux中最为核心的store对象</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;</span><br><span class="line">//暴露store</span><br><span class="line">export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))</span><br></pre></td></tr></table></figure>
<p><strong>store对象</strong></p>
<ol>
<li><p>作用: redux库最核心的管理对象</p>
</li>
<li><p>它内部维护着:</p>
<ul>
<li><p>state</p>
</li>
<li><p>reducer</p>
</li>
</ul>
</li>
<li><p>核心方法:</p>
<ul>
<li><p>getState()</p>
</li>
<li><p>dispatch(action)</p>
</li>
<li><p>subscribe(listener)</p>
</li>
</ul>
</li>
<li><p>具体编码:</p>
<ul>
<li><p>store.getState()</p>
</li>
<li><p>store.dispatch({type:’INCREMENT’, number})</p>
</li>
<li><p>store.subscribe(render)</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码示例</span><br><span class="line">---------------------------store.js---------------------------------</span><br><span class="line">/**</span><br><span class="line">* 该文件撰文用于暴露一个store对象,整个应用只有一个store对象</span><br><span class="line">*/</span><br><span class="line">//引入createStore,专门用于创建redux中最为核心的store对象</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;</span><br><span class="line">//引入汇总后的reducer</span><br><span class="line">import reducer from &apos;./reducers&apos;</span><br><span class="line">//引入redux-thunk，用于支持异步action</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">//引入redux-devtools-extension</span><br><span class="line">import &#123;composeWithDevTools&#125; from &apos;redux-devtools-extension&apos;</span><br><span class="line">//暴露store</span><br><span class="line">export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))</span><br><span class="line">----------------------------index.js 引入store对象--------------------------------</span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line">import store from &apos;./redux/store&apos;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	/* 此处需要用Provider包裹App，目的是让App所有的后代容器组件都能接收到store */</span><br><span class="line">	&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">		&lt;App/&gt;</span><br><span class="line">	&lt;/Provider&gt;,</span><br><span class="line">	document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>combineReducers()</strong></p>
<p>作用：合并多个reducer函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码示例</span><br><span class="line">------------------ redux/reducers/index.js ------------------------------------</span><br><span class="line">/**</span><br><span class="line"> * 该文件用于汇总所有的reducer为一个总的reducer</span><br><span class="line"> */</span><br><span class="line">//引入combineReducers，用于汇总多个reducer</span><br><span class="line">import &#123;combineReducers&#125; from &apos;redux&apos;</span><br><span class="line">//引入为Count组件服务的reducer</span><br><span class="line">import count from &apos;./count&apos;</span><br><span class="line">import persons from &apos;./person&apos;</span><br><span class="line"></span><br><span class="line">//汇总所有的reducer变为一个总的reducer</span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">  count,persons</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="redux-异步编程"><a href="#redux-异步编程" class="headerlink" title="redux 异步编程"></a>redux 异步编程</h3><blockquote>
<ol>
<li><p>redux默认是不能进行异步处理的,</p>
</li>
<li><p>某些时候应用中需要在<code>redux</code>中执行异步任务(ajax, 定时器)</p>
</li>
</ol>
</blockquote>
<p><strong>使用异步中间件</strong></p>
<p>下载依赖<code>npm install --save redux-thunk</code></p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码示例</span><br><span class="line">---------------------------store.js---------------------------------</span><br><span class="line">/**</span><br><span class="line"> * 该文件撰文用于暴露一个store对象,整个应用只有一个store对象</span><br><span class="line"> */</span><br><span class="line">//引入createStore,专门用于创建redux中最为核心的store对象</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;</span><br><span class="line">//引入汇总后的reducer</span><br><span class="line">import reducer from &apos;./reducers&apos;</span><br><span class="line">//引入redux-thunk，用于支持异步action</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">//引入redux-devtools-extension</span><br><span class="line">import &#123;composeWithDevTools&#125; from &apos;redux-devtools-extension&apos;</span><br><span class="line">//暴露store</span><br><span class="line">export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))</span><br></pre></td></tr></table></figure>
<h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h3><blockquote>
<ol>
<li><p>一个react插件库</p>
</li>
<li><p>专门用来简化react应用中使用redux</p>
</li>
</ol>
</blockquote>
<p><strong>react-Redux将所有组件分成两大类</strong></p>
<p> <strong>1、UI组件</strong></p>
<blockquote>
<p>1)   只负责 UI 的呈现，不带有任何业务逻辑</p>
<p>2)   通过props接收数据(一般数据和函数)</p>
<p>3)   不使用任何 Redux 的 API</p>
<p>4)   一般保存在<code>components</code>文件夹下,也可以直接写在容器组件中直接加工成容器组件</p>
</blockquote>
<p><strong>2、容器组件</strong></p>
<blockquote>
<p>1)   负责管理数据和业务逻辑，不负责UI的呈现</p>
<p>2)   使用 Redux 的 API</p>
<p>3)   一般保存在<code>ontainers</code>文件夹下</p>
</blockquote>
<h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><p><strong>Provider</strong></p>
<p>作用: 让所有组件都可以得到state数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line">import store from &apos;./redux/store&apos;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	/* 此处需要用Provider包裹App，目的是让App所有的后代容器组件都能接收到store */</span><br><span class="line">	&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">		&lt;App/&gt;</span><br><span class="line">	&lt;/Provider&gt;,</span><br><span class="line">	document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong><code>connect()()</code></strong></p>
<ol>
<li><p>作用: 用于包装 UI 组件生成容器组件</p>
</li>
<li><p>使用connect(<code>mapDispatchToProps</code>,<code>mapDispatchToProps</code>)(UI组件)</p>
<p>注意点:</p>
<pre><code>1. 该方法默认传入`state`与`dispatch`
2. 可以省略`dispatch`直接传入`action`方法,该api会自动帮你调用`dispatch`
</code></pre></li>
</ol>
<p><strong>mapStateToProps</strong></p>
<p>作用:将外部的数据（即<code>state对象</code>）转换为UI组件的标签属性</p>
<p>1.mapStateToProps函数返回的是一个对象；</p>
<p>2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</p>
<p>3.mapStateToProps<code>用于传递状态</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">	return &#123;count:state&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mapDispatchToProps</strong></p>
<p>作用:将<code>分发action的函数</code>转换为UI组件的标签属性</p>
<ol>
<li>mapDispatchToProps函数返回的是一个对象；</li>
<li>返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</li>
<li>mapDispatchToProps<code>用于传递操作状态的方法</code></li>
<li>可以省略<code>dispatch</code>,直接传入<code>action</code>,api将会<code>自动调用</code>dispatch</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------------不简化代码-----------------------------------------------</span><br><span class="line">/* </span><br><span class="line">	1.mapStateToProps函数返回的是一个对象；</span><br><span class="line">	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</span><br><span class="line">	3.mapStateToProps用于传递状态</span><br><span class="line">*/</span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">	return &#123;count:state&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">	1.mapDispatchToProps函数返回的是一个对象；</span><br><span class="line">	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</span><br><span class="line">	3.mapDispatchToProps用于传递操作状态的方法</span><br><span class="line">*/</span><br><span class="line">function mapDispatchToProps(dispatch)&#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		jia:number =&gt; dispatch(createIncrementAction(number)),</span><br><span class="line">		jian:number =&gt; dispatch(createDecrementAction(number)),</span><br><span class="line">		jiaAsync:(number,time) =&gt; dispatch(createIncrementAsyncAction(number,time)),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用connect()()创建并暴露一个Count的容器组件</span><br><span class="line">export default connect(mapStateToProps,mapDispatchToProps)(CountUI)</span><br><span class="line"></span><br><span class="line">----------------下面是简化代码-----------------------------</span><br><span class="line">//使用connect()()创建并暴露一个Count的容器组件</span><br><span class="line">//使用connect(传入状态,操作状态方法)(UI组件)</span><br><span class="line">export default connect(</span><br><span class="line">state =&gt; (&#123;</span><br><span class="line">count: state.count,</span><br><span class="line">personCount: state.persons.length</span><br><span class="line">&#125;),</span><br><span class="line">&#123;increment, decrement, incrementAsync&#125;</span><br><span class="line">)(Count)</span><br></pre></td></tr></table></figure>
<h3 id="使用redux调试工具"><a href="#使用redux调试工具" class="headerlink" title="使用redux调试工具"></a>使用redux调试工具</h3><p><strong>安装chrome浏览器插件</strong></p>
<blockquote>
<p>Redux DecTools</p>
</blockquote>
<p><strong>下载工具依赖包</strong></p>
<blockquote>
<p>npm install –save-dev redux-devtools-extension</p>
</blockquote>
<p><strong>修改store.js</strong></p>
<blockquote>
<p><code>import {composeWithDevTools} from &#39;redux-devtools-extension&#39;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 该文件撰文用于暴露一个store对象,整个应用只有一个store对象</span><br><span class="line">*/</span><br><span class="line">//引入createStore,专门用于创建redux中最为核心的store对象</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;</span><br><span class="line">//引入汇总后的reducer</span><br><span class="line">import reducer from &apos;./reducers&apos;</span><br><span class="line">//引入redux-thunk，用于支持异步action</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">//引入redux-devtools-extension</span><br><span class="line">import &#123;composeWithDevTools&#125; from &apos;redux-devtools-extension&apos;</span><br><span class="line">//暴露store</span><br><span class="line">export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))</span><br></pre></td></tr></table></figure>
<h2 id="React-拓展"><a href="#React-拓展" class="headerlink" title="React 拓展"></a>React 拓展</h2><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><strong>setState更新状态的2种写法</strong></p>
<blockquote>
<p>(1). setState(stateChange, [callback])——对象式的setState<br>1.stateChange为状态改变对象(该对象可以体现出状态的更改)<br>2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</p>
<p>(2). setState(updater, [callback])——函数式的setState</p>
<ul>
<li>updater为返回stateChange对象的函数。</li>
<li>updater可以接收到state和props。</li>
<li>callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</li>
</ul>
<p>总结:<br>       1.对象式的setState是函数式的setState的简写方式(<code>语法糖</code>)<br>       2.使用原则：<br>               (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式<br>               (2).如果新状态依赖于原状态 ===&gt; 使用函数方式<br>               (3).如果需要在setState()执行后获取最新的状态数据,<br>                   要在第二个callback函数中读取</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">export default class Demo extends Component &#123;</span><br><span class="line">state = &#123; count: 0 &#125;</span><br><span class="line">add = () =&gt; &#123;</span><br><span class="line">//对象式的setState</span><br><span class="line">/* //1.获取原来的count值</span><br><span class="line">const &#123;count&#125; = this.state</span><br><span class="line">//2.更新状态</span><br><span class="line">this.setState(&#123;count:count+1&#125;,()=&gt;&#123; console.log(this.state.count); &#125;)</span><br><span class="line">//console.log(&apos;12行的输出&apos;,this.state.count); //0 */</span><br><span class="line">//函数式的setState</span><br><span class="line">this.setState(state =&gt; (&#123; count: state.count + 1 &#125;))</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;当前求和为：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;button onClick=&#123;this.add&#125;&gt;点我+1&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h3><p><strong>路由组件的lazyLoad</strong></p>
<ol>
<li>懒加载中的组件,随用随调,不会提前加载</li>
<li>使用懒加载时需要给定一个<code>fallback</code>,用于请求过慢或者请求不到组件时显示,通常为<code>组件</code>(也可以直接为一个<code>虚拟DOM</code>)</li>
<li><code>fallback</code>如果是指定为一个组件,则该组件一定不能指定为<code>懒加载组件</code>,就正常引入的那种组件即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//	import Loading from &apos;./Loading&apos; // 用于指定`fallback`</span><br><span class="line">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span><br><span class="line">	const Login = lazy(()=&gt;import(&apos;@/pages/Login&apos;))</span><br><span class="line">	//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span><br><span class="line">	&lt;Suspense fallback=&#123;&lt;h1&gt;loading.....&lt;/h1&gt;&#125;&gt;</span><br><span class="line">    //&lt;Suspense fallback=&#123;&lt;Loading/&gt;&#125;&gt;   指定为组件                 </span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path=&quot;/xxx&quot; component=&#123;Xxxx&#125;/&gt;</span><br><span class="line">            &lt;Redirect to=&quot;/login&quot;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>Hook是React 16.8.0版本增加的新特性/新语法，可以让你在函数组件中使用 state 以及其他的 React 特性</p>
<p><strong>三个常用的Hook</strong></p>
<p>useState()、useEffect()、useRef()</p>
<p><strong>State Hook</strong></p>
<p>State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作<br>语法: const [xxx, setXxx] = React.useState(initValue)<br>useState()说明:<br>   参数: 第一次初始化指定的值在内部作缓存<br>   返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数<br>setXxx()2种写法:<br>   setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值<br>   setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</p>
<p><strong>Effect Hook</strong></p>
<p> Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)**<br>React中的副作用操作:<br>   发ajax请求数据获取<br>   设置订阅 / 启动定时器<br>   手动更改真实DOM<br>语法和说明:<br>   useEffect(() =&gt; {<br>     // 在此可以执行任何带副作用操作<br>     return () =&gt; { // 在组件卸载前执行<br>       // 在此做一些收尾工作, 比如清除定时器/取消订阅等<br>     }<br>   }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</p>
<p>可以把 useEffect Hook 看做如下三个函数的组合<br>   componentDidMount()<br>   componentDidUpdate()<br>    componentWillUnmount() </p>
<p><strong>Ref Hook</strong></p>
<p>Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据<br>语法: const refContainer = useRef()<br>作用:保存标签对象,功能与React.createRef()一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myRef = React.createRef()</span><br><span class="line">	show = ()=&gt;&#123;</span><br><span class="line">		alert(this.myRef.current.value)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ol>
<li><p>作用:可以不用必须有一个真实的DOM根标签了</p>
</li>
<li><p>当你不得不使用一个<code>容器</code>去包裹dom元素–jsx语法要求,以往我们做法是直接包一层<code>div</code></p>
<ol start="3">
<li><p>使用<code>Fragment</code>后可以<code>取代div</code>,但是编译后会被react丢弃,所以不会造成没必要的层级嵌套</p>
</li>
<li><p>效果等同于直接写一个<code>空标签&lt;&gt;&lt;/&gt;</code>,但是二者有区别</p>
<p><code>区别</code>:<code>Fragment</code>可以添加<code>key</code>属性作为唯一标识,而空标签一点属性都不能加</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component,Fragment &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export default class Demo extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;Fragment key=&#123;1&#125;&gt; </span><br><span class="line">				&lt;input type=&quot;text&quot;/&gt;</span><br><span class="line">				&lt;input type=&quot;text&quot;/&gt;</span><br><span class="line">			&lt;/Fragment&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>
<p>1) 创建Context容器对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const XxxContext = React.createContext()</span><br></pre></td></tr></table></figure>
<p>​    2.渲染子组时，外面包裹<code>xxxContext.Provider</code>, 通过value属性给后代组件传递数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;xxxContext.Provider value=&#123;数据&#125;&gt;</span><br><span class="line">		子组件</span><br><span class="line"> &lt;/xxxContext.Provider&gt;</span><br></pre></td></tr></table></figure>
<p>3.后代组件读取数据：<code>两种方法</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一种方式:仅适用于类组件 </span><br><span class="line">	  static contextType = xxxContext  // 声明接收context</span><br><span class="line">	  this.context // 读取context中的value数据</span><br><span class="line"></span><br><span class="line">	//第二种方式: 函数组件与类组件都可以</span><br><span class="line">	  &lt;xxxContext.Consumer&gt;</span><br><span class="line">	    &#123;</span><br><span class="line">	      value =&gt; ( // value就是context中的value数据</span><br><span class="line">	        要显示的内容</span><br><span class="line">	      )</span><br><span class="line">	    &#125;</span><br><span class="line">	  &lt;/xxxContext.Consumer&gt;</span><br></pre></td></tr></table></figure>
<p>注意:在应用开发中<code>一般不用context</code>, 一般都用它的封装react插件</p>
<p><strong>完整例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//------------------- 完整例子 ------------------------------------------------</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import &apos;./index.css&apos;</span><br><span class="line">//创建Context对象</span><br><span class="line">const MyContext = React.createContext()</span><br><span class="line">const &#123;Provider,Consumer&#125; = MyContext</span><br><span class="line">export default class A extends Component &#123;</span><br><span class="line"></span><br><span class="line">	state = &#123;username:&apos;tom&apos;,age:18&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123;username,age&#125; = this.state</span><br><span class="line">		return (</span><br><span class="line">			&lt;div className=&quot;parent&quot;&gt;</span><br><span class="line">				&lt;h3&gt;我是A组件&lt;/h3&gt;</span><br><span class="line">				&lt;h4&gt;我的用户名是:&#123;username&#125;&lt;/h4&gt;</span><br><span class="line">				&lt;Provider value=&#123;&#123;username,age&#125;&#125;&gt;</span><br><span class="line">					&lt;B/&gt;</span><br><span class="line">				&lt;/Provider&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;div className=&quot;child&quot;&gt;</span><br><span class="line">				&lt;h3&gt;我是B组件&lt;/h3&gt;</span><br><span class="line">				&lt;C/&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* class C extends Component &#123;</span><br><span class="line">	//声明接收context</span><br><span class="line">	static contextType = MyContext</span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123;username,age&#125; = this.context</span><br><span class="line">		return (</span><br><span class="line">			&lt;div className=&quot;grand&quot;&gt;</span><br><span class="line">				&lt;h3&gt;我是C组件&lt;/h3&gt;</span><br><span class="line">				&lt;h4&gt;我从A组件接收到的用户名:&#123;username&#125;,年龄是&#123;age&#125;&lt;/h4&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">function C()&#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;div className=&quot;grand&quot;&gt;</span><br><span class="line">			&lt;h3&gt;我是C组件&lt;/h3&gt;</span><br><span class="line">			&lt;h4&gt;我从A组件接收到的用户名:</span><br><span class="line">			&lt;Consumer&gt;</span><br><span class="line">				&#123;value =&gt; `$&#123;value.username&#125;,年龄是$&#123;value.age&#125;`&#125; //也可以返回标签</span><br><span class="line">			&lt;/Consumer&gt;</span><br><span class="line">			&lt;/h4&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件优化-–PureComponent"><a href="#组件优化-–PureComponent" class="headerlink" title="组件优化 –PureComponent"></a>组件优化 –<code>PureComponent</code></h3><blockquote>
<p><strong>Ⅰ-<code>Component的2个问题</code></strong></p>
<ol>
<li>只要执行setState(),即使不改变状态数据, 组件也会重新render() ==&gt; 效率低</li>
<li>只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==&gt; 效率低</li>
</ol>
<p><strong>Ⅱ-效率高的做法:</strong></p>
<p>只有当组件的state或props数据发生改变时才重新render()</p>
<p><strong>Ⅲ-原因解析</strong></p>
<p>Component中的shouldComponentUpdate()总是返回true</p>
</blockquote>
<h4 id="优化解决"><a href="#优化解决" class="headerlink" title="优化解决"></a>优化解决</h4><blockquote>
<p>办法1:<br>   <code>重写shouldComponentUpdate()</code>方法<br>   比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false<br>办法2:<br>   使用<code>PureComponent</code><br>   PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true<br>   注意:<br>       只是进行state和props数据的<code>浅比较</code>, 如果只是数据对象内部数据变了, 返回false<br>       不要直接修改state数据, 而是要<code>产生新数据</code><br>项目中一般使用PureComponent来优化</p>
</blockquote>
<p>优化代码示例:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">state = &#123; <span class="attr">carName</span>: <span class="string">"奔驰c36"</span>, <span class="attr">stus</span>: [<span class="string">'小张'</span>, <span class="string">'小李'</span>, <span class="string">'小王'</span>] &#125;</span><br><span class="line">addStu = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/* const &#123;stus&#125; = this.state</span></span><br><span class="line"><span class="comment">stus.unshift('小刘')</span></span><br><span class="line"><span class="comment">this.setState(&#123;stus&#125;) */</span></span><br><span class="line"><span class="keyword">const</span> &#123; stus &#125; = <span class="keyword">this</span>.state</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">stus</span>: [<span class="string">'小刘'</span>, ...stus] &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeCar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//this.setState(&#123;carName:'迈巴赫'&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">this</span>.state</span><br><span class="line">obj.carName = <span class="string">'迈巴赫'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === <span class="keyword">this</span>.state);</span><br><span class="line"><span class="keyword">this</span>.setState(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* shouldComponentUpdate(nextProps,nextState)&#123;</span></span><br><span class="line"><span class="comment">// console.log(this.props,this.state); //目前的props和state</span></span><br><span class="line"><span class="comment">// console.log(nextProps,nextState); //接下要变化的目标props，目标state</span></span><br><span class="line"><span class="comment">return !this.state.carName === nextState.carName</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Parent---render'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; carName &#125; = <span class="keyword">this</span>.state</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"> &lt;div className=<span class="string">"parent"</span>&gt;</span><br><span class="line">   &lt;h3&gt;我是Parent组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">   &#123;this.state.stus&#125;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">   &lt;span&gt;我的车名字是：&#123;carName&#125;&lt;/</span>span&gt;&lt;br /&gt;</span><br><span class="line">   &lt;button onClick=&#123;<span class="keyword">this</span>.changeCar&#125;&gt;点我换车&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">   &lt;button onClick=&#123;this.addStu&#125;&gt;添加一个小刘&lt;/</span>button&gt;</span><br><span class="line">   &lt;Child carName=<span class="string">"奥拓"</span> /&gt;</span><br><span class="line"> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends PureComponent &#123;</span></span><br><span class="line"><span class="regexp">/</span>* shouldComponentUpdate(nextProps,nextState)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props,<span class="keyword">this</span>.state); <span class="comment">//目前的props和state</span></span><br><span class="line"><span class="built_in">console</span>.log(nextProps,nextState); <span class="comment">//接下要变化的目标props，目标state</span></span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.props.carName === nextProps.carName</span><br><span class="line">&#125; *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">render() &#123;</span></span><br><span class="line"><span class="regexp">console.log('Child---render');</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp"> &lt;div className="child"&gt;</span></span><br><span class="line"><span class="regexp">   &lt;h3&gt;我是Child组件&lt;/</span>h3&gt;</span><br><span class="line">   &lt;span&gt;我接到的车是：&#123;<span class="keyword">this</span>.props.carName&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="render-props-—类似vue插槽"><a href="#render-props-—类似vue插槽" class="headerlink" title="render props  —类似vue插槽"></a>render props  —类似vue插槽</h3><blockquote>
<ol>
<li>如何向组件内部动态传入带内容的结构(标签)?</li>
</ol>
<p>Vue中:<br>   使用slot技术, 也就是通过组件标签体传入结构  <a><b></b></a><br>React中:<br>   使用children props: 通过组件标签体传入结构<br>   使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性</p>
<ol start="2">
<li>children props</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;&lt;A&gt;</span><br><span class="line">&gt;&lt;B&gt;xxxx&lt;/B&gt;</span><br><span class="line">&gt;&lt;/A&gt;</span><br><span class="line">&gt;&#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">&gt;问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 </span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="3">
<li>render props</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;&lt;A render=&#123;(data) =&gt; &lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;</span><br><span class="line">&gt;A组件: &#123;<span class="keyword">this</span>.props.render(内部state数据)&#125;</span><br><span class="line">&gt;C组件: 读取A组件传入的数据显示 &#123;<span class="keyword">this</span>.props.data&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="4">
<li>示例</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">&gt;<span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line">&gt;<span class="keyword">import</span> C <span class="keyword">from</span> <span class="string">'../1_setState'</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">&gt;	render() &#123;</span><br><span class="line">&gt;		<span class="keyword">return</span> (</span><br><span class="line">&gt;			&lt;div className="parent"&gt;</span><br><span class="line">&gt;				&lt;h3&gt;我是Parent组件&lt;/h3&gt;</span><br><span class="line">&gt;				&lt;A render=&#123;(name)=&gt;&lt;C name=&#123;name&#125;/&gt;&#125;/&gt;</span><br><span class="line">&gt;			&lt;/div&gt;</span><br><span class="line">&gt;		)</span><br><span class="line">&gt;	&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">&gt;	state = &#123;<span class="attr">name</span>:<span class="string">'tom'</span>&#125;</span><br><span class="line">&gt;	render() &#123;</span><br><span class="line">&gt;		<span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">&gt;		<span class="keyword">const</span> &#123;name&#125; = <span class="keyword">this</span>.state</span><br><span class="line">&gt;		<span class="keyword">return</span> (</span><br><span class="line">&gt;			&lt;div className="a"&gt;</span><br><span class="line">&gt;				&lt;h3&gt;我是A组件&lt;/h3&gt;</span><br><span class="line">&gt;				&#123;this.props.render(name)&#125;</span><br><span class="line">&gt;			&lt;/div&gt;</span><br><span class="line">&gt;		)</span><br><span class="line">&gt;	&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">&gt;	render() &#123;</span><br><span class="line">&gt;		<span class="built_in">console</span>.log(<span class="string">'B--render'</span>);</span><br><span class="line">&gt;		<span class="keyword">return</span> (</span><br><span class="line">&gt;			&lt;div className="b"&gt;</span><br><span class="line">&gt;				&lt;h3&gt;我是B组件,&#123;this.props.name&#125;&lt;/h3&gt;</span><br><span class="line">&gt;			&lt;/div&gt;</span><br><span class="line">&gt;		)</span><br><span class="line">&gt;	&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><ol>
<li>理解：</li>
</ol>
<p>​    错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面</p>
<ol start="2">
<li>特点：</li>
</ol>
<p>​    <code>只能捕获后代组件生命周期</code>产生的错误，<code>不能捕获自己组件</code>产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<ol start="3">
<li><p>getDerivedStateFromError配合componentDidCatch</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期函数，一旦后台组件报错，就会触发</span></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="comment">// 在render之前触发</span></span><br><span class="line">    <span class="comment">// 返回新的state</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hasError: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 统计页面的错误。发送请求发送到后台去</span></span><br><span class="line">    <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码示例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    hasError: <span class="string">''</span> <span class="comment">//用于标识子组件是否产生错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当Parent的子组件出现报错时候，会触发getDerivedStateFromError调用，并携带错误信息</span></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'@@@'</span>, error);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: error &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处统计错误，反馈给服务器，用于通知编码人员进行bug的解决'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是Parent组件&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.state.hasError ? &lt;h2&gt;当前网络不稳定，稍后再试&lt;/</span>h2&gt; : &lt;Child /&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h3><blockquote>
<ol>
<li>组件间的关系：</li>
</ol>
<ul>
<li>父子组件</li>
<li>兄弟组件（非嵌套组件）</li>
<li>祖孙组件（跨级组件）</li>
</ul>
<ol start="2">
<li>几种通信方式：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;  - props：</span><br><span class="line">&gt;   <span class="number">1</span>).children props</span><br><span class="line">&gt;   (<span class="number">2</span>).render props</span><br><span class="line">&gt;</span><br><span class="line">&gt;  - 消息订阅-发布：</span><br><span class="line">&gt;   ubs-sub、event等等</span><br><span class="line">&gt;</span><br><span class="line">&gt;  - 集中式管理：</span><br><span class="line">&gt;   redux、dva等等</span><br><span class="line">&gt;</span><br><span class="line">&gt;  - conText:</span><br><span class="line">&gt;   生产者-消费者模式</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="3">
<li>比较好的搭配方式</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;  - 父子组件：props</span><br><span class="line">&gt;  - 兄弟组件：消息订阅-发布、集中式管理</span><br><span class="line">&gt;  - 祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>ts基础整理</title>
    <url>/2022/09/06/ts%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><blockquote>
<p>Typed JavaScript at Any Scale.<br>添加了类型系统的 JavaScript，适用于任何规模的项目。</p>
</blockquote><p>以上描述是官网<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-1" target="_blank" rel="noopener">[1]</a>对于 TypeScript 的定义。</p><p>它强调了 TypeScript 的两个最重要的特性——类型系统、适用于任何规模。</p><h2 id="TypeScript-的特性§"><a href="#TypeScript-的特性§" class="headerlink" title="TypeScript 的特性§"></a>TypeScript 的特性<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#typescript-的特性" target="_blank" rel="noopener">§</a></h2><a id="more"></a>


<h3 id="类型系统§"><a href="#类型系统§" class="headerlink" title="类型系统§"></a>类型系统<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#类型系统" target="_blank" rel="noopener">§</a></h3><p>从 TypeScript 的名字就可以看出来，「类型」是其最核心的特性。</p>
<p>我们知道，JavaScript 是一门非常灵活的编程语言：</p>
<ul>
<li>它没有类型约束，一个变量可能初始化时是字符串，过一会儿又被赋值为数字。</li>
<li>由于隐式类型转换的存在，有的变量的类型很难在运行前就确定。</li>
<li>基于原型的面向对象编程，使得原型上的属性或方法可以在运行时被修改。</li>
<li>函数是 JavaScript 中的一等公民<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-2" target="_blank" rel="noopener">[2]</a>，可以赋值给变量，也可以当作参数或返回值。</li>
</ul>
<p>这种灵活性就像一把双刃剑，一方面使得 JavaScript 蓬勃发展，无所不能，从 2013 年开始就一直蝉联最普遍使用的编程语言排行榜冠军<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-3" target="_blank" rel="noopener">[3]</a>；另一方面也使得它的代码质量参差不齐，维护成本高，运行时错误多。</p>
<p>而 TypeScript 的类型系统，在很大程度上弥补了 JavaScript 的缺点。</p>
<h4 id="TypeScript-是静态类型§"><a href="#TypeScript-是静态类型§" class="headerlink" title="TypeScript 是静态类型§"></a>TypeScript 是静态类型<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#typescript-是静态类型" target="_blank" rel="noopener">§</a></h4><p>类型系统按照「类型检查的时机」来分类，可以分为动态类型和静态类型。</p>
<p>动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-4" target="_blank" rel="noopener">[4]</a>，没有编译阶段，所以它是动态类型，以下这段代码在运行时才会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line">foo.split(<span class="string">' '</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: foo.split is not a function</span></span><br><span class="line"><span class="comment">// 运行时会报错（foo.split 不是一个函数），造成线上 bug</span></span><br></pre></td></tr></table></figure>
<p>静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 <strong>TypeScript 是静态类型</strong>，这段 TypeScript 代码在编译阶段就会报错了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line">foo.split(<span class="string">' '</span>);</span><br><span class="line"><span class="comment">// Property 'split' does not exist on type 'number'.</span></span><br><span class="line"><span class="comment">// 编译时会报错（数字没有 split 方法），无法通过编译</span></span><br></pre></td></tr></table></figure>
<p>你可能会奇怪，这段 TypeScript 代码看上去和 JavaScript 没有什么区别呀。</p>
<p>没错！大部分 JavaScript 代码都只需要经过少量的修改（或者完全不用修改）就变成 TypeScript 代码，这得益于 TypeScript 强大的[类型推论][]，即使不去手动声明变量 <code>foo</code> 的类型，也能在变量初始化时自动推论出它是一个 <code>number</code> 类型。</p>
<p>完整的 TypeScript 代码是这样的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">foo.split(<span class="string">' '</span>);</span><br><span class="line"><span class="comment">// Property 'split' does not exist on type 'number'.</span></span><br><span class="line"><span class="comment">// 编译时会报错（数字没有 split 方法），无法通过编译</span></span><br></pre></td></tr></table></figure>
<h4 id="TypeScript-是弱类型§"><a href="#TypeScript-是弱类型§" class="headerlink" title="TypeScript 是弱类型§"></a>TypeScript 是弱类型<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#typescript-是弱类型" target="_blank" rel="noopener">§</a></h4><p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。</p>
<p>以下这段代码不管是在 JavaScript 中还是在 TypeScript 中都是可以正常运行的，运行时数字 <code>1</code> 会被隐式类型转换为字符串 <code>&#39;1&#39;</code>，加号 <code>+</code> 被识别为字符串拼接，所以打印出结果是字符串 <code>&#39;11&#39;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">'1'</span>);</span><br><span class="line"><span class="comment">// 打印出字符串 '11'</span></span><br></pre></td></tr></table></figure>
<p>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以<strong>它们都是弱类型</strong>。</p>
<p>作为对比，Python 是强类型，以下代码会在运行时报错：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span> + <span class="string">'1'</span>)</span><br><span class="line"><span class="comment"># TypeError: unsupported operand type(s) for +: 'int' and 'str'</span></span><br></pre></td></tr></table></figure>
<p>若要修复该错误，需要进行强制类型转换：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(str(<span class="number">1</span>) + <span class="string">'1'</span>)</span><br><span class="line"><span class="comment"># 打印出字符串 '11'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>强/弱是相对的，Python 在处理整型和浮点型相加时，会将整型隐式转换为浮点型，但是这并不影响 Python 是强类型的结论，因为大部分情况下 Python 并不会进行隐式类型转换。相比而言，JavaScript 和 TypeScript 中不管加号两侧是什么类型，都可以通过隐式类型转换计算出一个结果——而不是报错——所以 JavaScript 和 TypeScript 都是弱类型。</p>
</blockquote>
<blockquote>
<p>虽然 TypeScript 不限制加号两侧的类型，但是我们可以借助 TypeScript 提供的类型系统，以及 ESLint 提供的代码检查功能，来限制加号两侧必须同为数字或同为字符串<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-5" target="_blank" rel="noopener">[5]</a>。这在一定程度上使得 TypeScript 向「强类型」更近一步了——当然，这种限制是可选的。</p>
</blockquote>
<p>这样的类型系统体现了 TypeScript 的核心设计理念<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-6" target="_blank" rel="noopener">[6]</a>：在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型系统来提高代码的可维护性，减少可能出现的 bug。</p>
<h3 id="适用于任何规模§"><a href="#适用于任何规模§" class="headerlink" title="适用于任何规模§"></a>适用于任何规模<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#适用于任何规模" target="_blank" rel="noopener">§</a></h3><p>TypeScript 非常适用于大型项目——这是显而易见的，类型系统可以为大型项目带来更高的可维护性，以及更少的 bug。</p>
<p>在中小型项目中推行 TypeScript 的最大障碍就是认为使用 TypeScript 需要写额外的代码，降低开发效率。但事实上，由于有[类型推论][]，大部分类型都不需要手动声明了。相反，TypeScript 增强了编辑器（IDE）的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。而且 TypeScript 有近百个[编译选项][]，如果你认为类型检查过于严格，那么可以通过修改编译选项来降低类型检查的标准。</p>
<p>TypeScript 还可以和 JavaScript 共存。这意味着如果你有一个使用 JavaScript 开发的旧项目，又想使用 TypeScript 的特性，那么你不需要急着把整个项目都迁移到 TypeScript，你可以使用 TypeScript 编写新文件，然后在后续更迭中逐步迁移旧文件。如果一些 JavaScript 文件的迁移成本太高，TypeScript 也提供了一个方案，可以让你在不修改 JavaScript 文件的前提下，编写一个[类型声明文件][]，实现旧项目的渐进式迁移。</p>
<p>事实上，就算你从来没学习过 TypeScript，你也可能已经在不知不觉中使用到了 TypeScript——在 VSCode 编辑器中编写 JavaScript 时，代码补全和接口提示等功能就是通过 TypeScript Language Service 实现的<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-7" target="_blank" rel="noopener">[7]</a>：</p>
<p><img src="https://ts.xcatliu.com/assets/what-is-typescript-vscode.png" alt="what-is-typescript-vscode"></p>
<p>一些第三方库原生支持了 TypeScript，在使用时就能获得代码补全了，比如 Vue 3.0<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-8" target="_blank" rel="noopener">[8]</a>：</p>
<p><img src="https://ts.xcatliu.com/assets/what-is-typescript-vue.png" alt="what-is-typescript-vue"></p>
<p>有一些第三方库原生不支持 TypeScript，但是可以通过安装社区维护的类型声明库<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-9" target="_blank" rel="noopener">[9]</a>（比如通过运行 <code>npm install --save-dev @types/react</code> 来安装 React 的类型声明库）来获得代码补全能力——不管是在 JavaScript 项目中还是在 TypeScript 中项目中都是支持的：</p>
<p><img src="https://ts.xcatliu.com/assets/what-is-typescript-react.png" alt="what-is-typescript-react"></p>
<p>由此可见，TypeScript 的发展已经深入到前端社区的方方面面了，任何规模的项目都或多或少得到了 TypeScript 的支持。</p>
<h3 id="与标准同步发展§"><a href="#与标准同步发展§" class="headerlink" title="与标准同步发展§"></a>与标准同步发展<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#与标准同步发展" target="_blank" rel="noopener">§</a></h3><p>TypeScript 的另一个重要的特性就是坚持与 ECMAScript 标准<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-10" target="_blank" rel="noopener">[10]</a>同步发展。</p>
<p>ECMAScript 是 JavaScript 核心语法的标准，自 2015 年起，每年都会发布一个新版本，包含一些新的语法。</p>
<p>一个新的语法从提案到变成正式标准，需要经历以下几个阶段：</p>
<ul>
<li>Stage 0：展示阶段，仅仅是提出了讨论、想法，尚未正式提案。</li>
<li>Stage 1：征求意见阶段，提供抽象的 API 描述，讨论可行性，关键算法等。</li>
<li>Stage 2：草案阶段，使用正式的规范语言精确描述其语法和语义。</li>
<li>Stage 3：候选人阶段，语法的设计工作已完成，需要浏览器、Node.js 等环境支持，搜集用户的反馈。</li>
<li>Stage 4：定案阶段，已准备好将其添加到正式的 ECMAScript 标准中。</li>
</ul>
<p>一个语法进入到 Stage 3 阶段后，TypeScript 就会实现它。一方面，让我们可以尽早的使用到最新的语法，帮助它进入到下一个阶段；另一方面，处于 Stage 3 阶段的语法已经比较稳定了，基本不会有语法的变更，这使得我们能够放心的使用它。</p>
<p>除了实现 ECMAScript 标准之外，TypeScript 团队也推进了诸多语法提案，比如可选链操作符（<code>?.</code>）<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-11" target="_blank" rel="noopener">[11]</a>、空值合并操作符（<code>??</code>）<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-12" target="_blank" rel="noopener">[12]</a>、Throw 表达式<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-13" target="_blank" rel="noopener">[13]</a>、正则匹配索引<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#link-14" target="_blank" rel="noopener">[14]</a>等。</p>
<h2 id="总结§"><a href="#总结§" class="headerlink" title="总结§"></a>总结<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#总结" target="_blank" rel="noopener">§</a></h2><p>什么是 TypeScript？</p>
<ul>
<li>TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。</li>
<li>TypeScript 是一门静态类型、弱类型的语言。</li>
<li>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。</li>
<li>TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。</li>
<li>TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。</li>
<li>TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。</li>
<li>TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。</li>
<li>TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。</li>
<li>TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。</li>
</ul>
<h2 id="附：TypeScript-的发展历史§"><a href="#附：TypeScript-的发展历史§" class="headerlink" title="附：TypeScript 的发展历史§"></a>附：TypeScript 的发展历史<a href="https://ts.xcatliu.com/introduction/what-is-typescript.html#附typescript-的发展历史" target="_blank" rel="noopener">§</a></h2><ul>
<li><p>2012-10：微软发布了 TypeScript 第一个版本（0.8），此前已经在微软内部开发了两年。</p>
</li>
<li><p>2014-04：TypeScript 发布了 1.0 版本。</p>
</li>
<li><p>2014-10：Angular 发布了 2.0 版本，它是一个基于 TypeScript 开发的前端框架。</p>
</li>
<li><p>2015-01：ts-loader 发布，webpack 可以编译 TypeScript 文件了。</p>
</li>
<li><p>2015-04：微软发布了 Visual Studio Code，它内置了对 TypeScript 语言的支持，它自身也是用 TypeScript 开发的。</p>
</li>
<li><p>2016-05：<code>@types/react</code> 发布，TypeScript 可以开发 React 应用了。</p>
</li>
<li><p>2016-05：<code>@types/node</code> 发布，TypeScript 可以开发 Node.js 应用了。</p>
</li>
<li><p>2016-09：TypeScript 发布了 2.0 版本。</p>
</li>
<li><p>2018-06：TypeScript 发布了 3.0 版本。</p>
</li>
<li><p>2019-02：TypeScript 宣布由官方团队来维护 typescript-eslint，以支持在 TypeScript 文件中运行 ESLint 检查。</p>
</li>
<li><p>2020-05：Deno 发布了 1.0 版本，它是一个 JavaScript 和 TypeScript 运行时。</p>
</li>
<li><p>2020-08：TypeScript 发布了 4.0 版本。</p>
</li>
<li><p>2020-09：Vue 发布了 3.0 版本，官方支持 TypeScript。</p>
</li>
</ul>
<h1 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h1><p>TypeScript 的命令行工具安装方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>以上命令会在全局环境下安装 <code>tsc</code> 命令，安装完成之后，我们就可以在任何地方执行 <code>tsc</code> 命令了。</p>
<p>编译一个 TypeScript 文件很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p>我们约定使用 TypeScript 编写的文件以 <code>.ts</code> 为后缀，用 TypeScript 编写 React 时，以 <code>.tsx</code> 为后缀。</p>
<h2 id="编辑器§"><a href="#编辑器§" class="headerlink" title="编辑器§"></a>编辑器<a href="https://ts.xcatliu.com/introduction/get-typescript.html#编辑器" target="_blank" rel="noopener">§</a></h2><p>TypeScript 最大的优势之一便是增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。</p>
<p>主流的编辑器都支持 TypeScript，这里我推荐使用 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>。</p>
<p>它是一款开源，跨终端的轻量级编辑器，内置了对 TypeScript 的支持。</p>
<p>另外它本身也是<a href="https://github.com/Microsoft/vscode/" target="_blank" rel="noopener">用 TypeScript 编写的</a>。</p>
<h1 id="Hello-TypeScript"><a href="#Hello-TypeScript" class="headerlink" title="Hello TypeScript"></a>Hello TypeScript</h1><p>我们从一个简单的例子开始。</p>
<p>将以下代码复制到 <code>hello.ts</code> 中：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p>这时候会生成一个编译好的文件 <code>hello.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>在 TypeScript 中，我们使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以。</p>
<p>上述例子中，我们用 <code>:</code> 指定 <code>person</code> 参数类型为 <code>string</code>。但是编译为 js 之后，并没有什么检查的代码被插入进来。</p>
<p>这是因为 <strong>TypeScript 只会在编译时对类型进行静态检查，如果发现有错误，编译的时候就会报错</strong>。而在运行时，与普通的 JavaScript 文件一样，不会对类型进行检查。</p>
<p>如果我们需要保证运行时的参数类型，还是得手动对类型进行判断：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> person === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'person is not a string'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>let</code> 是 ES6 中的关键字，和 <code>var</code> 类似，用于定义一个局部变量，可以参阅 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">let 和 const 命令</a>。</p>
</blockquote>
<p>下面尝试把这段代码编译一下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>编辑器中会提示错误，编译的时候也会出错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello.ts:6:22 - error TS2345: Argument of <span class="built_in">type</span> <span class="string">'number[]'</span> is not assignable to parameter of <span class="built_in">type</span> <span class="string">'string'</span>.</span><br></pre></td></tr></table></figure>
<p>但是还是生成了 js 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>这是因为 <strong>TypeScript 编译的时候即使报错了，还是会生成编译结果</strong>，我们仍然可以使用这个编译之后的文件。</p>
<p>如果要在报错的时候终止 js 文件的生成，可以在 <code>tsconfig.json</code> 中配置 <code>noEmitOnError</code> 即可。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p>
<ul>
<li><p><a href="https://ts.xcatliu.com/basics/primitive-data-types.html" target="_blank" rel="noopener">原始数据类型</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/any.html" target="_blank" rel="noopener">任意值</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/type-inference.html" target="_blank" rel="noopener">类型推论</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/union-types.html" target="_blank" rel="noopener">联合类型</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html" target="_blank" rel="noopener">对象的类型——接口</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/type-of-array.html" target="_blank" rel="noopener">数组的类型</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/type-of-function.html" target="_blank" rel="noopener">函数的类型</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/type-assertion.html" target="_blank" rel="noopener">类型断言</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html" target="_blank" rel="noopener">声明文件</a></p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/built-in-objects.html" target="_blank" rel="noopener">内置对象</a></p>
</li>
</ul>
<h1 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h1><p>JavaScript 的类型分为两种：原始数据类型（<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener">Primitive data types</a>）和对象类型（Object types）。</p>
<p>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener"><code>Symbol</code></a> 和 ES10 中的新类型 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener"><code>BigInt</code></a>。</p>
<p>本节主要介绍<strong>前五种</strong>原始数据类型在 TypeScript 中的应用。</p>
<h2 id="布尔值§"><a href="#布尔值§" class="headerlink" title="布尔值§"></a>布尔值<a href="https://ts.xcatliu.com/basics/primitive-data-types.html#布尔值" target="_blank" rel="noopener">§</a></h2><p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span></span><br></pre></td></tr></table></figure>
<p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByNewBoolean: <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'Boolean' is not assignable to type 'boolean'.</span></span><br><span class="line"><span class="comment">//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.</span></span><br></pre></td></tr></table></figure>
<p>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByNewBoolean: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByBoolean: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在 TypeScript 中，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样，不再赘述。</p>
<h2 id="数值§"><a href="#数值§" class="headerlink" title="数值§"></a>数值<a href="https://ts.xcatliu.com/basics/primitive-data-types.html#数值" target="_blank" rel="noopener">§</a></h2><p>使用 <code>number</code> 定义数值类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: <span class="built_in">number</span> = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: <span class="built_in">number</span> = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>
<p>编译结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>0b1010</code> 和 <code>0o744</code> 是 <a href="http://es6.ruanyifeng.com/#docs/number#二进制和八进制表示法" target="_blank" rel="noopener">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>
<h2 id="字符串§"><a href="#字符串§" class="headerlink" title="字符串§"></a>字符串<a href="https://ts.xcatliu.com/basics/primitive-data-types.html#字符串" target="_blank" rel="noopener">§</a></h2><p>使用 <code>string</code> 定义字符串类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: <span class="built_in">number</span> = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.</span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>
<p>编译结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">var</span> myAge = <span class="number">25</span>;</span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">var</span> sentence = <span class="string">"Hello, my name is "</span> + myName + <span class="string">".</span></span><br><span class="line"><span class="string">I'll be "</span> + (myAge + <span class="number">1</span>) + <span class="string">" years old next month."</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <figure class="highlight plain"><figcaption><span>[ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#模板字符串)，`$&#123;expr&#125;` 用来在模板字符串中嵌入表达式。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 空值[§](https://ts.xcatliu.com/basics/primitive-data-types.html#空值)</span><br><span class="line"></span><br><span class="line">JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 `void` 表示没有任何返回值的函数：</span><br><span class="line"></span><br><span class="line">```ts</span><br><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&apos;My name is Tom&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code>（只在 –strictNullChecks 未指定时）：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Null-和-Undefined§"><a href="#Null-和-Undefined§" class="headerlink" title="Null 和 Undefined§"></a>Null 和 Undefined<a href="https://ts.xcatliu.com/basics/primitive-data-types.html#null-和-undefined" target="_blank" rel="noopener">§</a></h2><p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 这样也不会报错</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = u;</span><br></pre></td></tr></table></figure>
<p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'void' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure>
<h1 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h1><p>任意值（Any）用来表示允许赋值为任意类型。</p>
<h2 id="什么是任意值类型§"><a href="#什么是任意值类型§" class="headerlink" title="什么是任意值类型§"></a>什么是任意值类型<a href="https://ts.xcatliu.com/basics/any.html#什么是任意值类型" target="_blank" rel="noopener">§</a></h2><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>
<p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<h2 id="任意值的属性和方法§"><a href="#任意值的属性和方法§" class="headerlink" title="任意值的属性和方法§"></a>任意值的属性和方法<a href="https://ts.xcatliu.com/basics/any.html#任意值的属性和方法" target="_blank" rel="noopener">§</a></h2><p>在任意值上访问任何属性都是允许的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: <span class="built_in">any</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName);</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName.firstName);</span><br></pre></td></tr></table></figure>
<p>也允许调用任何方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyThing: <span class="built_in">any</span> = <span class="string">'Tom'</span>;</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>);</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(<span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure>
<p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p>
<h2 id="未声明类型的变量§"><a href="#未声明类型的变量§" class="headerlink" title="未声明类型的变量§"></a>未声明类型的变量<a href="https://ts.xcatliu.com/basics/any.html#未声明类型的变量" target="_blank" rel="noopener">§</a></h2><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> something: <span class="built_in">any</span>;</span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>
<h1 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h1><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>
<h2 id="什么是类型推论§"><a href="#什么是类型推论§" class="headerlink" title="什么是类型推论§"></a>什么是类型推论<a href="https://ts.xcatliu.com/basics/type-inference.html#什么是类型推论" target="_blank" rel="noopener">§</a></h2><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>
<p>事实上，它等价于：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>
<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
<h2 id="简单的例子§"><a href="#简单的例子§" class="headerlink" title="简单的例子§"></a>简单的例子<a href="https://ts.xcatliu.com/basics/union-types.html#简单的例子" target="_blank" rel="noopener">§</a></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Type 'boolean' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>联合类型使用 <code>|</code> 分隔每个类型。</p>
<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p>
<h2 id="访问联合类型的属性或方法§"><a href="#访问联合类型的属性或方法§" class="headerlink" title="访问联合类型的属性或方法§"></a>访问联合类型的属性或方法<a href="https://ts.xcatliu.com/basics/union-types.html#访问联合类型的属性或方法" target="_blank" rel="noopener">§</a></h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//   Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
<h1 id="对象的类型——接口"><a href="#对象的类型——接口" class="headerlink" title="对象的类型——接口"></a>对象的类型——接口</h1><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>
<h2 id="什么是接口§"><a href="#什么是接口§" class="headerlink" title="什么是接口§"></a>什么是接口<a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html#什么是接口" target="_blank" rel="noopener">§</a></h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html#类实现接口" target="_blank" rel="noopener">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>
<h2 id="简单的例子§-1"><a href="#简单的例子§-1" class="headerlink" title="简单的例子§"></a>简单的例子<a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html#简单的例子" target="_blank" rel="noopener">§</a></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>
<p>接口一般首字母大写。<a href="https://msdn.microsoft.com/en-us/library/8bc1fexb(v=vs.71" target="_blank" rel="noopener">有的编程语言中会建议接口的名称加上 <code>I</code> 前缀</a>.aspx)。</p>
<p>定义的变量比接口少了一些属性是不允许的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Property 'age' is missing in type '&#123; name: string; &#125;'.</span></span><br></pre></td></tr></table></figure>
<p>多一些属性也是不允许的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span></span><br></pre></td></tr></table></figure>
<p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>
<h2 id="可选属性§"><a href="#可选属性§" class="headerlink" title="可选属性§"></a>可选属性<a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html#可选属性" target="_blank" rel="noopener">§</a></h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可选属性的含义是该属性可以不存在。</p>
<p>这时<strong>仍然不允许添加未定义的属性</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examples/playground/index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span></span><br></pre></td></tr></table></figure>
<h2 id="任意属性§"><a href="#任意属性§" class="headerlink" title="任意属性§"></a>任意属性<a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html#任意属性" target="_blank" rel="noopener">§</a></h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>
<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line"><span class="comment">// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Index signatures are incompatible.</span></span><br><span class="line"><span class="comment">//     Type 'string | number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="comment">//       Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>
<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>
<p>另外，在报错信息中可以看出，此时 <code>{ name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; }</code> 的类型被推断成了 <code>{ [x: string]: string | number; name: string; age: number; gender: string; }</code>，这是联合类型和接口的结合。</p>
<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="只读属性§"><a href="#只读属性§" class="headerlink" title="只读属性§"></a>只读属性<a href="https://ts.xcatliu.com/basics/type-of-object-interfaces.html#只读属性" target="_blank" rel="noopener">§</a></h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    id: <span class="number">89757</span>,</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure>
<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">89757</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.</span></span><br><span class="line"><span class="comment">// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure>
<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>
<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>
<h1 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>
<h2 id="「类型-方括号」表示法§"><a href="#「类型-方括号」表示法§" class="headerlink" title="「类型 + 方括号」表示法§"></a>「类型 + 方括号」表示法<a href="https://ts.xcatliu.com/basics/type-of-array.html#类型--方括号表示法" target="_blank" rel="noopener">§</a></h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>数组的项中<strong>不允许</strong>出现其他的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'string' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">fibonacci.push(<span class="string">'8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type '"8"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p>
<h2 id="数组泛型§"><a href="#数组泛型§" class="headerlink" title="数组泛型§"></a>数组泛型<a href="https://ts.xcatliu.com/basics/type-of-array.html#数组泛型" target="_blank" rel="noopener">§</a></h2><p>我们也可以使用数组泛型（Array Generic） <code>Array&lt;elemType&gt;</code> 来表示数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>关于泛型，可以参考<a href="https://ts.xcatliu.com/advanced/generics.html" target="_blank" rel="noopener">泛型</a>一章。</p>
<h2 id="用接口表示数组§"><a href="#用接口表示数组§" class="headerlink" title="用接口表示数组§"></a>用接口表示数组<a href="https://ts.xcatliu.com/basics/type-of-array.html#用接口表示数组" target="_blank" rel="noopener">§</a></h2><p>接口也可以用来描述数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>
<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>
<p>不过有一种情况例外，那就是它常用来表示类数组。</p>
<h2 id="类数组§"><a href="#类数组§" class="headerlink" title="类数组§"></a>类数组<a href="https://ts.xcatliu.com/basics/type-of-array.html#类数组" target="_blank" rel="noopener">§</a></h2><p>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">number</span>[] = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.</span></span><br></pre></td></tr></table></figure>
<p>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: &#123;</span><br><span class="line">        [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">        length: <span class="built_in">number</span>;</span><br><span class="line">        callee: <span class="built_in">Function</span>;</span><br><span class="line">    &#125; = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>
<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IArguments &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    callee: <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于内置对象，可以参考<a href="https://ts.xcatliu.com/basics/built-in-objects.html" target="_blank" rel="noopener">内置对象</a>一章。</p>
<h2 id="any-在数组中的应用§"><a href="#any-在数组中的应用§" class="headerlink" title="any 在数组中的应用§"></a>any 在数组中的应用<a href="https://ts.xcatliu.com/basics/type-of-array.html#any-在数组中的应用" target="_blank" rel="noopener">§</a></h2><p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'xcatliu'</span>, <span class="number">25</span>, &#123; website: <span class="string">'http://xcatliu.com'</span> &#125;];</span><br></pre></td></tr></table></figure>
<h1 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h1><blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html" target="_blank" rel="noopener">函数是 JavaScript 中的一等公民</a></p>
</blockquote>
<h2 id="函数声明§"><a href="#函数声明§" class="headerlink" title="函数声明§"></a>函数声明<a href="https://ts.xcatliu.com/basics/type-of-function.html#函数声明" target="_blank" rel="noopener">§</a></h2><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明（Function Declaration）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式（Function Expression）</span></span><br><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br></pre></td></tr></table></figure>
<h2 id="函数表达式§"><a href="#函数表达式§" class="headerlink" title="函数表达式§"></a>函数表达式<a href="https://ts.xcatliu.com/basics/type-of-function.html#函数表达式" target="_blank" rel="noopener">§</a></h2><p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>
<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
<p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#箭头函数" target="_blank" rel="noopener">ES6 中的箭头函数</a>。</p>
<h2 id="用接口定义函数的形状§"><a href="#用接口定义函数的形状§" class="headerlink" title="用接口定义函数的形状§"></a>用接口定义函数的形状<a href="https://ts.xcatliu.com/basics/type-of-function.html#用接口定义函数的形状" target="_blank" rel="noopener">§</a></h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>
<h2 id="可选参数§"><a href="#可选参数§" class="headerlink" title="可选参数§"></a>可选参数<a href="https://ts.xcatliu.com/basics/type-of-function.html#可选参数" target="_blank" rel="noopener">§</a></h2><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="literal">undefined</span>, <span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure>
<h2 id="参数默认值§"><a href="#参数默认值§" class="headerlink" title="参数默认值§"></a>参数默认值<a href="https://ts.xcatliu.com/basics/type-of-function.html#参数默认值" target="_blank" rel="noopener">§</a></h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = 'Cat'</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>
<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = 'Tom', lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> cat = buildName(<span class="literal">undefined</span>, <span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于默认参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#函数参数的默认值" target="_blank" rel="noopener">ES6 中函数参数的默认值</a>。</p>
</blockquote>
<h2 id="剩余参数§"><a href="#剩余参数§" class="headerlink" title="剩余参数§"></a>剩余参数<a href="https://ts.xcatliu.com/basics/type-of-function.html#剩余参数" target="_blank" rel="noopener">§</a></h2><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: any[] = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest参数" target="_blank" rel="noopener">ES6 中的 rest 参数</a>。</p>
<h2 id="重载§"><a href="#重载§" class="headerlink" title="重载§"></a>重载<a href="https://ts.xcatliu.com/basics/type-of-function.html#重载" target="_blank" rel="noopener">§</a></h2><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p>
<p>利用联合类型，我们可以这么实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p>
<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>
<p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p>
<h2 id="语法§"><a href="#语法§" class="headerlink" title="语法§"></a>语法<a href="https://ts.xcatliu.com/basics/type-assertion.html#语法" target="_blank" rel="noopener">§</a></h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">值 <span class="keyword">as</span> 类型</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br></pre></td></tr></table></figure>
<p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 <code>值 as 类型</code>。</p>
<p>形如 <code>&lt;Foo&gt;</code> 的语法在 tsx 中表示的是一个 <code>ReactNode</code>，在 ts 中除了表示类型断言之外，也可能是表示一个<a href="https://ts.xcatliu.com/advanced/generics.html" target="_blank" rel="noopener">泛型</a>。</p>
<p>故建议大家在使用类型断言时，统一使用 <code>值 as 类型</code> 这样的语法，本书中也会贯彻这一思想。</p>
<h2 id="类型断言的用途§"><a href="#类型断言的用途§" class="headerlink" title="类型断言的用途§"></a>类型断言的用途<a href="https://ts.xcatliu.com/basics/type-assertion.html#类型断言的用途" target="_blank" rel="noopener">§</a></h2><p>类型断言的常见用途有以下几种：</p>
<h3 id="将一个联合类型断言为其中一个类型§"><a href="#将一个联合类型断言为其中一个类型§" class="headerlink" title="将一个联合类型断言为其中一个类型§"></a>将一个联合类型断言为其中一个类型<a href="https://ts.xcatliu.com/basics/type-assertion.html#将一个联合类型断言为其中一个类型" target="_blank" rel="noopener">§</a></h3><p><a href="https://ts.xcatliu.com/basics/union-types.html#访问联合类型的属性或方法" target="_blank" rel="noopener">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">animal: Cat | Fish</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">animal: Cat | Fish</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> animal.swim === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:11:23 - error TS2339: Property 'swim' does not exist on type 'Cat | Fish'.</span></span><br><span class="line"><span class="comment">//   Property 'swim' does not exist on type 'Cat'.</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>
<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">animal: Cat | Fish</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (animal <span class="keyword">as</span> Fish).swim === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p>
<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swim</span>(<span class="params">animal: Cat | Fish</span>) </span>&#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Fish).swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom: Cat = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    run() &#123; <span class="built_in">console</span>.log(<span class="string">'run'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line">swim(tom);</span><br><span class="line"><span class="comment">// Uncaught TypeError: animal.swim is not a function`</span></span><br></pre></td></tr></table></figure>
<p>上面的例子编译时不会报错，但在运行时会报错：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: animal.swim is <span class="literal">not</span> a function`</span><br></pre></td></tr></table></figure>
<p>原因是 <code>(animal as Fish).swim()</code> 这段代码隐藏了 <code>animal</code> 可能为 <code>Cat</code> 的情况，将 <code>animal</code> 直接断言为 <code>Fish</code> 了，而 TypeScript 编译器信任了我们的断言，故在调用 <code>swim()</code> 时没有编译错误。</p>
<p>可是 <code>swim</code> 函数接受的参数是 <code>Cat | Fish</code>，一旦传入的参数是 <code>Cat</code> 类型的变量，由于 <code>Cat</code> 上没有 <code>swim</code> 方法，就会导致运行时错误了。</p>
<p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p>
<h3 id="将一个父类断言为更加具体的子类§"><a href="#将一个父类断言为更加具体的子类§" class="headerlink" title="将一个父类断言为更加具体的子类§"></a>将一个父类断言为更加具体的子类<a href="https://ts.xcatliu.com/basics/type-assertion.html#将一个父类断言为更加具体的子类" target="_blank" rel="noopener">§</a></h3><p>当类之间有继承关系时，类型断言也是很常见的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ApiError <span class="keyword">extends</span> <span class="built_in">Error</span> &#123;</span><br><span class="line">    code: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> HttpError <span class="keyword">extends</span> <span class="built_in">Error</span> &#123;</span><br><span class="line">    statusCode: <span class="built_in">number</span> = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (error <span class="keyword">as</span> ApiError).code === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们声明了函数 <code>isApiError</code>，它用来判断传入的参数是不是 <code>ApiError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比较抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>
<p>但是由于父类 <code>Error</code> 中没有 <code>code</code> 属性，故直接获取 <code>error.code</code> 会报错，需要使用类型断言获取 <code>(error as ApiError).code</code>。</p>
<p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>ApiError</code>，那就是使用 <code>instanceof</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ApiError <span class="keyword">extends</span> <span class="built_in">Error</span> &#123;</span><br><span class="line">    code: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> HttpError <span class="keyword">extends</span> <span class="built_in">Error</span> &#123;</span><br><span class="line">    statusCode: <span class="built_in">number</span> = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> ApiError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>ApiError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p>
<p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ApiError <span class="keyword">extends</span> Error &#123;</span><br><span class="line">    code: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> HttpError <span class="keyword">extends</span> Error &#123;</span><br><span class="line">    statusCode: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> ApiError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:9:26 - error TS2693: 'ApiError' only refers to a type, but is being used as a value here.</span></span><br></pre></td></tr></table></figure>
<p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code> 了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ApiError <span class="keyword">extends</span> Error &#123;</span><br><span class="line">    code: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> HttpError <span class="keyword">extends</span> Error &#123;</span><br><span class="line">    statusCode: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (error <span class="keyword">as</span> ApiError).code === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将任何一个类型断言为-any§"><a href="#将任何一个类型断言为-any§" class="headerlink" title="将任何一个类型断言为 any§"></a>将任何一个类型断言为 <code>any</code><a href="https://ts.xcatliu.com/basics/type-assertion.html#将任何一个类型断言为-any" target="_blank" rel="noopener">§</a></h3><p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p>
<p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">foo.length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:2:5 - error TS2339: Property 'length' does not exist on type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p>
<p>这种错误提示显然是非常有用的。</p>
<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window &amp; typeof globalThis'.</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p>
<p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p>
<p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p>
<p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p>
<p>上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 <code>foo</code> 属性，<code>as any</code> 会更加方便。</p>
<p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" target="_blank" rel="noopener">TypeScript 的设计理念</a>之一），才能发挥出 TypeScript 最大的价值。</p>
<h3 id="将-any-断言为一个具体的类型§"><a href="#将-any-断言为一个具体的类型§" class="headerlink" title="将 any 断言为一个具体的类型§"></a>将 <code>any</code> 断言为一个具体的类型<a href="https://ts.xcatliu.com/basics/type-assertion.html#将-any-断言为一个具体的类型" target="_blank" rel="noopener">§</a></h3><p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p>
<p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p>
<p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p>
<p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).cache[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).cache[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = getCacheData(<span class="string">'tom'</span>) <span class="keyword">as</span> Cat;</span><br><span class="line">tom.run();</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们调用完 <code>getCacheData</code> 之后，立即将它断言为 <code>Cat</code> 类型。这样的话明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的访问时就有了代码补全，提高了代码的可维护性。</p>
<h2 id="类型断言的限制§"><a href="#类型断言的限制§" class="headerlink" title="类型断言的限制§"></a>类型断言的限制<a href="https://ts.xcatliu.com/basics/type-assertion.html#类型断言的限制" target="_blank" rel="noopener">§</a></h2><blockquote>
<p>本小节的前置知识点：[结构类型系统（TODO）][]、[类型兼容性（TODO）][]</p>
</blockquote>
<p>从上面的例子中，我们可以总结出：</p>
<ul>
<li>联合类型可以被断言为其中一个类型</li>
<li>父类可以被断言为子类</li>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
</ul>
<p>那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？</p>
<p>答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。</p>
<p>具体来说，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>
<p>下面我们通过一个简化的例子，来理解类型断言的限制：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Cat = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    run: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'run'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> animal: Animal = tom;</span><br></pre></td></tr></table></figure>
<p>我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p>
<p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。TypeScript 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 <code>Cat extends Animal</code> 是等价的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。</p>
<p>我们把它换成 TypeScript 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p>
<p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以互相进行类型断言了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAnimal</span>(<span class="params">animal: Animal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (animal <span class="keyword">as</span> Cat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCat</span>(<span class="params">cat: Cat</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (cat <span class="keyword">as</span> Animal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的设计其实也很容易就能理解：</p>
<ul>
<li>允许 <code>animal as Cat</code> 是因为「父类可以被断言为子类」，这个前面已经学习过了</li>
<li>允许 <code>cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li>
</ul>
<p>需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。</p>
<p>总之，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>
<p>同理，若 <code>B</code> 兼容 <code>A</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>
<p>所以这也可以换一种说法：</p>
<p>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。</p>
<p>综上所述：</p>
<ul>
<li>联合类型可以被断言为其中一个类型</li>
<li>父类可以被断言为子类</li>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
<li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可</li>
</ul>
<p>其实前四种情况都是最后一个的特例。</p>
<h2 id="双重断言§"><a href="#双重断言§" class="headerlink" title="双重断言§"></a>双重断言<a href="https://ts.xcatliu.com/basics/type-assertion.html#双重断言" target="_blank" rel="noopener">§</a></h2><p>既然：</p>
<ul>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
</ul>
<p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testCat</span>(<span class="params">cat: Cat</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (cat <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> Fish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 互相都不兼容。</p>
<p>但是若使用双重断言，则可以打破「要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可」的限制，将任何一个类型断言为任何另一个类型。</p>
<p>若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。</p>
<p><strong>除非迫不得已，千万别用双重断言。</strong></p>
<h2 id="类型断言-vs-类型转换§"><a href="#类型断言-vs-类型转换§" class="headerlink" title="类型断言 vs 类型转换§"></a>类型断言 vs 类型转换<a href="https://ts.xcatliu.com/basics/type-assertion.html#类型断言-vs-类型转换" target="_blank" rel="noopener">§</a></h2><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toBoolean(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 1</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toBoolean(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 1</span></span><br></pre></td></tr></table></figure>
<p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p>
<p>若要进行类型转换，需要直接调用类型转换的方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBoolean</span>(<span class="params">something: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Boolean</span>(something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toBoolean(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 true</span></span><br></pre></td></tr></table></figure>
<h2 id="类型断言-vs-类型声明§"><a href="#类型断言-vs-类型声明§" class="headerlink" title="类型断言 vs 类型声明§"></a>类型断言 vs 类型声明<a href="https://ts.xcatliu.com/basics/type-assertion.html#类型断言-vs-类型声明" target="_blank" rel="noopener">§</a></h2><p>在这个例子中：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).cache[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = getCacheData(<span class="string">'tom'</span>) <span class="keyword">as</span> Cat;</span><br><span class="line">tom.run();</span><br></pre></td></tr></table></figure>
<p>我们使用 <code>as Cat</code> 将 <code>any</code> 类型断言为了 <code>Cat</code> 类型。</p>
<p>但实际上还有其他方式可以解决这个问题：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).cache[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom: Cat = getCacheData(<span class="string">'tom'</span>);</span><br><span class="line">tom.run();</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 声明为 <code>Cat</code>，然后再将 <code>any</code> 类型的 <code>getCacheData(&#39;tom&#39;)</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p>
<p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——<code>tom</code> 在接下来的代码中都变成了 <code>Cat</code> 类型。</p>
<p>它们的区别，可以通过这个例子来理解：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal: Animal = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tom = animal <span class="keyword">as</span> Cat;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>animal</code> 断言为 <code>Cat</code> 赋值给 <code>tom</code>。</p>
<p>但是若直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal: Animal = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tom: Cat = animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:12:5 - error TS2741: Property 'run' is missing in type 'Animal' but required in type 'Cat'.</span></span><br></pre></td></tr></table></figure>
<p>则会报错，不允许将 <code>animal</code> 赋值为 <code>Cat</code> 类型的 <code>tom</code>。</p>
<p>这很容易理解，<code>Animal</code> 可以看作是 <code>Cat</code> 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p>
<p>深入的讲，它们的核心区别就在于：</p>
<ul>
<li><code>animal</code> 断言为 <code>Cat</code>，只需要满足 <code>Animal</code> 兼容 <code>Cat</code> 或 <code>Cat</code> 兼容 <code>Animal</code> 即可</li>
<li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行</li>
</ul>
<p>但是 <code>Cat</code> 并不兼容 <code>Animal</code>。</p>
<p>而在前一个例子中，由于 <code>getCacheData(&#39;tom&#39;)</code> 是 <code>any</code> 类型，<code>any</code> 兼容 <code>Cat</code>，<code>Cat</code> 也兼容 <code>any</code>，故</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tom = getCacheData(<span class="string">'tom'</span>) <span class="keyword">as</span> Cat;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tom: Cat = getCacheData(<span class="string">'tom'</span>);</span><br></pre></td></tr></table></figure>
<p>知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。</p>
<p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加优雅。</p>
<h2 id="类型断言-vs-泛型§"><a href="#类型断言-vs-泛型§" class="headerlink" title="类型断言 vs 泛型§"></a>类型断言 vs 泛型<a href="https://ts.xcatliu.com/basics/type-assertion.html#类型断言-vs-泛型" target="_blank" rel="noopener">§</a></h2><blockquote>
<p>本小节的前置知识点：<a href="https://ts.xcatliu.com/advanced/generics.html" target="_blank" rel="noopener">泛型</a></p>
</blockquote>
<p>还是这个例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).cache[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = getCacheData(<span class="string">'tom'</span>) <span class="keyword">as</span> Cat;</span><br><span class="line">tom.run();</span><br></pre></td></tr></table></figure>
<p>我们还有第三种方式可以解决这个问题，那就是泛型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>&lt;<span class="title">T</span>&gt;(<span class="params">key: <span class="built_in">string</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).cache[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = getCacheData&lt;Cat&gt;(<span class="string">'tom'</span>);</span><br><span class="line">tom.run();</span><br></pre></td></tr></table></figure>
<p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p>
<h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h1><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>
<h2 id="新语法索引§"><a href="#新语法索引§" class="headerlink" title="新语法索引§"></a>新语法索引<a href="https://ts.xcatliu.com/basics/declaration-files.html#新语法索引" target="_blank" rel="noopener">§</a></h2><p>由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：</p>
<ul>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-var" target="_blank" rel="noopener"><code>declare var</code></a> 声明全局变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-function" target="_blank" rel="noopener"><code>declare function</code></a> 声明全局方法</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-class" target="_blank" rel="noopener"><code>declare class</code></a> 声明全局类</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-enum" target="_blank" rel="noopener"><code>declare enum</code></a> 声明全局枚举类型</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-namespace" target="_blank" rel="noopener"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#interface-和-type" target="_blank" rel="noopener"><code>interface</code> 和 <code>type</code></a> 声明全局类型</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export" target="_blank" rel="noopener"><code>export</code></a> 导出变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-namespace" target="_blank" rel="noopener"><code>export namespace</code></a> 导出（含有子属性的）对象</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-default" target="_blank" rel="noopener"><code>export default</code></a> ES6 默认导出</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-1" target="_blank" rel="noopener"><code>export =</code></a> commonjs 导出模块</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-as-namespace" target="_blank" rel="noopener"><code>export as namespace</code></a> UMD 库声明全局变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-global" target="_blank" rel="noopener"><code>declare global</code></a> 扩展全局变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-module" target="_blank" rel="noopener"><code>declare module</code></a> 扩展模块</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#san-xie-xian-zhi-ling" target="_blank" rel="noopener"><code>///</code></a> 三斜线指令</li>
</ul>
<h2 id="什么是声明语句§"><a href="#什么是声明语句§" class="headerlink" title="什么是声明语句§"></a>什么是声明语句<a href="https://ts.xcatliu.com/basics/declaration-files.html#什么是声明语句" target="_blank" rel="noopener">§</a></h2><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p>
<p>我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure>
<p>但是在 ts 中，编译器并不知道 <code>$</code> 或 <code>jQuery</code> 是什么东西<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery" target="_blank" rel="noopener">1</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// ERROR: Cannot find name 'jQuery'.</span></span><br></pre></td></tr></table></figure>
<p>这时，我们需要使用 <code>declare var</code> 来定义它的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var" target="_blank" rel="noopener">2</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure>
<p>上例中，<code>declare var</code> 并没有真的定义一个变量，只是定义了全局变量 <code>jQuery</code> 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure>
<p>除了 <code>declare var</code> 之外，还有其他很多种声明语句，将会在后面详细介绍。</p>
<h2 id="什么是声明文件§"><a href="#什么是声明文件§" class="headerlink" title="什么是声明文件§"></a>什么是声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#什么是声明文件" target="_blank" rel="noopener">§</a></h2><p>通常我们会把声明语句放到一个单独的文件（<code>jQuery.d.ts</code>）中，这就是声明文件<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts" target="_blank" rel="noopener">3</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure>
<p>声明文件必需以 <code>.d.ts</code> 为后缀。</p>
<p>一般来说，ts 会解析项目中所有的 <code>*.ts</code> 文件，当然也包含以 <code>.d.ts</code> 结尾的文件。所以当我们将 <code>jQuery.d.ts</code> 放到项目中时，其他所有 <code>*.ts</code> 文件就都可以获得 <code>jQuery</code> 的类型定义了。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  ├── index.ts</span><br><span class="line">|  └── jQuery.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<p>这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。</p>
<h3 id="第三方声明文件§"><a href="#第三方声明文件§" class="headerlink" title="第三方声明文件§"></a>第三方声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#第三方声明文件" target="_blank" rel="noopener">§</a></h3><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts" target="_blank" rel="noopener">jQuery in DefinitelyTyped</a>。</p>
<p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p>
<p><code>@types</code> 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>
<p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件。</p>
<h2 id="书写声明文件§"><a href="#书写声明文件§" class="headerlink" title="书写声明文件§"></a>书写声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#书写声明文件" target="_blank" rel="noopener">§</a></h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p>
<p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p>
<p>库的使用场景主要有以下几种：</p>
<ul>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#quan-ju-bian-liang" target="_blank" rel="noopener">全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#npm-bao" target="_blank" rel="noopener">npm 包</a>：通过 <code>import foo from &#39;foo&#39;</code> 导入，符合 ES6 模块规范</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#umd-ku" target="_blank" rel="noopener">UMD 库</a>：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#zhi-jie-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">直接扩展全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">在 npm 包或 UMD 库中扩展全局变量</a>：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#mo-kuai-cha-jian" target="_blank" rel="noopener">模块插件</a>：通过 <code>&lt;script&gt;</code> 或 <code>import</code> 导入后，改变另一个模块的结构</li>
</ul>
<h3 id="全局变量§"><a href="#全局变量§" class="headerlink" title="全局变量§"></a>全局变量<a href="https://ts.xcatliu.com/basics/declaration-files.html#全局变量" target="_blank" rel="noopener">§</a></h3><p>全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 <code>$</code> 和 <code>jQuery</code>。</p>
<p>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 <code>src</code> 目录下（或者对应的源码目录下）：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  ├── index.ts</span><br><span class="line">|  └── jQuery.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<p>全局变量的声明文件主要有以下几种语法：</p>
<ul>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-var" target="_blank" rel="noopener"><code>declare var</code></a> 声明全局变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-function" target="_blank" rel="noopener"><code>declare function</code></a> 声明全局方法</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-class" target="_blank" rel="noopener"><code>declare class</code></a> 声明全局类</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-enum" target="_blank" rel="noopener"><code>declare enum</code></a> 声明全局枚举类型</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-namespace" target="_blank" rel="noopener"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#interface-he-type" target="_blank" rel="noopener"><code>interface</code> 和 <code>type</code></a> 声明全局类型</li>
</ul>
<h4 id="declare-var§"><a href="#declare-var§" class="headerlink" title="declare var§"></a><code>declare var</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-var" target="_blank" rel="noopener">§</a></h4><p>在所有的声明语句中，<code>declare var</code> 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 <code>declare let</code> 和 <code>declare const</code>，使用 <code>let</code> 与使用 <code>var</code> 没有什么区别：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量</span></span><br><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而当我们使用 <code>const</code> 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/04-declare-const-jquery" target="_blank" rel="noopener">4</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line"><span class="comment">// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量</span></span><br><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure>
<p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 <code>const</code> 而不是 <code>var</code> 或 <code>let</code>。</p>
<p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value" target="_blank" rel="noopener">5</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ERROR: An implementation cannot be declared in ambient contexts.</span></span><br></pre></td></tr></table></figure>
<h4 id="declare-function§"><a href="#declare-function§" class="headerlink" title="declare function§"></a><code>declare function</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-function" target="_blank" rel="noopener">§</a></h4><p><code>declare function</code> 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 <code>function</code> 来定义：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br></pre></td></tr></table></figure>
<p>在函数类型的声明语句中，函数重载也是支持的<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function" target="_blank" rel="noopener">6</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">domReadyCallback: () =&gt; <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Dom Ready!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="declare-class§"><a href="#declare-class§" class="headerlink" title="declare class§"></a><code>declare class</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-class" target="_blank" rel="noopener">§</a></h4><p>当全局变量是一个类的时候，我们用 <code>declare class</code> 来定义它的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/07-declare-class" target="_blank" rel="noopener">7</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/Animal.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，<code>declare class</code> 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 <code>sayHi</code> 方法的具体实现则会报错：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/Animal.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ERROR: An implementation cannot be declared in ambient contexts.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="declare-enum§"><a href="#declare-enum§" class="headerlink" title="declare enum§"></a><code>declare enum</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-enum" target="_blank" rel="noopener">§</a></h4><p>使用 <code>declare enum</code> 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/08-declare-enum" target="_blank" rel="noopener">8</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/Directions.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>
<p>与其他全局变量的类型声明一致，<code>declare enum</code> 仅用来定义类型，而不是具体的值。</p>
<p><code>Directions.d.ts</code> 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>
<p>其中 <code>Directions</code> 是由第三方库定义好的全局变量。</p>
<h4 id="declare-namespace§"><a href="#declare-namespace§" class="headerlink" title="declare namespace§"></a><code>declare namespace</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-namespace" target="_blank" rel="noopener">§</a></h4><p><code>namespace</code> 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。</p>
<p>由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 <code>module</code> 关键字表示内部模块。但由于后来 ES6 也使用了 <code>module</code> 关键字，ts 为了兼容 ES6，使用 <code>namespace</code> 替代了自己的 <code>module</code>，更名为命名空间。</p>
<p>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 <code>namespace</code>，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 <code>namespace</code> 的使用了。</p>
<p><code>namespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p>
<p>比如 <code>jQuery</code> 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br></pre></td></tr></table></figure>
<p>注意，在 <code>declare namespace</code> 内部，我们直接使用 <code>function ajax</code> 来声明函数，而不是使用 <code>declare function ajax</code>。类似的，也可以使用 <code>const</code>, <code>class</code>, <code>enum</code> 等语句<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace" target="_blank" rel="noopener">9</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="keyword">const</span> version: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">class</span> Event &#123;</span><br><span class="line">        blur(eventType: EventType): <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> EventType &#123;</span><br><span class="line">        CustomClick</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jQuery.version);</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> jQuery.Event();</span><br><span class="line">e.blur(jQuery.EventType.CustomClick);</span><br></pre></td></tr></table></figure>
<h5 id="嵌套的命名空间§"><a href="#嵌套的命名空间§" class="headerlink" title="嵌套的命名空间§"></a>嵌套的命名空间<a href="https://ts.xcatliu.com/basics/declaration-files.html#嵌套的命名空间" target="_blank" rel="noopener">§</a></h5><p>如果对象拥有深层的层级，则需要用嵌套的 <code>namespace</code> 来声明深层的属性的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting" target="_blank" rel="noopener">10</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">object: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    check: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.checked = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>假如 <code>jQuery</code> 下仅有 <code>fn</code> 这一个属性（没有 <code>ajax</code> 等其他属性或方法），则可以不需要嵌套 <code>namespace</code><a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/11-declare-namespace-dot" target="_blank" rel="noopener">11</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery.fn &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">object: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    check: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.checked = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="interface-和-type§"><a href="#interface-和-type§" class="headerlink" title="interface 和 type§"></a><code>interface</code> 和 <code>type</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#interface-和-type" target="_blank" rel="noopener">§</a></h4><p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 <code>interface</code> 或 <code>type</code> 来声明一个全局的接口或类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/12-interface" target="_blank" rel="noopener">12</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> AjaxSettings &#123;</span><br><span class="line">    method?: <span class="string">'GET'</span> | <span class="string">'POST'</span></span><br><span class="line">    data?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: AjaxSettings</span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，在其他文件中也可以使用这个接口或类型了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> settings: AjaxSettings = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(<span class="string">'/api/post_something'</span>, settings);</span><br></pre></td></tr></table></figure>
<p><code>type</code> 与 <code>interface</code> 类似，不再赘述。</p>
<h5 id="防止命名冲突§"><a href="#防止命名冲突§" class="headerlink" title="防止命名冲突§"></a>防止命名冲突<a href="https://ts.xcatliu.com/basics/declaration-files.html#防止命名冲突" target="_blank" rel="noopener">§</a></h5><p>暴露在最外层的 <code>interface</code> 或 <code>type</code> 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 <code>namespace</code> 下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/13-avoid-name-conflict" target="_blank" rel="noopener">13</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">interface</span> AjaxSettings &#123;</span><br><span class="line">        method?: <span class="string">'GET'</span> | <span class="string">'POST'</span></span><br><span class="line">        data?: <span class="built_in">any</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: AjaxSettings</span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在使用这个 <code>interface</code> 的时候，也应该加上 <code>jQuery</code> 前缀：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> settings: jQuery.AjaxSettings = &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(<span class="string">'/api/post_something'</span>, settings);</span><br></pre></td></tr></table></figure>
<h4 id="声明合并§"><a href="#声明合并§" class="headerlink" title="声明合并§"></a>声明合并<a href="https://ts.xcatliu.com/basics/declaration-files.html#声明合并" target="_blank" rel="noopener">§</a></h4><p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery(&#39;#foo&#39;)</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/14-declaration-merging" target="_blank" rel="noopener">14</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>);</span><br><span class="line">jQuery.ajax(<span class="string">'/api/get_something'</span>);</span><br></pre></td></tr></table></figure>
<p>关于声明合并的更多用法，可以查看<a href="https://ts.xcatliu.com/advanced/declaration-merging.html" target="_blank" rel="noopener">声明合并</a>章节。</p>
<h3 id="npm-包§"><a href="#npm-包§" class="headerlink" title="npm 包§"></a>npm 包<a href="https://ts.xcatliu.com/basics/declaration-files.html#npm-包" target="_blank" rel="noopener">§</a></h3><p>一般我们通过 <code>import foo from &#39;foo&#39;</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p>
<p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p>
<ol>
<li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li>
<li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li>
</ol>
<p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>
<ol>
<li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li>
<li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li>
</ol>
<p>目录结构：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── types</span><br><span class="line">|  └── foo</span><br><span class="line">|     └── index.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p><code>tsconfig.json</code> 内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">        <span class="attr">"paths"</span>: &#123;</span><br><span class="line">            <span class="attr">"*"</span>: [<span class="string">"types/*"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p>
<p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p>
<p>不管采用了以上两种方式中的哪一种，我都<strong>强烈建议</strong>大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 <code>@types</code> 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p>
<p>npm 包的声明文件主要有以下几种语法：</p>
<ul>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export" target="_blank" rel="noopener"><code>export</code></a> 导出变量</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-namespace" target="_blank" rel="noopener"><code>export namespace</code></a> 导出（含有子属性的）对象</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-default" target="_blank" rel="noopener"><code>export default</code></a> ES6 默认导出</li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-1" target="_blank" rel="noopener"><code>export =</code></a> commonjs 导出模块</li>
</ul>
<h4 id="export§"><a href="#export§" class="headerlink" title="export§"></a><code>export</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#export" target="_blank" rel="noopener">§</a></h4><p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code> 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p>
<p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export" target="_blank" rel="noopener">15</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123;</span><br><span class="line">    data: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的导入和使用模块应该是这样：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; name, getName, Animal, Directions, Options &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="keyword">let</span> myName = getName();</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line"><span class="keyword">let</span> options: Options = &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="混用-declare-和-export§"><a href="#混用-declare-和-export§" class="headerlink" title="混用 declare 和 export§"></a>混用 <code>declare</code> 和 <code>export</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#混用-declare-和-export" target="_blank" rel="noopener">§</a></h5><p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出。上例的声明文件可以等价的改写为<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/16-declare-and-export" target="_blank" rel="noopener">16</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">    data: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, Animal, Directions, Options &#125;;</span><br></pre></td></tr></table></figure>
<p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p>
<h4 id="export-namespace§"><a href="#export-namespace§" class="headerlink" title="export namespace§"></a><code>export namespace</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-namespace" target="_blank" rel="noopener">§</a></h4><p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace" target="_blank" rel="noopener">17</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line">foo.bar.baz();</span><br></pre></td></tr></table></figure>
<h4 id="export-default§"><a href="#export-default§" class="headerlink" title="export default§"></a><code>export default</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-default" target="_blank" rel="noopener">§</a></h4><p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from &#39;foo&#39;</code> 而不是 <code>import { foo } from &#39;foo&#39;</code> 来导入这个默认值。</p>
<p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/18-export-default" target="_blank" rel="noopener">18</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/19-export-default-enum-error" target="_blank" rel="noopener">19</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line"><span class="comment">// ERROR: Expression expected.</span></span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Directions;</span><br></pre></td></tr></table></figure>
<p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/20-export-default-enum" target="_blank" rel="noopener">20</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Directions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="export-§"><a href="#export-§" class="headerlink" title="export =§"></a><code>export =</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-" target="_blank" rel="noopener">§</a></h4><p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = foo;</span><br><span class="line"><span class="comment">// 单个导出</span></span><br><span class="line">exports.bar = bar;</span><br></pre></td></tr></table></figure>
<p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">'foo'</span>).bar;</span><br></pre></td></tr></table></figure>
<p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure>
<p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> bar = foo.bar;</span><br></pre></td></tr></table></figure>
<p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal" target="_blank" rel="noopener">21</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export { bar }</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code> 来将 <code>bar</code> 合并到 <code>foo</code> 里。</p>
<p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看<a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require" target="_blank" rel="noopener">官方文档</a>。</p>
<p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p>
<h3 id="UMD-库§"><a href="#UMD-库§" class="headerlink" title="UMD 库§"></a>UMD 库<a href="https://ts.xcatliu.com/basics/declaration-files.html#umd-库" target="_blank" rel="noopener">§</a></h3><p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p>
<h4 id="export-as-namespace§"><a href="#export-as-namespace§" class="headerlink" title="export as namespace§"></a><code>export as namespace</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-as-namespace" target="_blank" rel="noopener">§</a></h4><p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/22-export-as-namespace" target="_blank" rel="noopener">22</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line"><span class="keyword">export</span> = foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然它也可以与 <code>export default</code> 一起使用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接扩展全局变量§"><a href="#直接扩展全局变量§" class="headerlink" title="直接扩展全局变量§"></a>直接扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files.html#直接扩展全局变量" target="_blank" rel="noopener">§</a></h3><p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/23-merge-global-interface" target="_blank" rel="noopener">23</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> String &#123;</span><br><span class="line">    prependHello(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span>.prependHello();</span><br></pre></td></tr></table></figure>
<p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p>
<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace" target="_blank" rel="noopener">24</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JQuery &#123;</span><br><span class="line">    <span class="keyword">interface</span> CustomOptions &#123;</span><br><span class="line">        bar: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> JQueryStatic &#123;</span><br><span class="line">    foo(options: JQuery.CustomOptions): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.foo(&#123;</span><br><span class="line">    bar: <span class="string">''</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="在-npm-包或-UMD-库中扩展全局变量§"><a href="#在-npm-包或-UMD-库中扩展全局变量§" class="headerlink" title="在 npm 包或 UMD 库中扩展全局变量§"></a>在 npm 包或 UMD 库中扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files.html#在-npm-包或-umd-库中扩展全局变量" target="_blank" rel="noopener">§</a></h3><p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p>
<h4 id="declare-global§"><a href="#declare-global§" class="headerlink" title="declare global§"></a><code>declare global</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-global" target="_blank" rel="noopener">§</a></h4><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/25-declare-global" target="_blank" rel="noopener">25</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> global &#123;</span><br><span class="line">    <span class="keyword">interface</span> String &#123;</span><br><span class="line">        prependHello(): <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="string">'bar'</span>.prependHello();</span><br></pre></td></tr></table></figure>
<p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p>
<h3 id="模块插件§"><a href="#模块插件§" class="headerlink" title="模块插件§"></a>模块插件<a href="https://ts.xcatliu.com/basics/declaration-files.html#模块插件" target="_blank" rel="noopener">§</a></h3><p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p>
<h4 id="declare-module§"><a href="#declare-module§" class="headerlink" title="declare module§"></a><code>declare module</code><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-module" target="_blank" rel="noopener">§</a></h4><p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/26-declare-module" target="_blank" rel="noopener">26</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'moment' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">moment</span>.<span class="title">CalendarKey</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment-plugin'</span>;</span><br><span class="line"></span><br><span class="line">moment.foo();</span><br></pre></td></tr></table></figure>
<p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/27-multiple-declare-module" target="_blank" rel="noopener">27</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/foo-bar.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'foo' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Foo &#123;</span><br><span class="line">        foo: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'bar' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Foo &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f: Foo;</span><br><span class="line">bar.bar();</span><br></pre></td></tr></table></figure>
<h3 id="声明文件中的依赖§"><a href="#声明文件中的依赖§" class="headerlink" title="声明文件中的依赖§"></a>声明文件中的依赖<a href="https://ts.xcatliu.com/basics/declaration-files.html#声明文件中的依赖" target="_blank" rel="noopener">§</a></h3><p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'moment' &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">moment</span>.<span class="title">CalendarKey</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p>
<h4 id="三斜线指令§"><a href="#三斜线指令§" class="headerlink" title="三斜线指令§"></a>三斜线指令<a href="https://ts.xcatliu.com/basics/declaration-files.html#三斜线指令" target="_blank" rel="noopener">§</a></h4><p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p>
<p>但是在声明文件中，它还是有一定的用武之地。</p>
<p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p>
<ul>
<li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li>
<li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li>
</ul>
<h5 id="书写一个全局变量的声明文件§"><a href="#书写一个全局变量的声明文件§" class="headerlink" title="书写一个全局变量的声明文件§"></a><strong>书写</strong>一个全局变量的声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#书写一个全局变量的声明文件" target="_blank" rel="noopener">§</a></h5><p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/28-triple-slash-directives" target="_blank" rel="noopener">28</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types="jquery" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">options: JQuery.AjaxSettings</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p>
<p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p>
<h5 id="依赖一个全局变量的声明文件§"><a href="#依赖一个全局变量的声明文件§" class="headerlink" title="依赖一个全局变量的声明文件§"></a><strong>依赖</strong>一个全局变量的声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#依赖一个全局变量的声明文件" target="_blank" rel="noopener">§</a></h5><p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/29-triple-slash-directives-global" target="_blank" rel="noopener">29</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// types/node-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types="node" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p: NodeJS.Process</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'node-plugin'</span>;</span><br><span class="line"></span><br><span class="line">foo(global.process);</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p>
<p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>
<p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p>
<h5 id="拆分声明文件§"><a href="#拆分声明文件§" class="headerlink" title="拆分声明文件§"></a>拆分声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#拆分声明文件" target="_blank" rel="noopener">§</a></h5><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules/@types/jquery/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types="sizzle" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQueryStatic.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="JQuery.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="misc.d.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="legacy.d.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br></pre></td></tr></table></figure>
<p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是：<code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p>
<p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p>
<h5 id="其他三斜线指令§"><a href="#其他三斜线指令§" class="headerlink" title="其他三斜线指令§"></a>其他三斜线指令<a href="https://ts.xcatliu.com/basics/declaration-files.html#其他三斜线指令" target="_blank" rel="noopener">§</a></h5><p>除了这两种三斜线指令之外，还有其他的三斜线指令，比如 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code>, <code>/// &lt;amd-module /&gt;</code> 等，但它们都是废弃的语法，故这里就不介绍了，详情可见<a href="http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html" target="_blank" rel="noopener">官网</a>。</p>
<h3 id="自动生成声明文件§"><a href="#自动生成声明文件§" class="headerlink" title="自动生成声明文件§"></a>自动生成声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#自动生成声明文件" target="_blank" rel="noopener">§</a></h3><p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，添加 <code>declaration</code> 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p>
<p>我们可以在命令行中添加 <code>--declaration</code>（简写 <code>-d</code>），或者在 <code>tsconfig.json</code> 中添加 <code>declaration</code> 选项。这里以 <code>tsconfig.json</code> 为例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"outDir"</span>: <span class="string">"lib"</span>,</span><br><span class="line">        <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中我们添加了 <code>outDir</code> 选项，将 ts 文件的编译结果输出到 <code>lib</code> 目录下，然后添加了 <code>declaration</code> 选项，设置为 <code>true</code>，表示将会由 ts 文件自动生成 <code>.d.ts</code> 声明文件，也会输出到 <code>lib</code> 目录下。</p>
<p>运行 <code>tsc</code> 之后，目录结构如下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/30-auto-d-ts" target="_blank" rel="noopener">30</a>：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── lib</span><br><span class="line">|  ├── bar</span><br><span class="line">|  |  ├── index.d.ts</span><br><span class="line">|  |  └── index.js</span><br><span class="line">|  ├── index.d.ts</span><br><span class="line">|  └── index.js</span><br><span class="line">├── src</span><br><span class="line">|  ├── bar</span><br><span class="line">|  |  └── index.ts</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── package.json</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>src</code> 目录下有两个 ts 文件，分别是 <code>src/index.ts</code> 和 <code>src/bar/index.ts</code>，它们被编译到 <code>lib</code> 目录下的同时，也会生成对应的两个声明文件 <code>lib/index.d.ts</code> 和 <code>lib/bar/index.d.ts</code>。它们的内容分别是：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/bar/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lib/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./bar'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="comment">// lib/bar/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br></pre></td></tr></table></figure>
<p>可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。</p>
<p>使用 <code>tsc</code> 自动生成声明文件时，每个 ts 文件都会对应一个 <code>.d.ts</code> 声明文件。这样的好处是，使用方不仅可以在使用 <code>import foo from &#39;foo&#39;</code> 导入默认的模块时获得类型提示，还可以在使用 <code>import bar from &#39;foo/lib/bar&#39;</code> 导入一个子模块时，也获得对应的类型提示。</p>
<p>除了 <code>declaration</code> 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：</p>
<ul>
<li><code>declarationDir</code> 设置生成 <code>.d.ts</code> 文件的目录</li>
<li><code>declarationMap</code> 对每个 <code>.d.ts</code> 文件，都生成对应的 <code>.d.ts.map</code>（sourcemap）文件</li>
<li><code>emitDeclarationOnly</code> 仅生成 <code>.d.ts</code> 文件，不生成 <code>.js</code> 文件</li>
</ul>
<h2 id="发布声明文件§"><a href="#发布声明文件§" class="headerlink" title="发布声明文件§"></a>发布声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#发布声明文件" target="_blank" rel="noopener">§</a></h2><p>当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。</p>
<p>此时有两种方案：</p>
<ol>
<li>将声明文件和源码放在一起</li>
<li>将声明文件发布到 <code>@types</code> 下</li>
</ol>
<p>这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。</p>
<p>仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 <code>@types</code> 下。</p>
<h3 id="将声明文件和源码放在一起§"><a href="#将声明文件和源码放在一起§" class="headerlink" title="将声明文件和源码放在一起§"></a>将声明文件和源码放在一起<a href="https://ts.xcatliu.com/basics/declaration-files.html#将声明文件和源码放在一起" target="_blank" rel="noopener">§</a></h3><p>如果声明文件是通过 <code>tsc</code> 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。</p>
<p>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：</p>
<ul>
<li>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址</li>
<li>在项目根目录下，编写一个 <code>index.d.ts</code> 文件</li>
<li>针对入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件），编写一个同名不同后缀的 <code>.d.ts</code> 文件</li>
</ul>
<p>第一种方式是给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"lib/index.js"</span>,</span><br><span class="line">    <span class="attr">"types"</span>: <span class="string">"foo.d.ts"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定了 <code>types</code> 为 <code>foo.d.ts</code> 之后，导入此库的时候，就会去找 <code>foo.d.ts</code> 作为此库的类型声明文件了。</p>
<p><code>typings</code> 与 <code>types</code> 一样，只是另一种写法。</p>
<p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件，将它视为此库的类型声明文件。</p>
<p>如果没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件）是否存在对应同名不同后缀的 <code>.d.ts</code> 文件。</p>
<p>比如 <code>package.json</code> 是这样时：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"lib/index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会先识别 <code>package.json</code> 中是否存在 <code>types</code> 或 <code>typings</code> 字段。发现不存在，那么就会寻找是否存在 <code>index.d.ts</code> 文件。如果还是不存在，那么就会寻找是否存在 <code>lib/index.d.ts</code> 文件。假如说连 <code>lib/index.d.ts</code> 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。</p>
<p>有的库为了支持导入子模块，比如 <code>import bar from &#39;foo/lib/bar&#39;</code>，就需要额外再编写一个类型声明文件 <code>lib/bar.d.ts</code> 或者 <code>lib/bar/index.d.ts</code>，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。</p>
<h3 id="将声明文件发布到-types-下§"><a href="#将声明文件发布到-types-下§" class="headerlink" title="将声明文件发布到 @types 下§"></a>将声明文件发布到 <code>@types</code> 下<a href="https://ts.xcatliu.com/basics/declaration-files.html#将声明文件发布到-types-下" target="_blank" rel="noopener">§</a></h3><p>如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 <code>@types</code> 下。</p>
<p>与普通的 npm 模块不同，<code>@types</code> 是统一由 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener">DefinitelyTyped</a> 管理的。要将声明文件发布到 <code>@types</code> 下，就需要给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。</p>
<p>pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 <code>@types</code> 下。</p>
<p>在 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener">DefinitelyTyped</a> 中创建一个新的类型声明，需要用到一些工具，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener">DefinitelyTyped</a> 的文档中已经有了<a href="https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package" target="_blank" rel="noopener">详细的介绍</a>，这里就不赘述了，以官方文档为准。</p>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><p>JavaScript 中有很多<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">内置对象</a>，它们可以直接在 TypeScript 中当做定义好了的类型。</p>
<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
<h2 id="ECMAScript-的内置对象§"><a href="#ECMAScript-的内置对象§" class="headerlink" title="ECMAScript 的内置对象§"></a>ECMAScript 的内置对象<a href="https://ts.xcatliu.com/basics/built-in-objects.html#ecmascript-的内置对象" target="_blank" rel="noopener">§</a></h2><p>ECMAScript 标准提供的内置对象有：</p>
<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p>
<p>我们可以在 TypeScript 中将变量定义为这些类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure>
<p>更多的内置对象，可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">MDN 的文档</a>。</p>
<p>而他们的定义文件，则在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>中。</p>
<h2 id="DOM-和-BOM-的内置对象§"><a href="#DOM-和-BOM-的内置对象§" class="headerlink" title="DOM 和 BOM 的内置对象§"></a>DOM 和 BOM 的内置对象<a href="https://ts.xcatliu.com/basics/built-in-objects.html#dom-和-bom-的内置对象" target="_blank" rel="noopener">§</a></h2><p>DOM 和 BOM 提供的内置对象有：</p>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
<p>TypeScript 中会经常用到这些类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>它们的定义文件同样在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>中。</p>
<h2 id="TypeScript-核心库的定义文件§"><a href="#TypeScript-核心库的定义文件§" class="headerlink" title="TypeScript 核心库的定义文件§"></a>TypeScript 核心库的定义文件<a href="https://ts.xcatliu.com/basics/built-in-objects.html#typescript-核心库的定义文件" target="_blank" rel="noopener">§</a></h2><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>
<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Math &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of a base expression taken to a specified power.</span></span><br><span class="line"><span class="comment">     * @param x The base value of the expression.</span></span><br><span class="line"><span class="comment">     * @param y The exponent value of the expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pow(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举一个 DOM 中的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.targetCurrent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document <span class="keyword">extends</span> Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;</span><br><span class="line">    addEventListener(<span class="keyword">type</span>: <span class="built_in">string</span>, listener: <span class="function">(<span class="params">ev: MouseEvent</span>) =&gt;</span> <span class="built_in">any</span>, useCapture?: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>
<p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>
<h2 id="用-TypeScript-写-Node-js§"><a href="#用-TypeScript-写-Node-js§" class="headerlink" title="用 TypeScript 写 Node.js§"></a>用 TypeScript 写 Node.js<a href="https://ts.xcatliu.com/basics/built-in-objects.html#用-typescript-写-nodejs" target="_blank" rel="noopener">§</a></h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
</search>
