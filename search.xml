<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3新特性</title>
    <url>/2018/05/30/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="css3有哪些新特性"><a href="#css3有哪些新特性" class="headerlink" title="css3有哪些新特性"></a>css3有哪些新特性</h1><ol>
<li>实现圆角<code>border-radius</code>、阴影<code>box-shadow</code>、<code>border-image</code>；</li>
<li>对文字加特效<code>text-shadow</code>、线性渐变<code>gradient</code>、旋转<code>transform</code>；</li>
<li><code>transform</code>：旋转<code>rotate（9deg）</code>、缩放<code>scale（0.85,0.9）</code>、定位<code>translate（0px，-30px）</code>、倾斜<code>skew（-9deg、0deg）</code>；</li>
<li>增加了更多的css选择器、多背景、rgba</li>
<li>在css3中引入为一个的伪类：：selection</li>
<li>媒体查询、多栏布局</li>
</ol>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS优先级的计算方法</title>
    <url>/2018/05/29/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="css优先级的计算方法"><a href="#css优先级的计算方法" class="headerlink" title="css优先级的计算方法"></a>css优先级的计算方法</h1><h2 id="1-CSS优先级比较"><a href="#1-CSS优先级比较" class="headerlink" title="1.CSS优先级比较"></a>1.CSS优先级比较</h2><p>！important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 默认</p><h2 id="2-CSS权重计算"><a href="#2-CSS权重计算" class="headerlink" title="2.CSS权重计算"></a>2.CSS权重计算</h2><p>我们把特殊性分为4个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。</p><a id="more"></a>

<p>4个等级的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一等：代表内联样式，如: style=””，权值为1000。</span><br><span class="line">第二等：代表ID选择器，如：#content，权值为0100。</span><br><span class="line">第三等：代表类，伪类和属性选择器，如.content，权值为0010。</span><br><span class="line">第四等：代表标签选择器和伪元素选择器，如div p，权值为0001。</span><br><span class="line">第五等：通用选择器（*），子选择器（&gt;），相邻同胞选择器（+），权值为0000</span><br></pre></td></tr></table></figure>
<p>当选择不同的选择器，选中同一个元素时并且设置相同的样式时，这样样式之间就会产生冲突，最终到底采用哪个选择器定义的样式，由选择器的优先级（权重）来决定，优先级高的优先显示。</p>
<p>继承的样式没有优先级<br>当选择器包含多种选择器时，需要将多种选择器的优先级相加然后进行比较。但是注意，选择器的优先级计算不会超过他的最大数量级，如果选择器的优先级一样，则使用靠后的样式。<br>并集选择器的优先级时单独计算。<br>可以在样式的最后添加一个!important，则此时该样式会获得一个最高的一个优先级，将会超过所有的样式甚至超过内联样式，所以在开发中尽量避免使用。</p>
<p>伪类的顺序</p>
<p>涉及到a的伪类一共四个：<br>:link<br>:visited<br>:hover<br>:active<br>这四个选择器的优先级是一样的。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>DAY1-1_JavaScript基础语法</title>
    <url>/2021/09/27/DAY1-1/</url>
    <content><![CDATA[<h1 id="JavaScript基础语法"><a href="#JavaScript基础语法" class="headerlink" title="JavaScript基础语法"></a>JavaScript基础语法</h1><ul>
<li><code>HTML</code> ：标记语言</li>
<li><code>JavaScript</code> ：编程语言</li>
</ul><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><h3 id="JavaScript发展历史（JS）"><a href="#JavaScript发展历史（JS）" class="headerlink" title="JavaScript发展历史（JS）"></a>JavaScript发展历史（JS）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 1994年，网景公司(Netscape)发布了Navigator浏览器0.9版，这是世界上第一款比较成熟的网络浏览器，轰动一时。但是这是一款名副其实的浏览器--只能浏览页面，浏览器无法与用户互动,当时解决这个问题有两个办法，一个是采用现有的语言,许它们直接嵌入网页。另一个是发明一种全新的语言。</span><br><span class="line">	liveScript ==&gt; javaScript ==&gt; ECMAscript</span><br><span class="line"></span><br><span class="line">2. 1995年Sun公司将Oak语言改名为Java，正式向市场推出。Sun公司大肆宣传，许诺这种语言可以&quot;一次编写，到处运	 行&quot;(Write Once, Run Anywhere)，它看上去很可能成为未来的主宰。</span><br><span class="line"></span><br><span class="line">3. 网景公司动了心，决定与Sun公司结成联盟</span><br><span class="line"></span><br><span class="line">4. 34岁的系统程序员Brendan Eich登场了。1995年4月，网景公司录用了他,他只用10天时间就把Javascript设计出来了。（多肽语言）</span><br><span class="line"></span><br><span class="line">5. (1)借鉴C语言的基本语法; (2)借鉴Java语言的数据类型和内存管理; (3)借鉴Scheme语言，将函数提升到&quot;第一等公民&quot;(first class)的地位; (4)借鉴Self语言，使用基于原型(prototype)的继承机制。</span><br></pre></td></tr></table></figure><a id="more"></a>

<h3 id="JavaScript能干什么"><a href="#JavaScript能干什么" class="headerlink" title="JavaScript能干什么"></a>JavaScript能干什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 常见的网页效果【表单验证，轮播图。。。】</span><br><span class="line">2. 与H5配合实现游戏【水果忍者： http://www.jq22.com/demo/html5-fruit-ninja/】</span><br><span class="line">3. 实现应用级别的程序【http://naotu.baidu.com】</span><br><span class="line">4. 实现统计效果【http://echarts.baidu.com/examples/】</span><br><span class="line">5. 地理定位等功能【http://lbsyun.baidu.com/jsdemo.htm#i4_5】</span><br><span class="line">6. 在线学编程【https://codecombat.163.com/play/】</span><br><span class="line">7. js可以实现人工智能【面部识别】</span><br><span class="line">8. 。。。</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ECMASCRIPT: 定义了javascript的语法规范,描述了语言的基本语法和数据类型</span><br><span class="line">2. BOM (Browser Object Model): 浏览器对象模型</span><br><span class="line">  - 有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等</span><br><span class="line">3. DOM (Document Object Model): 文档对象模型</span><br><span class="line">  - 有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加个 div，减少个 div，给div 换个位置等</span><br></pre></td></tr></table></figure>
<p>总结： <strong>JS 就是通过固定的语法去操作 浏览器 和 标签结构 来实现网页上的各种效果</strong></p>
<h2 id="JavaScript代码的书写位置"><a href="#JavaScript代码的书写位置" class="headerlink" title="JavaScript代码的书写位置"></a>JavaScript代码的书写位置</h2><ul>
<li>和 <code>css</code> 一样，我们的 <code>js</code> 也可以有多种方式书写在页面上让其生效</li>
<li><code>js</code> 也有多种方式书写，分为 <strong>行内式</strong>， <strong>内嵌式</strong>，<strong>外链式</strong></li>
</ul>
<h3 id="行内式-JS-代码（不推荐）"><a href="#行内式-JS-代码（不推荐）" class="headerlink" title="行内式 JS 代码（不推荐）"></a>行内式 JS 代码（不推荐）</h3><ul>
<li>写在标签上的 js 代码需要依靠事件（行为）来触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 写在 a 标签的 href 属性上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('我是一个弹出层');"</span>&gt;</span>点击一下试试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 写在其他元素上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert('我是一个弹出层')"</span>&gt;</span>点一下试试看<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	注：onclick 是一个事件（点击事件），当点击元素的时候执行后面的 js 代码</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="内嵌式-JS-代码"><a href="#内嵌式-JS-代码" class="headerlink" title="内嵌式 JS 代码"></a>内嵌式 JS 代码</h3><ul>
<li>内嵌式的 js 代码会在页面打开的时候直接触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 html 页面书写一个 script 标签，标签内部书写 js 代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">	alert('我是一个弹出层')</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	注：script 标签可以放在 head 里面也可以放在 body 里面</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="外链式-JS-代码（推荐）"><a href="#外链式-JS-代码（推荐）" class="headerlink" title="外链式 JS 代码（推荐）"></a>外链式 JS 代码（推荐）</h3><ul>
<li>外链式 js 代码只要引入了 html 页面，就会在页面打开的时候直接触发</li>
<li>新建一个 <code>.js</code> 后缀的文件，在文件内书写 js 代码，把写好的 js 文件引入 html 页面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 index.js 文件</span></span><br><span class="line">alert(<span class="string">'我是一个弹出层'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是一个 html 文件 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 script 标签的 src 属性，把写好的 js 文件引入页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 一个页面可以引入多个 js 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="JS-中的注释"><a href="#JS-中的注释" class="headerlink" title="JS 中的注释"></a>JS 中的注释</h2><ul>
<li>学习一个语言，先学习一个语言的注释，因为注释是给我们自己看的，也是给开发人员看的</li>
<li>写好一个注释，有利于我们以后阅读代码</li>
</ul>
<h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><ul>
<li>一般就是用来描述下面一行代码的作用</li>
<li>可以直接写两个 <code>/</code> ，也可以按 <code>ctrl + /</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是一个单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码表示在浏览器里面出现一个弹出层</span></span><br><span class="line">alert(<span class="string">'我是一个弹出层'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><ul>
<li>一般用来写一大段话，或者注释一段代码</li>
<li>可以直接写 <code>/**/</code> 然后在两个星号中间写注释，也可以按 <code>shift + alt + a</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	我是一个多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	注释的代码不会执行</span></span><br><span class="line"><span class="comment">	alert('我是一个弹出层')</span></span><br><span class="line"><span class="comment">	alert('我是一个弹出层')</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">alert(<span class="string">'我是一个弹出层'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="变量（重点）"><a href="#变量（重点）" class="headerlink" title="变量（重点）"></a>变量（重点）</h2><ul>
<li>变量指的是在程序中保存数据的一个容器</li>
<li>变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据</li>
<li>也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到他</li>
<li>语法： <code>var 变量名 = 值</code></li>
</ul>
<h3 id="定义变量及赋值"><a href="#定义变量及赋值" class="headerlink" title="定义变量及赋值"></a>定义变量及赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个变量</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给一个变量赋值</span></span><br><span class="line">num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量的同时给其赋值</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<ol>
<li>一个变量名只能存储一个值</li>
<li>当再次给一个变量赋值的时候，前面一次的值就没有了</li>
<li>变量名称区分大小写（JS 区分大小写）</li>
</ol>
</li>
</ul>
<h3 id="变量的命名规则和命名规范"><a href="#变量的命名规则和命名规范" class="headerlink" title="变量的命名规则和命名规范"></a>变量的命名规则和命名规范</h3><ul>
<li>规则： 必须遵守的，不遵守就是错<ol>
<li>一个变量名称可以由 <strong>数字</strong>、<strong>字母</strong>、<strong>英文下划线（_）</strong>、<strong>美元符号（$）</strong> 组成</li>
<li>严格区分大小写</li>
<li>不能由数字开头，不要使用中文汉字命名</li>
<li>不能是 <strong>保留字</strong> 或者 <strong>关键字</strong></li>
<li>不要出现空格</li>
</ol>
</li>
<li>规范： 建议遵守的（开发者默认），不遵守不会报错<ol>
<li>变量名尽量有意义（语义化）</li>
<li>遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写</li>
</ol>
</li>
</ul>
<h2 id="数据类型（重点）"><a href="#数据类型（重点）" class="headerlink" title="数据类型（重点）"></a>数据类型（重点）</h2><ul>
<li>是指我们存储在内存中的数据的类型</li>
<li>我们通常分为两大类 <strong>基本数据类型</strong> 和 <strong>复杂数据类型</strong></li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol>
<li>数值类型（number）<ul>
<li>一切数字都是数值类型（包括二进制，十进制，十六进制等）</li>
<li>NaN（not a number），一个非数字</li>
</ul>
</li>
<li>字符串类型（string）<ul>
<li>被引号包裹的所有内容（可以是单引号也可以是双引号）</li>
</ul>
</li>
<li>布尔类型（boolean）<ul>
<li>只有两个（true 或者 false）</li>
</ul>
</li>
<li>null类型（null）<ul>
<li>只有一个，就是 null，表示空的意思</li>
</ul>
</li>
<li>undefined类型（undefined）<ul>
<li>只有一个，就是 undefined，表示没有值的意思</li>
</ul>
</li>
</ol>
<h3 id="复杂数据类型（暂时先不讲）"><a href="#复杂数据类型（暂时先不讲）" class="headerlink" title="复杂数据类型（暂时先不讲）"></a>复杂数据类型（暂时先不讲）</h3><ol>
<li>对象类型（object）</li>
<li>函数类型（function）</li>
<li>。。。</li>
</ol>
<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><ul>
<li>既然已经把数据分开了类型，那么我们就要知道我们存储的数据是一个什么类型的数据</li>
<li>使用 <code>typeof</code> 关键字来进行判断</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种使用方式</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种使用方式</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(s1));</span><br></pre></td></tr></table></figure>
<h3 id="判断一个变量是不是数字"><a href="#判断一个变量是不是数字" class="headerlink" title="判断一个变量是不是数字"></a>判断一个变量是不是数字</h3><ul>
<li>可以使用 <code>isNaN</code> 这个方法来判断一个变量是不是数字</li>
<li><code>isNaN</code> ：is not a number</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果变量是一个数字</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(n1)); <span class="comment">//=&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果变量不是一个数字</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(s1)); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul>
<li>数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等</li>
</ul>
<h3 id="其他数据类型转成数值"><a href="#其他数据类型转成数值" class="headerlink" title="其他数据类型转成数值"></a>其他数据类型转成数值</h3><ol>
<li><p><code>Number(变量)</code></p>
<ul>
<li>可以把一个变量强制转换成数值类型</li>
<li>可以转换小数，会保留小数</li>
<li>可以转换布尔值</li>
<li>遇到不可转换的都会返回 NaN</li>
</ul>
</li>
<li><p><code>parseInt(变量)</code></p>
<ul>
<li>从第一位开始检查，是数字就转换，知道一个不是数字的内容</li>
<li>开头就不是数字，那么直接返回 NaN</li>
<li>不认识小数点，只能保留整数</li>
</ul>
</li>
<li><p><code>parseFloat(变量)</code></p>
<ul>
<li><p>从第一位开始检查，是数字就转换，知道一个不是数字的内容</p>
</li>
<li><p>开头就不是数字，那么直接返回 NaN</p>
</li>
<li><p>认识一次小数点</p>
</li>
</ul>
</li>
<li><p>除了加法以外的数学运算</p>
<ul>
<li>运算符两边都是可运算数字才行</li>
<li>如果运算符任何一遍不是一个可运算数字，那么就会返回 NaN</li>
<li>加法不可以用</li>
</ul>
</li>
</ol>
<h3 id="其他数据类型转成字符串"><a href="#其他数据类型转成字符串" class="headerlink" title="其他数据类型转成字符串"></a>其他数据类型转成字符串</h3><ol>
<li><code>变量.toString()</code><ul>
<li>有一些数据类型不能使用 <code>toString()</code> 方法，比如 undefined 和 null</li>
</ul>
</li>
<li><code>String(变量)</code><ul>
<li>所有数据类型都可以</li>
</ul>
</li>
<li>使用加法运算<ul>
<li>在 JS 里面，<code>+</code> 由两个含义</li>
<li>字符串拼接： 只要 <code>+</code> 任意一边是字符串，就会进行字符串拼接</li>
<li>加法运算：只有 <code>+</code> 两边都是数字的时候，才会进行数学运算</li>
</ul>
</li>
</ol>
<h3 id="其他数据类型转成布尔"><a href="#其他数据类型转成布尔" class="headerlink" title="其他数据类型转成布尔"></a>其他数据类型转成布尔</h3><ol>
<li><code>Boolean(变量)</code><ul>
<li>在 js 中，只有 <code>&#39;&#39;</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>，这些是 false，其余都是 true</li>
</ul>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>就是在代码里面进行运算的时候使用的符号，不光只是数学运算，我们在 js 里面还有很多的运算方式</li>
</ul>
<h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><ol>
<li><p><code>+</code></p>
<ul>
<li>只有符号两边都是数字的时候才会进行加法运算</li>
<li>只要符号任意一边是字符串类型，就会进行字符串拼接</li>
</ul>
</li>
<li><p><code>-</code></p>
<ul>
<li><p>会执行减法运算</p>
</li>
<li><p>会自动把两边都转换成数字进行运算</p>
</li>
</ul>
</li>
<li><p><code>*</code></p>
<ul>
<li>会执行乘法运算</li>
<li>会自动把两边都转换成数字进行运算</li>
</ul>
</li>
<li><p><code>/</code></p>
<ul>
<li>会执行除法运算</li>
<li>会自动把两边都转换成数字进行运算</li>
</ul>
</li>
<li><p><code>%</code></p>
<ul>
<li>会执行取余运算</li>
<li>会自动把两边都转换成数字进行运算</li>
</ul>
</li>
</ol>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ol>
<li><p><code>=</code></p>
<ul>
<li>就是把 <code>=</code> 右边的赋值给等号左边的变量名</li>
<li><code>var num = 100</code></li>
<li>就是把 100 赋值给 num 变量</li>
<li>那么 num 变量的值就是 100</li>
</ul>
</li>
<li><p><code>+=</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a += 10</code> 等价于 <code>a = a + 10</code></li>
</ul>
</li>
<li><p><code>-=</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a -= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a -= 10</code> 等价于 <code>a = a - 10</code></li>
</ul>
</li>
<li><p><code>*=</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a *= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a *= 10</code> 等价于 <code>a = a * 10</code></li>
</ul>
</li>
<li><p><code>/+</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a /= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a /= 10</code> 等价于 <code>a = a / 10</code></li>
</ul>
</li>
<li><p><code>%=</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a %= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt; 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a %= 10</code> 等价于 <code>a = a % 10</code></li>
</ul>
</li>
</ol>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ol>
<li><code>==</code><ul>
<li>比较符号两边的值是否相等，不管数据类型</li>
<li><code>1 == &#39;1&#39;</code></li>
<li>两个的值是一样的，所以得到 true</li>
</ul>
</li>
<li><code>===</code><ul>
<li>比较符号两边的值和数据类型是否都相等</li>
<li><code>1 === &#39;1&#39;</code></li>
<li>两个值虽然一样，但是因为数据类型不一样，所以得到 false</li>
</ul>
</li>
<li><code>!=</code><ul>
<li>比较符号两边的值是否不等</li>
<li><code>1 != &#39;1&#39;</code></li>
<li>因为两边的值是相等的，所以比较他们不等的时候得到 false</li>
</ul>
</li>
<li><code>!==</code><ul>
<li>比较符号两边的数据类型和值是否不等</li>
<li><code>1 !== &#39;1&#39;</code></li>
<li>因为两边的数据类型确实不一样，所以得到 true</li>
</ul>
</li>
<li><code>&gt;=</code><ul>
<li>比较左边的值是否 大于或等于 右边的值</li>
<li><code>1 &gt;= 1</code>  true</li>
<li><code>1 &gt;= 0</code>  true</li>
<li><code>1 &gt;= 2</code>  false</li>
</ul>
</li>
<li><code>&lt;=</code><ul>
<li>比较左边的值是否 小于或等于 右边的值</li>
<li><code>1 &lt;= 2</code>  true</li>
<li><code>1 &lt;= 1</code>  true</li>
<li><code>1 &lt;= 0</code>  false </li>
</ul>
</li>
<li><code>&gt;</code><ul>
<li>比较左边的值是否 大于 右边的值</li>
<li><code>1 &gt; 0</code>  true</li>
<li><code>1 &gt; 1</code>  false</li>
<li><code>1 &gt; 2</code>  false</li>
</ul>
</li>
<li><code>&lt;</code><ul>
<li>比较左边的值是否 小于 右边的值</li>
<li><code>1 &lt; 2</code>  true</li>
<li><code>1 &lt; 1</code> false</li>
<li><code>1 &lt; 0</code> false</li>
</ul>
</li>
</ol>
<p>###逻辑运算符 </p>
<ol>
<li><code>&amp;&amp;</code><ul>
<li>进行 且 的运算</li>
<li>符号左边必须为 true 并且右边也是 true，才会返回 true</li>
<li>只要有一边不是 true，那么就会返回 false</li>
<li><code>true &amp;&amp; true</code>  true</li>
<li><code>true &amp;&amp; false</code>  false</li>
<li><code>false &amp;&amp; true</code>  false</li>
<li><code>false &amp;&amp; false</code>  false</li>
</ul>
</li>
<li><code>||</code><ul>
<li>进行 或 的运算</li>
<li>符号的左边为 true 或者右边为 true，都会返回 true</li>
<li>只有两边都是 false 的时候才会返回 false</li>
<li><code>true || true</code>  true</li>
<li><code>true || false</code>  true</li>
<li><code>false || true</code>  true</li>
<li><code>false || false</code>  false</li>
</ul>
</li>
<li><code>!</code><ul>
<li>进行 取反 运算</li>
<li>本身是 true 的，会变成 false</li>
<li>本身是 false 的，会变成 true</li>
<li><code>!true</code>  false</li>
<li><code>!false</code>  true</li>
</ul>
</li>
</ol>
<h3 id="自增自减运算符（一元运算符）"><a href="#自增自减运算符（一元运算符）" class="headerlink" title="自增自减运算符（一元运算符）"></a>自增自减运算符（一元运算符）</h3><ol>
<li><p><code>++</code></p>
<ul>
<li><p>进行自增运算</p>
</li>
<li><p>分成两种，<strong>前置++</strong> 和 <strong>后置++</strong></p>
</li>
<li><p>前置++，会先把值自动 +1，在返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(++a);</span><br><span class="line"><span class="comment">// 会返回 11，并且把 a 的值变成 11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后置++，会先把值返回，在自动+1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a++);</span><br><span class="line"><span class="comment">// 会返回 10，然后把 a 的值变成 11</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>--</code></p>
<ul>
<li>进行自减运算</li>
<li>分成两种，<strong>前置–</strong> 和 <strong>后置–</strong></li>
<li>和 <code>++</code> 运算符道理一样</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY1-4_函数（上）</title>
    <url>/2021/09/27/DAY1-4/</url>
    <content><![CDATA[<h1 id="函数（上）"><a href="#函数（上）" class="headerlink" title="函数（上）"></a>函数（上）</h1><ul>
<li>我们代码里面所说的函数和我们上学的时候学习的什么三角函数、二次函数之类的不是一个东西</li>
</ul><h2 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h2><ul>
<li><p>对于 js 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p>
</li>
<li><p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p>
</li>
<li><p>先看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个是我们以前写的一段代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数，这个 &#123;&#125; 就是那个 “盒子”</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数我们以前写的代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul><a id="more"></a>

<h2 id="函数的两个阶段（重点）"><a href="#函数的两个阶段（重点）" class="headerlink" title="函数的两个阶段（重点）"></a>函数的两个阶段（重点）</h2><ul>
<li>按照我们刚才的说法，两个阶段就是 <strong>放在盒子里面</strong> 和 <strong>让盒子里面的代码执行</strong></li>
</ul>
<h3 id="函数定义阶段"><a href="#函数定义阶段" class="headerlink" title="函数定义阶段"></a>函数定义阶段</h3><ul>
<li><p>定义阶段就是我们把代码 <strong>放在盒子里面</strong></p>
</li>
<li><p>我们就要学习怎么 <strong>放进去</strong>，也就是书写一个函数</p>
</li>
<li>我们有两种定义方式 <strong>声明式</strong> 和 <strong>赋值式</strong></li>
</ul>
<h4 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h4><ul>
<li><p>使用 <code>function</code> 这个关键字来声明一个函数</p>
</li>
<li><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一段代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function: 声明函数的关键字，表示接下来是一个函数了</span></span><br><span class="line"><span class="comment">// fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）</span></span><br><span class="line"><span class="comment">// (): 必须写，是用来放参数的位置（一会我们再聊）</span></span><br><span class="line"><span class="comment">// &#123;&#125;: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="赋值式"><a href="#赋值式" class="headerlink" title="赋值式"></a>赋值式</h4><ul>
<li><p>其实就是和我们使用 <code>var</code> 关键字是一个道理了</p>
</li>
<li><p>首先使用 <code>var</code> 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了</p>
</li>
<li><p>语法： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一段代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不需要在 function 后面书写函数的名字了，因为在前面已经有了</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数调用阶段"><a href="#函数调用阶段" class="headerlink" title="函数调用阶段"></a>函数调用阶段</h3><ul>
<li>就是让 <strong>盒子里面</strong> 的代码执行一下</li>
<li>让函数执行</li>
<li>两种定义函数的方式不同，但是调用函数的方式都以一样的</li>
</ul>
<h4 id="调用一个函数"><a href="#调用一个函数" class="headerlink" title="调用一个函数"></a>调用一个函数</h4><ul>
<li><p>函数调用就是直接写 <code>函数名()</code> 就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值式函数</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn2 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行</strong></li>
</ul>
</li>
</ul>
<h4 id="调用上的区别"><a href="#调用上的区别" class="headerlink" title="调用上的区别"></a>调用上的区别</h4><ul>
<li><p>虽然两种定义方式的调用都是一样的，但是还是有一些区别的</p>
</li>
<li><p>声明式函数： 调用可以在 <strong>定义之前或者定义之后</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以调用</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以调用</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值式函数： 调用只能在 <strong>定义之前</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会报错</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值式函数</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以调用</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数的参数（重点）"><a href="#函数的参数（重点）" class="headerlink" title="函数的参数（重点）"></a>函数的参数（重点）</h2><ul>
<li><p>我们在定义函数和调用函数的时候都出现过 <code>()</code></p>
</li>
<li><p>现在我们就来说一下这个 <code>()</code> 的作用</p>
</li>
<li><p>就是用来放参数的位置</p>
</li>
<li><p>参数分为两种 <strong>行参</strong> 和 <strong>实参</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">行参写在这里</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一段代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(实参写在这里)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值式函数</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">行参写在这里</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一段代码</span></span><br><span class="line">&#125;</span><br><span class="line">fn(实参写在这里)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="行参和实参的作用"><a href="#行参和实参的作用" class="headerlink" title="行参和实参的作用"></a>行参和实参的作用</h3><ol>
<li><p>行参</p>
<ul>
<li><p>就是在函数内部可以使用的变量，在函数外部不能使用</p>
</li>
<li><p>每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范）</p>
</li>
<li><p>多个单词之间以 <code>,</code> 分隔</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 书写一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在函数内部就可以使用 num 这个变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 在函数内部就可以使用 num 这个变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 书写两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在函数内部就可以使用 num1 和 num2 这两个变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在函数内部就可以使用 num1 和 num2 这两个变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只有行参的话，那么在函数内部使用的值个变量是没有值的，也就是 <code>undefined</code></p>
</li>
<li><p><strong>行参的值是在函数调用的时候由实参决定的</strong></p>
</li>
</ul>
</li>
<li><p>实参</p>
<ul>
<li><p>在函数调用的时候给行参赋值的</p>
</li>
<li><p>也就是说，在调用的时候是给一个实际的内容的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内部可以使用 num </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的本次调用，书写的实参是 100</span></span><br><span class="line"><span class="comment">// 那么本次调用的时候函数内部的 num 就是 100</span></span><br><span class="line">fn(<span class="number">100</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的本次调用，书写的实参是 200</span></span><br><span class="line"><span class="comment">// 那么本次调用的时候函数内部的 num 就是 200</span></span><br><span class="line">fn(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数内部的行参的值，由函数调用的时候传递的实参决定</strong></p>
</li>
<li><p><strong>多个参数的时候，是按照顺序一一对应的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内部可以使用 num1 和 num2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数本次调用的时候，书写的参数是 100 和 200</span></span><br><span class="line"><span class="comment">// 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200</span></span><br><span class="line">fn(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="参数个数的关系"><a href="#参数个数的关系" class="headerlink" title="参数个数的关系"></a>参数个数的关系</h3><ol>
<li><p>行参比实参少</p>
<ul>
<li><p>因为是按照顺序一一对应的</p>
</li>
<li><p>行参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内部可以使用 num1 和 num2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本次调用的时候，传递了两个实参，100 200 和 300</span></span><br><span class="line"><span class="comment">// 100 对应了 num1，200 对应了 num2，300 没有对应的变量</span></span><br><span class="line"><span class="comment">// 所以在函数内部就没有办法依靠变量来使用 300 这个值</span></span><br><span class="line">fn(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>行参比实参多</p>
<ul>
<li><p>因为是按照顺序一一对应的</p>
</li>
<li><p>所以多出来的行参就是没有值的，就是 <code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内部可以使用 num1 num2 和 num3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本次调用的时候，传递了两个实参，100 和 200</span></span><br><span class="line"><span class="comment">// 就分别对应了 num1 和 num2</span></span><br><span class="line"><span class="comment">// 而 num3 没有实参和其对应，那么 num3 的值就是 undefined</span></span><br><span class="line">fn(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="函数的return（重点）"><a href="#函数的return（重点）" class="headerlink" title="函数的return（重点）"></a>函数的return（重点）</h2><ul>
<li>return 返回的意思，其实就是给函数一个 <strong>返回值</strong> 和 <strong>终断函数</strong></li>
</ul>
<h3 id="终断函数"><a href="#终断函数" class="headerlink" title="终断函数"></a>终断函数</h3><ul>
<li><p>当我开始执行函数以后，函数内部的代码就会从上到下的依次执行</p>
</li>
<li><p>必须要等到函数内的代码执行完毕</p>
</li>
<li><p>而 <code>return</code> 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 写了 return 以后，后面的 4 和 5 就不会继续执行了</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><p>函数调用本身也是一个表达式，表达式就应该有一个值出现</p>
</li>
<li><p>现在的函数执行完毕之后，是不会有结果出现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn() 也是一个表达式，这个表达式就没有结果出现</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>return</code> 关键字就是可以给函数执行完毕一个结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行代码</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，fn() 这个表达式执行完毕之后就有结果出现了</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以在函数内部使用 <code>return</code> 关键把任何内容当作这个函数运行后的结果</li>
</ul>
</li>
</ul>
<h2 id="函数的优点"><a href="#函数的优点" class="headerlink" title="函数的优点"></a>函数的优点</h2><ul>
<li>函数就是对一段代码的封装，在我们想调用的时候调用</li>
<li>函数的几个优点<ol>
<li>封装代码，使代码更加简洁</li>
<li>复用，在重复功能的时候直接调用就好</li>
<li>代码执行时机，随时可以在我们想要执行的时候执行</li>
</ol>
</li>
</ul>
<h2 id="预解析（重点）"><a href="#预解析（重点）" class="headerlink" title="预解析（重点）"></a>预解析（重点）</h2><ul>
<li><strong>预解析</strong> 其实就是聊聊 js 代码的编译和执行</li>
<li>js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码</li>
<li>也就是说，我们的 js 代码在运行的时候，会经历两个环节 <strong>解释代码</strong> 和 <strong>执行代码</strong></li>
</ul>
<h3 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h3><ul>
<li><p>因为是在所有代码执行之前进行解释，所以叫做 <strong>预解析（预解释）</strong></p>
</li>
<li><p>需要解释的内容有两个</p>
<ul>
<li>声明式函数<ul>
<li>在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数</li>
</ul>
</li>
<li><code>var</code> 关键字<ul>
<li>在内存中先声明有一个变量名</li>
</ul>
</li>
</ul>
</li>
<li><p>看下面一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>经过预解析之后可以变形为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line">num = <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值是函数会按照 <code>var</code> 关键字的规则进行预解析</p>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY1-3_循环结构</title>
    <url>/2021/09/27/DAY1-3/</url>
    <content><![CDATA[<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><ul>
<li>循环结构，就是根据某些给出的条件，重复的执行同一段代码</li>
<li>循环必须要有某些固定的内容组成<ol>
<li>初始化</li>
<li>条件判断</li>
<li>要执行的代码</li>
<li>自身改变</li>
</ol>
</li>
</ul><h2 id="WHILE-循环"><a href="#WHILE-循环" class="headerlink" title="WHILE 循环"></a>WHILE 循环</h2><ul>
<li><p><code>while</code>，中文叫 当…时，其实就是当条件满足时就执行代码，一旦不满足了就不执行了</p>
</li>
<li><p>语法 <code>while (条件) { 满足条件就执行 }</code></p>
</li>
<li><p>因为满足条件就执行，所以我们写的时候一定要注意，就是设定一个边界值，不然就一直循环下去了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化条件</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. 条件判断</span></span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// 3. 要执行的代码</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前的 num 的值是 '</span> + num)</span><br><span class="line">  <span class="comment">// 4. 自身改变</span></span><br><span class="line">  num = num + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有自身改变，那么就会一直循环不停了</li>
</ul>
</li>
</ul><a id="more"></a>

<h2 id="DO-WHILE-循环"><a href="#DO-WHILE-循环" class="headerlink" title="DO WHILE 循环"></a>DO WHILE 循环</h2><ul>
<li><p>是一个和 <code>while</code> 循环类似的循环</p>
</li>
<li><p><code>while</code> 会先进行条件判断，满足就执行，不满足直接就不执行了</p>
</li>
<li><p>但是 <code>do while</code> 循环是，先不管条件，先执行一回，然后在开始进行条件判断</p>
</li>
<li><p>语法： <code>do { 要执行的代码 } while (条件)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面这个代码，条件一开始就不满足，但是依旧会执行一次 do 后面 &#123;&#125; 内部的代码</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我执行了一次'</span>)</span><br><span class="line">  num = num + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="FOR-循环"><a href="#FOR-循环" class="headerlink" title="FOR 循环"></a>FOR 循环</h2><ul>
<li><p>和 <code>while</code> 和 <code>do while</code> 循环都不太一样的一种循环结构</p>
</li>
<li><p>道理是和其他两种一样的，都是循环执行代码的</p>
</li>
<li><p>语法： <code>for (var i = 0; i &lt; 10; i++) { 要执行的代码 }</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把初始化，条件判断，自身改变，写在了一起</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 这里写的是要执行的代码</span></span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台会依次输出 1 ~ 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个只是看起来不太舒服，但是用起来比较好用</p>
</li>
</ul>
<h2 id="BREAK-终止循环"><a href="#BREAK-终止循环" class="headerlink" title="BREAK 终止循环"></a>BREAK 终止循环</h2><ul>
<li><p>在循环没有进行完毕的时候，因为我设置的条件满足，提前终止循环</p>
</li>
<li><p>比如：我要吃五个包子，吃到三个的时候，不能在吃了，我就停止吃包子这个事情</p>
</li>
<li><p>要终止循环，就可以直接使用 <code>break</code> 关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 没循环一次，吃一个包子</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我吃了一个包子'</span>)</span><br><span class="line">  <span class="comment">// 当 i 的值为 3 的时候，条件为 true，执行 &#123;&#125; 里面的代码终止循环</span></span><br><span class="line">  <span class="comment">// 循环就不会继续向下执行了，也就没有 4 和 5 了</span></span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="CONTINUE-结束本次循环"><a href="#CONTINUE-结束本次循环" class="headerlink" title="CONTINUE 结束本次循环"></a>CONTINUE 结束本次循环</h2><ul>
<li><p>在循环中，把循环的本次跳过去，继续执行后续的循环</p>
</li>
<li><p>比如：吃五个包子，到第三个的时候，第三个掉地下了，不吃了，跳过第三个，继续吃第四个和第五个</p>
</li>
<li><p>跳过本次循环，就可以使用 <code>continue</code> 关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 当 i 的值为 3 的时候，执行 &#123;&#125; 里面的代码</span></span><br><span class="line">  <span class="comment">// &#123;&#125; 里面有 continue，那么本次循环后面的代码就都不执行了</span></span><br><span class="line">  <span class="comment">// 自动算作 i 为 3 的这一次结束了，去继续执行 i = 4 的那次循环了</span></span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个是第三个包子，掉地下了，我不吃了'</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我吃了一个包子'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY2-1_数组</title>
    <url>/2021/09/27/DAY2-1/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li><p>什么是数组？</p>
</li>
<li><p>字面理解就是 <strong>数字的组合</strong></p>
</li>
<li><p>其实不太准确，准确的来说数组是一个 <strong>数据的集合</strong></p>
</li>
<li><p>也就是我们把一些数据放在一个盒子里面，按照顺序排好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'hello'</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个东西就是一个数组，存储着一些数据的集合</p>
</li>
</ul><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><ul>
<li><code>number</code> / <code>string</code> / <code>boolean</code> / <code>undefined</code> / <code>null</code> / <code>object</code> / <code>function</code>  /  <code>array</code> / …</li>
<li>数组也是数据类型中的一种</li>
<li><p>我们简单的把所有数据类型分为两个大类 <strong>基本数据类型</strong> 和 <strong>复杂数据类型</strong></p>
</li>
<li><p>基本数据类型： <code>number</code> / <code>string</code> / <code>boolean</code> / <code>undefined</code> / <code>null</code> </p>
</li>
<li>复杂数据类型： <code>object</code> / <code>function</code>  /  <code>array</code> / …</li>
</ul><a id="more"></a>

<h2 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h2><ul>
<li>数组就是一个 <code>[]</code></li>
<li>在 <code>[]</code> 里面存储着各种各样的数据，按照顺序依次排好</li>
</ul>
<h3 id="字面量创建一个数组"><a href="#字面量创建一个数组" class="headerlink" title="字面量创建一个数组"></a>字面量创建一个数组</h3><ul>
<li><p>直接使用 <code>[]</code> 的方式创建一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个有内容的数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内置构造函数创建数组"><a href="#内置构造函数创建数组" class="headerlink" title="内置构造函数创建数组"></a>内置构造函数创建数组</h3><ul>
<li><p>使用 js 的内置构造函数 <code>Array</code> 创建一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10 的数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个有内容的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组的-length"><a href="#数组的-length" class="headerlink" title="数组的 length"></a>数组的 length</h3><ul>
<li><p>length:  长度的意思</p>
</li>
<li><p>length 就是表示数组的长度，数组里面有多少个成员，length 就是多少</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h3><ul>
<li><p>索引，也叫做下标，是指一个数据在数组里面排在第几个的位置</p>
</li>
<li><p>注意： <strong>在所有的语言里面，索引都是从 0 开始的</strong></p>
</li>
<li><p>在 js 里面也一样，数组的索引从 0 开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'hello'</span>, <span class="string">'world'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面这个数组中，<strong>第 0 个</strong> 数据就是字符串 <code>hello</code>，<strong>第 1 个</strong> 数据就是字符串 <code>world</code></p>
</li>
<li><p>想获取数组中的第几个就使用 <code>数组[索引]</code> 来获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'hello'</span>, <span class="string">'world'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]) <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]) <span class="comment">// world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据类型之间存储的区别（重点）"><a href="#数据类型之间存储的区别（重点）" class="headerlink" title="数据类型之间存储的区别（重点）"></a>数据类型之间存储的区别（重点）</h2><ul>
<li>既然我们区分了基本数据类型和复杂数据类型</li>
<li>那么他们之间就一定会存在一些区别</li>
<li>他们最大的区别就是在存储上的区别</li>
<li>我们的存储空间分成两种 <strong>栈</strong> 和 <strong>堆</strong></li>
<li>栈： 主要存储基本数据类型的内容</li>
<li>堆： 主要存储复杂数据类型的内容</li>
</ul>
<h3 id="基本数据类型在内存中的存储情况"><a href="#基本数据类型在内存中的存储情况" class="headerlink" title="基本数据类型在内存中的存储情况"></a>基本数据类型在内存中的存储情况</h3><ul>
<li><code>var num = 100</code>，在内存中的存储情况</li>
<li><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/基本数据类型在内存中的存储情况.png)</li>
<li>直接在 <strong>栈空间</strong> 内有存储一个数据</li>
</ul>
<h3 id="复杂数据类型在内存中的存储情况"><a href="#复杂数据类型在内存中的存储情况" class="headerlink" title="复杂数据类型在内存中的存储情况"></a>复杂数据类型在内存中的存储情况</h3><ul>
<li><p>下面这个 对象 的存储</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/复杂数据类型在内存中的存储情况.png)</p>
</li>
<li><p>复杂数据类型的存储</p>
<ol>
<li>在堆里面开辟一个存储空间</li>
<li>把数据存储到存储空间内</li>
<li>把存储空间的地址赋值给栈里面的变量</li>
</ol>
</li>
<li><p>这就是数据类型之间存储的区别</p>
</li>
</ul>
<h3 id="数据类型之间的比较"><a href="#数据类型之间的比较" class="headerlink" title="数据类型之间的比较"></a>数据类型之间的比较</h3><ul>
<li><p>基本数据类型是 <strong>值</strong> 之间的比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num == str) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>复杂数据类型是 <strong>地址</strong> 之间的比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj == obj2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址）</li>
<li>虽然存储的内容是一样的，那么也是两个存储空间，两个地址</li>
<li>复杂数据类型之间就是地址的比较，所以 <code>obj</code> 和 <code>obj2</code> 两个变量的地址不一样</li>
<li>所以我们得到的就是 <code>false</code></li>
</ul>
</li>
</ul>
<h2 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h2><ul>
<li><p>数组是一个复杂数据类型，我们在操作它的时候就不能再想基本数据类型一样操作了</p>
</li>
<li><p>比如我们想改变一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们想把数组变成只有 1 和 2</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>这样肯定是不合理，因为这样不是在改变之前的数组</li>
<li>相当于心弄了一个数组给到 arr 这个变量了</li>
<li>相当于把 arr 里面存储的地址给换了，也就是把存储空间换掉了，而不是在之前的空间里面修改</li>
<li>所以我们就需要借助一些方法，在不改变存储空间的情况下，把存储空间里面的数据改变了</li>
</ul>
</li>
</ul>
<h3 id="数组常用方法之-push"><a href="#数组常用方法之-push" class="headerlink" title="数组常用方法之 push"></a>数组常用方法之 push</h3><ul>
<li><p><code>push</code> 是用来在数组的末尾追加一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 push 方法追加一个元素在末尾</span></span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组常用方法之-pop"><a href="#数组常用方法之-pop" class="headerlink" title="数组常用方法之 pop"></a>数组常用方法之 pop</h3><ul>
<li><p><code>pop</code> 是用来删除数组末尾的一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 pop 方法删除末尾的一个元素</span></span><br><span class="line">arr.pop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组常用方法之-unshift"><a href="#数组常用方法之-unshift" class="headerlink" title="数组常用方法之 unshift"></a>数组常用方法之 unshift</h3><ul>
<li><p><code>unshift</code> 是在数组的最前面添加一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 unshift 方法想数组的最前面添加一个元素</span></span><br><span class="line">arr.unshift(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [4, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组常用方法之-shift"><a href="#数组常用方法之-shift" class="headerlink" title="数组常用方法之  shift"></a>数组常用方法之  shift</h3><ul>
<li><p><code>shift</code> 是删除数组最前面的一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 shift 方法删除数组最前面的一个元素</span></span><br><span class="line">arr.shift()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组常用方法之-splice"><a href="#数组常用方法之-splice" class="headerlink" title="数组常用方法之 splice"></a>数组常用方法之 splice</h3><ul>
<li><p><code>splice</code> 是截取数组中的某些内容，按照数组的索引来截取</p>
</li>
<li><p>语法： <code>splice(从哪一个索引位置开始，截取多少个，替换的新元素)</code> （第三个参数可以不写）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 splice 方法截取数组</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 4, 5]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr.splice(1, 2)</code> 表示从索引 1 开始截取 2 个内容</li>
<li>第三个参数没有写，就是没有新内容替换掉截取位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 splice 方法截取数组</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'我是新内容'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, '我是新内容', 4, 5]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr.splice(1, 2, &#39;我是新内容&#39;)</code> 表示从索引 1 开始截取 2 个内容</li>
<li>然后用第三个参数把截取完空出来的位置填充</li>
</ul>
</li>
</ul>
<h3 id="数组常用方法之-reverse"><a href="#数组常用方法之-reverse" class="headerlink" title="数组常用方法之 reverse"></a>数组常用方法之 reverse</h3><ul>
<li><p><code>reverse</code> 是用来反转数组使用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 reverse 方法来反转数组</span></span><br><span class="line">arr.reverse()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组常用方法之-sort"><a href="#数组常用方法之-sort" class="headerlink" title="数组常用方法之 sort"></a>数组常用方法之 sort</h3><ul>
<li><p><code>sort</code> 是用来给数组排序的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sort 方法给数组排序</span></span><br><span class="line">arr.sort()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个只是一个基本的简单用法</li>
</ul>
</li>
</ul>
<h3 id="数组常用方法之-concat"><a href="#数组常用方法之-concat" class="headerlink" title="数组常用方法之 concat"></a>数组常用方法之 concat</h3><ul>
<li><p><code>concat</code> 是把多个数组进行拼接</p>
</li>
<li><p>和之前的方法有一些不一样的地方，就是 <code>concat</code> 不会改变原始数组，而是返回一个新的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 concat 方法拼接数组</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>concat 方法不会改变原始数组</strong></li>
</ul>
</li>
</ul>
<h3 id="数组常用方法之-join"><a href="#数组常用方法之-join" class="headerlink" title="数组常用方法之 join"></a>数组常用方法之 join</h3><ul>
<li><p><code>join</code> 是把数组里面的每一项内容链接起来，变成一个字符串</p>
</li>
<li><p>可以自己定义每一项之间链接的内容 <code>join(要以什么内容链接)</code></p>
</li>
<li><p>不会改变原始数组，而是把链接好的字符串返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 join 链接数组</span></span><br><span class="line"><span class="keyword">var</span> str = arr.join(<span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 1-2-3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>join 方法不会改变原始数组，而是返回链接好的字符串</strong></li>
</ul>
</li>
</ul>
<h2 id="for-和-for-in-循环"><a href="#for-和-for-in-循环" class="headerlink" title="for 和 for in 循环"></a>for 和 for in 循环</h2><ul>
<li><p>因为数组的索引就可以获取数组中的内容</p>
</li>
<li><p>数组的索引又是按照 0 ～ n 顺序排列</p>
</li>
<li><p>我们就可以使用 for 循环来循环数组，因为 for 循环我们也可以设置成 0 ～ n 顺序增加</p>
</li>
<li><p>我们把这个行为叫做 <strong>遍历</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for 循环遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会在控制台依次打印出 1， 2， 3， 4， 5</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>i &lt; arr.length</code> 因为 length 就是数组的长度，就是一个数字，所以我们可以直接用它来决定循环次数</li>
<li><code>console.log(arr[i])</code> 因为随着循环，i 的值会从 0 开始依次增加</li>
<li>所以我们实际上就相当于在打印 <code>arr[0]</code> / <code>arr[1]</code> / …</li>
</ul>
</li>
</ul>
<ul>
<li><p>因为 <strong>对象</strong> 是没有索引的，所以我们没有办法使用 for 循环来遍历</p>
</li>
<li><p>这里我们使用 for in 循环来遍历对象</p>
</li>
<li><p>先来看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会在控制台打印两次内容，分别是 name 和 age</span></span><br></pre></td></tr></table></figure>
<ul>
<li>for in 循环的遍历是按照对象中有多少成员来决定了</li>
<li>有多少成员，就会执行多少次</li>
<li><code>key</code> 是我们自己定义的一个变量，就和 for 循环的时候我们定义的 i 一个道理</li>
<li>在每次循环的过程中，key 就代表着对象中某一个成员的 <strong>属性名</strong></li>
</ul>
</li>
</ul>
<h2 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h2><ul>
<li>排序，就是把一个乱序的数组，通过我们的处理，让他变成一个有序的数组</li>
<li>今天我们讲解两种方式来排序一个数组 <strong>冒泡排序</strong> 和 <strong>选择排序</strong></li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li><p>先遍历数组，让挨着的两个进行比较，如果前一个比后一个大，那么就把两个换个位置</p>
</li>
<li><p>数组遍历一遍以后，那么最后一个数字就是最大的那个了</p>
</li>
<li><p>然后进行第二遍的遍历，还是按照之前的规则，第二大的数字就会跑到倒数第二的位置</p>
</li>
<li><p>以此类推，最后就会按照顺序把数组排好了</p>
<ol>
<li><p>我们先来准备一个乱序的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来我们就会用代码让数组排序</li>
</ul>
</li>
<li><p>先不着急循环，先来看数组里面内容换个位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定我现在要让数组中的第 0 项和第 1 项换个位置</span></span><br><span class="line"><span class="comment">// 需要借助第三个变量</span></span><br><span class="line"><span class="keyword">var</span> tmp = arr[<span class="number">0</span>]</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>]</span><br><span class="line">arr[<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次遍历数组，把最大的放到最后面去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span></span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[i]</span><br><span class="line">    arr[i] = arr[i + <span class="number">1</span>]</span><br><span class="line">    arr[i + <span class="number">1</span>] = tmp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历完毕以后，数组就会变成 [3, 1, 5, 6, 4, 7, 2, 8, 9]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一次结束以后，数组中的最后一个，就会是最大的那个数字</li>
<li>然后我们把上面的这段代码执行多次。数组有多少项就执行多少次</li>
</ul>
</li>
<li><p>按照数组的长度来遍历多少次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = arr[i]</span><br><span class="line">      arr[i] = arr[i + <span class="number">1</span>]</span><br><span class="line">      arr[i + <span class="number">1</span>] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束以后，数组就排序好了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给一些优化</p>
<ul>
<li><p>想象一个问题，假设数组长度是 9，第八次排完以后</p>
</li>
<li><p>后面八个数字已经按照顺序排列好了，剩下的那个最小的一定是在最前面</p>
</li>
<li><p>那么第九次就已经没有意义了，因为最小的已经在最前面了，不会再有任何换位置出现了</p>
</li>
<li><p>那么我们第九次遍历就不需要了，所以我们可以减少一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = arr[i]</span><br><span class="line">      arr[i] = arr[i + <span class="number">1</span>]</span><br><span class="line">      arr[i + <span class="number">1</span>] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个问题，第一次的时候，已经把最大的数字放在最后面了</p>
</li>
<li><p>那么第二次的时候，其实倒数第二个和最后一个就不用比了</p>
</li>
<li><p>因为我们就是要把倒数第二大的放在倒数第二的位置，即使比较了，也不会换位置</p>
</li>
<li><p>第三次就要倒数第三个数字就不用再和后两个比较了</p>
</li>
<li><p>以此类推，那么其实每次遍历的时候，就遍历当前次数 - 1 次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">    <span class="comment">// 判断，如果数组中的当前一个比后一个大，那么两个交换一下位置</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp = arr[i]</span><br><span class="line">      arr[i] = arr[i + <span class="number">1</span>]</span><br><span class="line">      arr[i + <span class="number">1</span>] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>至此，一个冒泡排序就完成了</p>
</li>
</ol>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li><p>先假定数组中的第 0 个就是最小的数字的索引</p>
</li>
<li><p>然后遍历数组，只要有一个数字比我小，那么就替换之前记录的索引</p>
</li>
<li><p>知道数组遍历结束后，就能找到最小的那个索引，然后让最小的索引换到第 0 个的位置</p>
</li>
<li><p>再来第二趟遍历，假定第 1 个是最小的数字的索引</p>
</li>
<li><p>在遍历一次数组，找到比我小的那个数字的索引</p>
</li>
<li><p>遍历结束后换个位置</p>
</li>
<li><p>依次类推，也可以把数组排序好</p>
<ol>
<li><p>准备一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>假定数组中的第 0 个是最小数字的索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minIndex = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数组，判断，只要数字比我小，那么就替换掉原先记录的索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minIndex = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结束后找到最小的索引</span></span><br><span class="line"><span class="comment">// 让第 minIndex 个和第 0 个交换</span></span><br><span class="line"><span class="keyword">var</span> tmp = arr[minIndex]</span><br><span class="line">arr[minIndex] = arr[<span class="number">0</span>]</span><br><span class="line">arr[<span class="number">0</span>] = tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照数组的长度重复执行上面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">  <span class="comment">// 因为第一遍的时候假定第 0 个，第二遍的时候假定第 1 个</span></span><br><span class="line">  <span class="comment">// 所以我们要假定第 j 个就行</span></span><br><span class="line">  <span class="keyword">var</span> minIndex = j</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 因为之前已经把最小的放在最前面了，后面的循环就不需要判断前面的了</span></span><br><span class="line">  <span class="comment">// 直接从 j + 1 开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = j + <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">      minIndex = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历结束后找到最小的索引</span></span><br><span class="line">  <span class="comment">// 第一堂的时候是和第 0 个交换，第二趟的时候是和第 1 个交换</span></span><br><span class="line">  <span class="comment">// 我们直接和第 j 个交换就行</span></span><br><span class="line">  <span class="keyword">var</span> tmp = arr[minIndex]</span><br><span class="line">  arr[minIndex] = arr[j]</span><br><span class="line">  arr[j] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些优化</p>
<ul>
<li><p>和之前一样，倒数第二次排序完毕以后，就已经排好了，最后一次没有必要了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">var</span> minIndex = j</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = j + <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">      minIndex = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> tmp = arr[minIndex]</span><br><span class="line">  arr[minIndex] = arr[j]</span><br><span class="line">  arr[j] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在交换变量之前，可以判断一下，如果我们遍历后得到的索引和当前的索引一直</p>
</li>
<li><p>那么就证明当前这个就是目前最小的，那么就没有必要交换</p>
</li>
<li><p>做一我们要判断，最小作引和当前作引不一样的时候，才交换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">var</span> minIndex = j</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = j + <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">      minIndex = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (minIndex !== j) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = arr[minIndex]</span><br><span class="line">    arr[minIndex] = arr[j]</span><br><span class="line">    arr[j] = tmp   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>至此，选择排序完成</p>
</li>
</ol>
</li>
</ul>
<h2 id="函数参数传递基本数据类型和复杂数据类型的区别"><a href="#函数参数传递基本数据类型和复杂数据类型的区别" class="headerlink" title="函数参数传递基本数据类型和复杂数据类型的区别"></a>函数参数传递基本数据类型和复杂数据类型的区别</h2><ul>
<li><p>之前我们知道了，基本数据类型和复杂数据类型在存储上是有区别的</p>
</li>
<li><p>那么他们在赋值之间也是有区别的</p>
</li>
<li><p>基本数据类型之间的赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 = num</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<ul>
<li>相当于是把 num 的值复制了一份一摸一样的给了 num2 变量</li>
<li>赋值以后两个在没有关系</li>
</ul>
</li>
<li><p>复杂数据类型之间的赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj</span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">'Rose'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Rose</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">// Rose</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为复杂数据类型，变量存储的是地址，真实内容在 堆空间 内存储</li>
<li>所以赋值的时候相当于把 obj 存储的那个地址复制了一份给到了 obj2 变量</li>
<li>现在 obj 和 obj2 两个变量存储的地址一样，指向一个内存空间</li>
<li>所以使用 obj2 这个变量修改空间内的内容，obj 指向的空间也会跟着改变了</li>
</ul>
</li>
</ul>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul>
<li><p>函数的参数也是赋值的之中，在函数调用的时候，实参给行参赋值</p>
</li>
<li><p>和之前变量赋值的规则是一样的</p>
</li>
<li><p>函数传递基本数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n = <span class="number">200</span></span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">fn(num)</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和之前变量赋值的时候一样，在把 num 的值复制了一份一摸一样的给到了函数内部的行参 n</li>
<li>两个之间在没有任何关系了</li>
</ul>
</li>
<li><p>函数传递复杂数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.name = <span class="string">'Rose'</span></span><br><span class="line">  <span class="built_in">console</span>.log(o.name) <span class="comment">// Rose</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br><span class="line">fn(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Rose</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和之前变量赋值的时候一样，把 obj 内存储的地址复制了一份一摸一样的给到函数内部的行参 o</li>
<li>函数外部的 obj 和函数内部的行参 o，存储的是一个地址，指向的是一个存储空间</li>
<li>所以两个变量操作的是一个存储空间</li>
<li>在函数内部改变了空间内的数据</li>
<li>obj 看到的也是改变以后的内容</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY2-2_ES5/String</title>
    <url>/2021/09/27/DAY2-2/</url>
    <content><![CDATA[<h1 id="ES5-String"><a href="#ES5-String" class="headerlink" title="ES5/String"></a>ES5/String</h1><h2 id="严格模式（了解）"><a href="#严格模式（了解）" class="headerlink" title="严格模式（了解）"></a>严格模式（了解）</h2><ul>
<li>我们都知道 js 是一个相对不很严谨的语言</li>
<li>而且开发的时候，一些代码也不是很严格要求</li>
<li>而严格模式就是对开发的时候写的一些内容做了要求</li>
</ul><h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><ul>
<li><p>想开启严格模式，直接在代码最开始的位置写上字符串 <code>use strict</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="string">'use strtic'</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// 下面代码书写就要按照严格模式来书写</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul><a id="more"></a>

<h3 id="严格模式的规则"><a href="#严格模式的规则" class="headerlink" title="严格模式的规则"></a>严格模式的规则</h3><ol>
<li><p>声明变量必须有 <code>var</code> 关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'use strtic'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">num2 = <span class="number">200</span> <span class="comment">// 这个就会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>之前了解过，在声明变量的时候，如果没有 var 关键字，那么按照作用域的规则会自动定义成全局变量</li>
<li>严格模式下不可以，会报错</li>
</ul>
</li>
<li><p>函数的行参不可以重复</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'use strtic'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">p1, p1</span>) </span>&#123;&#125; <span class="comment">// 直接就会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在非严格模式下，函数两个行参一样，是不会报错的，只不过就是相当于在函数内部只有一个变量了</li>
<li>但是在严格模式下会报错</li>
</ul>
</li>
<li><p>声明式函数调用的时候函数内部没有 this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'use strtic'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<ul>
<li>本身，全局声明式函数在调用的时候，函数内部的 this 是指向 window 的</li>
<li>在严格模式下，是没有 this 的</li>
</ul>
</li>
</ol>
<h2 id="ES5-中常见的数组常用方法"><a href="#ES5-中常见的数组常用方法" class="headerlink" title="ES5 中常见的数组常用方法"></a>ES5 中常见的数组常用方法</h2><ul>
<li>之前我们讲过的数组常用方法都是 ES3 的方法</li>
<li>今天来说一些 ES5 中的方法</li>
</ul>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><ul>
<li><p><code>indexOf</code> 用来找到数组中某一项的索引</p>
</li>
<li><p>语法： <code>indexOf(你要找的数组中的项)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 indexOf 超找数组中的某一项</span></span><br><span class="line"><span class="keyword">var</span> index = arr.indexOf(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们要找的是数组中值为 3 的那一项</li>
<li>返回的就是值为 3 的那一项在该数组中的索引</li>
</ul>
</li>
<li><p>如果你要找的内容在数组中没有，那么就会返回 -1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 indexOf 超找数组中的某一项</span></span><br><span class="line"><span class="keyword">var</span> index = arr.indexOf(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>你要找的值在数组中不存在，那么就会返回 -1</li>
</ul>
</li>
</ul>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><ul>
<li><p>和 for 循环一个作用，就是用来遍历数组的</p>
</li>
<li><p>语法：<code>arr.forEach(function (item, index, arr) {})</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach 遍历数组</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// item 就是数组中的每一项</span></span><br><span class="line">  <span class="comment">// index 就是数组的索引</span></span><br><span class="line">  <span class="comment">// arr 就是原始数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数组的第 '</span> + index + <span class="string">' 项的值是 '</span> + item + <span class="string">'，原始数组是'</span>, arr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>forEach() 的时候传递的那个函数，会根据数组的长度执行</li>
<li>数组的长度是多少，这个函数就会执行多少回</li>
</ul>
</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li><p>和 forEach 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 map 遍历数组</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// item 就是数组中的每一项</span></span><br><span class="line">  <span class="comment">// index 就是数组的索引</span></span><br><span class="line">  <span class="comment">// arr 就是原始数组</span></span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [11, 12, 13]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul>
<li><p>和 map 的使用方式类似，按照我们的条件来筛选数组</p>
</li>
<li><p>把原始数组中满足条件的筛选出来，组成一个新的数组返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 filter 过滤数组</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// item 就是数组中的每一项</span></span><br><span class="line">  <span class="comment">// index 就是数组的索引</span></span><br><span class="line">  <span class="comment">// arr 就是原始数组</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们设置的条件就是 <code>&gt; 1</code></li>
<li>返回的新数组就会是原始数组中所有 <code>&gt; 1</code> 的项</li>
</ul>
</li>
</ul>
<h2 id="创建字符串（了解）"><a href="#创建字符串（了解）" class="headerlink" title="创建字符串（了解）"></a>创建字符串（了解）</h2><ul>
<li><p>我们创建字符串也分为两种方法 <strong>字面量</strong> 和 <strong>构造函数</strong></p>
</li>
<li><p>字面量： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ASCII-字符集（了解）"><a href="#ASCII-字符集（了解）" class="headerlink" title="ASCII 字符集（了解）"></a>ASCII 字符集（了解）</h2><ul>
<li>我们都知道，计算机只能存储 <code>0101010</code> 这样的二进制数字</li>
<li>那么我们的 <code>a ~ z</code> / <code>A ~ Z</code> / <code>$</code> / <code>@</code> /… 之类的内容也有由二进制数字组成的</li>
<li>我们可以简单的理解为， <code>a ~ z</code> / <code>A ~ Z</code> / <code>$</code> / <code>@</code> /… 之类的内容都有一个自己的编号，然后在计算机存储的时候，是存储的这些编号，我们看的时候，也是通过这些编号在解析成我们要看到的内容给我们看到</li>
<li><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/ASCII控制字符.png)</li>
<li><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/ASCII显示字符.png)</li>
<li>上面的就是 ASCII 对照表，我们只需要知道他是这么存储的就好</li>
</ul>
<h3 id="unicode-编码"><a href="#unicode-编码" class="headerlink" title="unicode 编码"></a>unicode 编码</h3><ul>
<li>我们看到了，ASCII 只有这 128 个字符的编码结构</li>
<li>但是因为 ASCII 出现的比较早，而且是美国发明的，早起时候这些内容就够用了</li>
<li>因为存储一些英文的内容，传递一些英文的文章什么的都够用了</li>
<li>那么对于这个世界来说肯定是不够用的</li>
<li>因为我们的汉字没有办法存储，包括一些其他国家的语言也没有办法存储</li>
<li>所以就出现了 unicode 编码，也叫（万国码，统一码）</li>
<li>unicode 对照表就是一个和 ASCII 一样的对照表，只不过变得很大很大，因为存储的内容特别的多</li>
<li>而且包含了世界上大部分国家的文字，所以我们的文字和字符现在在存储的时候，都是按照 unicode 编码转换成数字进行存储</li>
<li>我们的 UTF-8 就是一种 8 位的unicode字符集</li>
</ul>
<h2 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a>字符串的常用方法</h2><ul>
<li>我们操作字符串，也有一堆的方法来帮助我们操作</li>
<li>字符串和数组有一个一样的地方，也是按照索引来排列的</li>
</ul>
<h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><ul>
<li><p><code>charAt(索引)</code>  是找到字符串中指定索引位置的内容返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Jack'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 charAt 找到字符串中的某一个内容</span></span><br><span class="line"><span class="keyword">var</span> index = str.charAt(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为字符串也是按照索引进行排列的，也是同样从 0 开始</li>
<li>所以索引 2 的位置就是 c</li>
</ul>
</li>
<li><p>如果没有对应的索引，那么就会返回 空字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Jack'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 charAt 找到字符串中的某一个内容</span></span><br><span class="line"><span class="keyword">var</span> index = str.charAt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// ''</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个字符串根本没有索引 10 的位置</li>
<li>所以就会返回一个空字符串 <code>&#39;&#39;</code></li>
</ul>
</li>
</ul>
<h3 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h3><ul>
<li><p><code>charCodeAt(索引)</code> 就是返回对应索引位置的 unicode 编码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Jack'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 charAt 找到字符串中的某一个内容</span></span><br><span class="line"><span class="keyword">var</span> index = str.charCodeAt(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// 74</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为 <code>J</code> 在 unicode 对照表里面存储的是 74，所以就会返回 74</li>
</ul>
</li>
</ul>
<h3 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf"></a>indexOf</h3><ul>
<li><p><code>indexOf</code> 就是按照字符找到对应的索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Jack'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 indexOf 找到对应的索引</span></span><br><span class="line"><span class="keyword">var</span> index = str.indexOf(<span class="string">'J'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为字符 <code>J</code> 在字符串 <code>Jack</code> 中的索引位置是 0</li>
<li>所以会返回 0</li>
</ul>
</li>
</ul>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><ul>
<li><p><code>substring</code> 是用来截取字符串使用的</p>
</li>
<li><p>语法： <code>substring(从哪个索引开始，到哪个索引截止)</code>，包含开始索引，不包含结束索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span></span><br><span class="line"><span class="comment">//         01234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 substring 截取字符串</span></span><br><span class="line"><span class="keyword">var</span> newStr = str.substring(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// el</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从索引 1 开始，到索引 3 截止，包含前面的索引不包含后面的索引</li>
<li>所以返回的是 el</li>
</ul>
</li>
</ul>
<h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><ul>
<li><p><code>substr</code> 也是用来截取字符串的</p>
</li>
<li><p>语法：<code>substr(从哪个索引开始，截取多少个)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span></span><br><span class="line"><span class="comment">//         01234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 substr 截取字符串</span></span><br><span class="line"><span class="keyword">var</span> newStr = str.substr(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// ell</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法和 <code>substring</code> 不一样的是，第二个参数是截取多少个</li>
<li>从索引 1 开始，截取 3 个，所以得到的是 <code>ell</code></li>
</ul>
</li>
</ul>
<h3 id="toLowerCase-和-toUpperCase"><a href="#toLowerCase-和-toUpperCase" class="headerlink" title="toLowerCase 和 toUpperCase"></a>toLowerCase 和 toUpperCase</h3><ul>
<li><p>这两个方法分别使用用来给字符串转成 小写字母 和 大写字母 的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = hello</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toUpperCase 转换成大写</span></span><br><span class="line"><span class="keyword">var</span> upper = str.toUpperCase()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(upper) <span class="comment">// HELLO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toLowerCase 转换成小写</span></span><br><span class="line"><span class="keyword">var</span> lower = upper.toLowerCase()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lower) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY2-3_Math 和 Date</title>
    <url>/2021/09/27/DAY2-3/</url>
    <content><![CDATA[<h1 id="Math-和-Date"><a href="#Math-和-Date" class="headerlink" title="Math 和 Date"></a>Math 和 Date</h1><ul>
<li>Math 是 js 的一个内置对象，提供了一堆的方法帮助我们操作 <strong>数字</strong></li>
<li>Date 是 js 的一个内置对象，提供了一堆的方法帮助我们操作 <strong>时间</strong></li>
</ul><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul>
<li>没有什么多余的东西，就是一堆的方法来操作数字</li>
</ul><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><ul>
<li><p><code>Math.random()</code> 这个方法是用来生成一个 <code>0 ~ 1</code> 之间的随机数</p>
</li>
<li><p>每次执行生成的数字都不一样，但是一定是 <code>0 ~ 1</code> 之间的</p>
</li>
<li><p>生成的数字包含 0 ，但是不包含 1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.random()</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 得到一个随机数</span></span><br></pre></td></tr></table></figure>
</li>
</ul><a id="more"></a>


<h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3><ul>
<li><p><code>Math.round()</code> 是将一个小数 <strong>四舍五入</strong> 变成一个整数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(num)) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">10.6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(num2)) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h3><ul>
<li><p><code>Math.abs()</code> 是返回一个数字的绝对值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">-10</span></span><br><span class="line"><span class="built_in">console</span>.log(math.abs(num)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h3><ul>
<li><p><code>Math.ceil()</code> 是将一个小数 <strong>向上取整</strong> 得到的整数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(num)) <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">10.9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(num2)) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h3><ul>
<li><p><code>Math.floor()</code> 是将一个小数 <strong>向下取整</strong> 的到的整数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(num)) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">10.9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(num2)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a>max</h3><ul>
<li><p><code>Math.max()</code> 得到的是你传入的几个数字之中最大的那个数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="min"><a href="#min" class="headerlink" title="min"></a>min</h3><ul>
<li><p><code>Math.min()</code> 得到的是你传入的几个数字之中最小的那个数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PI"><a href="#PI" class="headerlink" title="PI"></a>PI</h3><ul>
<li><p><code>Math.PI</code> 得到的是 <code>π</code> 的值，也就是 <code>3.1415936...</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.PI) <span class="comment">// 3.141592653589793</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为计算机的计算精度问题，只能得到小数点后 15 位</li>
<li><strong>使用 Math.PI 的时候，是不需要加 () 的</strong></li>
</ul>
</li>
</ul>
<h2 id="数字转换进制"><a href="#数字转换进制" class="headerlink" title="数字转换进制"></a>数字转换进制</h2><ol>
<li><p><code>toString()</code> 方法可以在数字转成字符串的时候给出一个进制数</p>
<ul>
<li><p>语法： <code>toString(你要转换的进制)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)) <span class="comment">// 1100100</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)) <span class="comment">// 144</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)) <span class="comment">// 64</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>parseInt()</code> 方法可以在字符串转成数字的时候把字符串当成多少进制转成十进制</p>
<ul>
<li><p>语法： <code>parseInt(要转换的字符串，当作几进制来转换)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(str, <span class="number">8</span>)) <span class="comment">// 64 把 100 当作一个 八进制 的数字转换成 十进制 以后得到的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(str, <span class="number">16</span>)) <span class="comment">// 256 把 100 当作 十六进制 的数字转换成 十进制 以后得到的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(str, <span class="number">2</span>)) <span class="comment">// 4 把 100 当作 二进制 的数字转换成 十进制 以后得到的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ul>
<li>js 提供的内置构造函数，专门用来获取时间的</li>
</ul>
<h3 id="new-Date"><a href="#new-Date" class="headerlink" title="new Date()"></a>new Date()</h3><ul>
<li><p><code>new Date()</code> 在不传递参数的情况下是默认返回当前时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// 当前时间 Fri Mar 01 2019 13:11:23 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new Date()</code> 在传入参数的时候，可以获取到一个你传递进去的时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-03-03 13:11:11'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// Sun Mar 03 2019 13:11:11 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new Date()</code> 传递的参数有多种情况</p>
<ol>
<li><p>传递两个数字，第一个表示年，第二个表示月份</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">00</span>) <span class="comment">// 月份从 0 开始计数，0 表示 1月，11 表示 12月</span></span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// Tue Jan 01 2019 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递三个数字，前两个不变，第三个表示该月份的第几天，从 1 到 31</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">00</span>, <span class="number">05</span>) </span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// Sat Jan 05 2019 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递四个数字，前三个不变，第四个表示当天的几点，从 0 到 23</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">00</span>, <span class="number">05</span>, <span class="number">22</span>) </span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// Sat Jan 05 2019 22:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递五个数字，前四个不变，第五个表示的是该小时的多少分钟，从 0 到 59</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">00</span>, <span class="number">05</span>, <span class="number">22</span>, <span class="number">33</span>) </span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// Sat Jan 05 2019 22:33:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递六个数字，前五个不变，第六个表示该分钟的多少秒，从 0 到 59</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">00</span>, <span class="number">05</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">55</span>) </span><br><span class="line"><span class="built_in">console</span>.log(time) <span class="comment">// Sat Jan 05 2019 22:33:55 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传入字符串的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019'</span>)) </span><br><span class="line"><span class="comment">// Tue Jan 01 2019 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-02'</span>)) </span><br><span class="line"><span class="comment">// Fri Feb 01 2019 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-02-03'</span>)) </span><br><span class="line"><span class="comment">// Sun Feb 03 2019 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-02-03 13:'</span>)) </span><br><span class="line"><span class="comment">// Sun Feb 03 2019 13:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-02-03 13:13:'</span>)) </span><br><span class="line"><span class="comment">// Sun Feb 03 2019 13:13:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-02-03 13:13:13'</span>)) </span><br><span class="line"><span class="comment">// Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="将日期字符串格式化成指定内容"><a href="#将日期字符串格式化成指定内容" class="headerlink" title="将日期字符串格式化成指定内容"></a>将日期字符串格式化成指定内容</h2><ul>
<li>比如我们得到的时间字符串是 <code>Sun Feb 03 2019 13:13:13 GMT+0800 (中国标准时间)</code></li>
<li>我指向得到这个日期中是那一年，我们就要靠截取字符串的形式得到</li>
<li>但是现在 js 为我们提供了一系列的方法来得到里面的指定内容</li>
</ul>
<h3 id="getFullYear"><a href="#getFullYear" class="headerlink" title="getFullYear"></a>getFullYear</h3><ul>
<li><p><code>getFullYear()</code> 方式是得到指定字符串中的哪一年</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getFullYear()) <span class="comment">// 2019</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getMonth"><a href="#getMonth" class="headerlink" title="getMonth"></a>getMonth</h3><ul>
<li><p><code>getMonth()</code> 方法是得到指定字符串中的哪一个月份 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getMonth()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里要有一个注意的地方</li>
<li>月份是从 0 开始数的</li>
<li>0 表示 1月，1 表示 2月，依此类推</li>
</ul>
</li>
</ul>
<h3 id="getDate"><a href="#getDate" class="headerlink" title="getDate"></a>getDate</h3><ul>
<li><p><code>getDate()</code> 方法是得到指定字符串中的哪一天</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getDate()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getHours"><a href="#getHours" class="headerlink" title="getHours"></a>getHours</h3><ul>
<li><p><code>getHours()</code> 方法是得到指定字符串中的哪小时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getHours()) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getMinutes"><a href="#getMinutes" class="headerlink" title="getMinutes"></a>getMinutes</h3><ul>
<li><p><code>getMinutes()</code> 方法是得到指定字符串中的哪分钟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getMinutes()) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getSeconds"><a href="#getSeconds" class="headerlink" title="getSeconds"></a>getSeconds</h3><ul>
<li><p><code>getSeconds()</code> 方法是得到指定字符串中的哪秒钟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getSeconds()) <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getDay"><a href="#getDay" class="headerlink" title="getDay"></a>getDay</h3><ul>
<li><p><code>getDay()</code> 方法是得到指定字符串当前日期是一周中的第几天（周日是 0，周六是 6）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getDay()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getTime"><a href="#getTime" class="headerlink" title="getTime"></a>getTime</h3><ul>
<li><p><code>getTime()</code> 方法是得到执行时间到 <code>格林威治时间</code> 的毫秒数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">03</span>, <span class="number">08</span>, <span class="number">08</span>, <span class="number">00</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(time.getTime()) <span class="comment">// 1554681622000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="获取时间差"><a href="#获取时间差" class="headerlink" title="获取时间差"></a>获取时间差</h2><ul>
<li>是指获取两个时间点之间相差的时间</li>
<li>在 js 中是不能用时间直接做 减法 的</li>
<li>我们需要一些特殊的操作</li>
<li>在编程的世界里面，有一个特殊的时间，是 <code>1970年01月01日00时00分00秒</code></li>
<li>这个时间我们叫做 <code>格林威治时间</code></li>
<li>所有的编程世界里面，这个时间都是一样的，而且 <code>格林威治时间</code> 的数字是 0</li>
<li>从 <code>格林威治时间</code> 开始，每经过1毫秒，数字就会 + 1</li>
<li>所以我们可以获取到任意一个时间节点到 <code>格林威治时间</code> 的毫秒数</li>
<li>然后在用两个毫秒数相减，就能得到两个时间点之间相差的毫秒数</li>
<li>我们在通过这个毫秒数得到准确的时间</li>
</ul>
<h3 id="计算时间差"><a href="#计算时间差" class="headerlink" title="计算时间差"></a>计算时间差</h3><ul>
<li>例如：我们现在计算一下 <code>2019-01-01 00:00:00</code> 到 <code>2019-01-03 04:55:34</code> 的时间差</li>
</ul>
<ol>
<li><p>先获取两个时间点到 <code>格林威治时间</code> 的毫秒数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-03 04:55:34'</span>)</span><br><span class="line"></span><br><span class="line">time1 = time1.getTime()</span><br><span class="line">time2 = time2.getTime()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(time1) <span class="comment">// 1546272000000</span></span><br><span class="line"><span class="built_in">console</span>.log(time2) <span class="comment">// 1546462534000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两个时间相减，得到两个时间点之间相差的毫秒数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> differenceTime = time2 - time1</span><br><span class="line"><span class="built_in">console</span>.log(differenceTime) <span class="comment">// 190534000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>现在我们计算出了两个时间点之间相差的毫秒数</li>
</ul>
</li>
<li><p>把我们计算的毫秒数换算成时间</p>
<ul>
<li><p>先计算出有多少天</p>
</li>
<li><p>以为一天是 <code>1000 * 60 * 60 * 24</code> 毫秒</p>
</li>
<li><p>用总的毫秒数除以一天的毫秒数，就能得到多少天了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-03 04:55:34'</span>)</span><br><span class="line">time1 = time1.getTime()</span><br><span class="line">time2 = time2.getTime()</span><br><span class="line"><span class="keyword">var</span> differenceTime = time2 - time1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的天数</span></span><br><span class="line"><span class="keyword">var</span> day = differenceTime / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) <span class="comment">// 2.20525462962963</span></span><br><span class="line">day = <span class="built_in">Math</span>.ceil(day) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为得到的是有小数的天数，我们向下取整，得到有多少个整的天数</li>
</ul>
</li>
<li><p>使用 <code>differenceTime</code> 减去两天所包含的毫秒数，剩下的就是不够一天的毫秒数</p>
</li>
<li><p>用不够一天的毫秒数计算出有多少个小时</p>
</li>
<li><p>因为一个小时是 <code>1000 * 60 * 60</code> 毫秒</p>
</li>
<li><p>用不够一天的毫秒数除以一小时的毫秒数，就能得到多少小时了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-03 04:55:34'</span>)</span><br><span class="line">time1 = time1.getTime()</span><br><span class="line">time2 = time2.getTime()</span><br><span class="line"><span class="keyword">var</span> differenceTime = time2 - time1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的天数</span></span><br><span class="line"><span class="keyword">var</span> day = differenceTime / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) <span class="comment">// 2.20525462962963</span></span><br><span class="line">day = <span class="built_in">Math</span>.floor(day) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的小时数</span></span><br><span class="line"><span class="keyword">var</span> afterHours = differenceTime - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> hours = afterHours / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line">hours = <span class="built_in">Math</span>.floor(hours) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和刚才一样的道理，我们需要向下取整</li>
</ul>
</li>
<li><p>同理，使用 <code>afterHours</code> - 4个小时包含的毫秒数，剩下的就是不够一个小时的毫秒数</p>
</li>
<li><p>用不够一个小时的毫秒数计算出有多少分钟</p>
</li>
<li><p>因为一分钟是 <code>1000 * 60</code> 毫秒</p>
</li>
<li><p>用不够一个小时的毫秒数除以一分钟的毫秒数就能得到多少分钟了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-03 04:55:34'</span>)</span><br><span class="line">time1 = time1.getTime()</span><br><span class="line">time2 = time2.getTime()</span><br><span class="line"><span class="keyword">var</span> differenceTime = time2 - time1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的天数</span></span><br><span class="line"><span class="keyword">var</span> day = differenceTime / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) <span class="comment">// 2.20525462962963</span></span><br><span class="line">day = <span class="built_in">Math</span>.floor(day) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的小时数</span></span><br><span class="line"><span class="keyword">var</span> afterHours = differenceTime - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> hours = afterHours / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line">hours = <span class="built_in">Math</span>.floor(hours) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整分钟数</span></span><br><span class="line"><span class="keyword">var</span> afterMinutes = afterHours - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> minutes = afterMinutes / (<span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">minutes = <span class="built_in">Math</span>.floor(minutes) <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和之前一样的道理计算出秒</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-03 04:55:34'</span>)</span><br><span class="line">time1 = time1.getTime()</span><br><span class="line">time2 = time2.getTime()</span><br><span class="line"><span class="keyword">var</span> differenceTime = time2 - time1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的天数</span></span><br><span class="line"><span class="keyword">var</span> day = differenceTime / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) <span class="comment">// 2.20525462962963</span></span><br><span class="line">day = <span class="built_in">Math</span>.floor(day) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的小时数</span></span><br><span class="line"><span class="keyword">var</span> afterHours = differenceTime - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> hours = afterHours / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line">hours = <span class="built_in">Math</span>.floor(hours) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整分钟数</span></span><br><span class="line"><span class="keyword">var</span> afterMinutes = afterHours - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> minutes = afterMinutes / (<span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">minutes = <span class="built_in">Math</span>.floor(minutes) <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整秒数</span></span><br><span class="line"><span class="keyword">var</span> afterSeconds = afterMinutes - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">55</span>)</span><br><span class="line"><span class="keyword">var</span> seconds = afterSeconds / <span class="number">1000</span></span><br><span class="line">seconds = <span class="built_in">Math</span>.floor(seconds) <span class="comment">// 34</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，同理减去整秒的数，剩下的就是毫秒数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-01 00:00:00'</span>)</span><br><span class="line"><span class="keyword">var</span> time2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2019-01-03 04:55:34'</span>)</span><br><span class="line">time1 = time1.getTime()</span><br><span class="line">time2 = time2.getTime()</span><br><span class="line"><span class="keyword">var</span> differenceTime = time2 - time1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的天数</span></span><br><span class="line"><span class="keyword">var</span> day = differenceTime / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) <span class="comment">// 2.20525462962963</span></span><br><span class="line">day = <span class="built_in">Math</span>.floor(day) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整的小时数</span></span><br><span class="line"><span class="keyword">var</span> afterHours = differenceTime - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> hours = afterHours / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line">hours = <span class="built_in">Math</span>.floor(hours) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整分钟数</span></span><br><span class="line"><span class="keyword">var</span> afterMinutes = afterHours - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> minutes = afterMinutes / (<span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">minutes = <span class="built_in">Math</span>.floor(minutes) <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算整秒数</span></span><br><span class="line"><span class="keyword">var</span> afterSeconds = afterMinutes - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">55</span>)</span><br><span class="line"><span class="keyword">var</span> seconds = afterSeconds / <span class="number">1000</span></span><br><span class="line">seconds = <span class="built_in">Math</span>.floor(seconds) <span class="comment">// 34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算毫秒数</span></span><br><span class="line"><span class="keyword">var</span> milliSeconds = afterSeconds - (<span class="number">1000</span> * <span class="number">34</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后我们把结果输出一下就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">'2019-01-01 00:00:00 和 2019-01-03 04:55:34 之间相差'</span>)</span><br><span class="line"><span class="built_in">document</span>.write(day + <span class="string">'天'</span> + hours + <span class="string">'小时'</span> + minutes + <span class="string">'分钟'</span> + seconds + <span class="string">'秒'</span> + milliSeconds + <span class="string">'毫秒'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY1-5_函数（下）</title>
    <url>/2021/09/27/DAY1-5/</url>
    <content><![CDATA[<h1 id="函数（下）"><a href="#函数（下）" class="headerlink" title="函数（下）"></a>函数（下）</h1><h2 id="作用域（重点）"><a href="#作用域（重点）" class="headerlink" title="作用域（重点）"></a>作用域（重点）</h2><ul>
<li>什么是作用域，就是一个变量可以生效的范围</li>
<li>变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域</li>
</ul><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><ul>
<li><p>全局作用域是最大的作用域</p>
</li>
<li><p>在全局作用域中定义的变量可以在任何地方使用</p>
</li>
<li><p>页面打开的时候，浏览器会自动给我们生成一个全局作用域 window</p>
</li>
<li><p>这个作用域会一直存在，直到页面关闭就销毁了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">200</span></span><br></pre></td></tr></table></figure>
</li>
</ul><a id="more"></a>

<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><ul>
<li><p>局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域</p>
</li>
<li><p>在局部作用域中定义的变量只能在这个局部作用域内部使用</p>
</li>
<li><p><strong>在 JS 中只有函数能生成一个局部作用域，别的都不行</strong></p>
</li>
<li><p>每一个函数，都是一个局部作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个 num 是一个全局作用域下的变量 在任何地方都可以使用</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 下面这个变量就是一个 fn 局部作用域内部的变量</span></span><br><span class="line">  <span class="comment">// 只能在 fn 函数内部使用</span></span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="变量使用规则（重点）"><a href="#变量使用规则（重点）" class="headerlink" title="变量使用规则（重点）"></a>变量使用规则（重点）</h2><ul>
<li>有了作用域以后，变量就有了使用范围，也就有了使用规则</li>
<li>变量使用规则分为两种，<strong>访问规则</strong> 和 <strong>赋值规则</strong></li>
</ul>
<h3 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h3><ul>
<li><p>当我想获取一个变量的值的时候，我们管这个行为叫做 <strong>访问</strong></p>
</li>
<li><p>获取变量的规则： </p>
<ul>
<li>首先，在自己的作用域内部查找，如果有，就直接拿来使用</li>
<li>如果没有，就去上一级作用域查找，如果有，就拿来使用</li>
<li>如果没有，就继续去上一级作用域查找，依次类推</li>
<li>如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">200</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num3 = <span class="number">300</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(num3) <span class="comment">// 自己作用域内有，拿过来用</span></span><br><span class="line">    <span class="built_in">console</span>.log(num2) <span class="comment">// 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用</span></span><br><span class="line">    <span class="built_in">console</span>.log(num) <span class="comment">// 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 自己没有，一级一级找上去到全局都没有，就会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的访问规则 也叫做 作用域的查找机制</p>
</li>
<li><p>作用域的查找机制只能是向上找，不能向下找</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="赋值规则"><a href="#赋值规则" class="headerlink" title="赋值规则"></a>赋值规则</h3><ul>
<li><p>当你想给一个变量赋值的时候，那么就先要找到这个变量，在给他赋值</p>
</li>
<li><p>变量赋值规则：</p>
<ul>
<li>先在自己作用域内部查找，有就直接赋值</li>
<li>没有就去上一级作用域内部查找，有就直接赋值</li>
<li>在没有再去上一级作用域查找，有就直接赋值</li>
<li>如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，在给他赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn 调用以后，要给 num 赋值</span></span><br><span class="line"><span class="comment">// 查看自己的作用域内部没有 num 变量</span></span><br><span class="line"><span class="comment">// 就会向上一级查找</span></span><br><span class="line"><span class="comment">// 上一级就是全局作用域，发现依旧没有</span></span><br><span class="line"><span class="comment">// 那么就会把 num 定义为全局的变量，并为其赋值</span></span><br><span class="line"><span class="comment">// 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><ul>
<li><p>什么是递归函数</p>
</li>
<li><p>在编程世界里面，递归就是一个自己调用自己的手段</p>
</li>
<li><p>递归函数： 一个函数内部，调用了自己，循环往复</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面这个代码就是一个最简单的递归函数</span></span><br><span class="line"><span class="comment">// 在函数内部调用了自己，函数一执行，就调用自己一次，在调用再执行，循环往复，没有止尽</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
</li>
<li><p>其实递归函数和循环很类似</p>
</li>
<li><p>需要有初始化，自增，执行代码，条件判断的，不然就是一个没有尽头的递归函数，我们叫做 <strong>死递归</strong></p>
</li>
</ul>
<h2 id="简单实现一个递归"><a href="#简单实现一个递归" class="headerlink" title="简单实现一个递归"></a>简单实现一个递归</h2><ul>
<li><p>我们先在用递归函数简单实现一个效果</p>
</li>
<li><p>需求： 求 1 至 5 的和</p>
<ul>
<li>先算 1 + 2 得 3</li>
<li>再算 3 + 3 得 6</li>
<li>再算 6 + 4 得 10 </li>
<li>再算 10 + 5 得 15</li>
<li>结束</li>
</ul>
</li>
<li><p>开始书写，写递归函数先要写结束条件（为了避免出现 “死递归”）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传递进来的是 1</span></span><br><span class="line">  <span class="comment">// 当 n === 5 的时候要结束</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>再写不满足条件的时候我们的递归处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传递进来的是 1</span></span><br><span class="line">  <span class="comment">// 当 n === 5 的时候要结束</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不满足条件的时候，就是当前数字 + 比自己大 1 的数字</span></span><br><span class="line">    <span class="keyword">return</span> n + add(n + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="简单了解对象"><a href="#简单了解对象" class="headerlink" title="简单了解对象"></a>简单了解对象</h2><ul>
<li><p>对象是一个复杂数据类型</p>
</li>
<li><p>其实说是复杂，但是没有很复杂，只不过是存储了一些基本数据类型的一个集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  num: <span class="number">100</span>,</span><br><span class="line">  str: <span class="string">'hello world'</span>,</span><br><span class="line">  boo: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里的 <code>{}</code> 和函数中的 <code>{}</code> 不一样</p>
</li>
<li><p>函数里面的是写代码的，而对象里面是写一些数据的</p>
</li>
<li><p><strong>对象就是一个键值对的集合</strong></p>
</li>
<li><p><code>{}</code> 里面的每一个键都是一个成员</p>
</li>
<li><p>也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了</p>
</li>
<li><p>其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据</p>
</li>
</ul>
<h3 id="创建一个对象"><a href="#创建一个对象" class="headerlink" title="创建一个对象"></a>创建一个对象</h3><ul>
<li><p>字面量的方式创建一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像对象中添加成员</span></span><br><span class="line">obj.name = <span class="string">'Jack'</span></span><br><span class="line">obj.age = <span class="number">18</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内置构造函数的方式创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向对象中添加成员</span></span><br><span class="line">obj.name = <span class="string">'Rose'</span></span><br><span class="line">obj.age = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Object 是 js 内置给我们的构造函数，用于创建一个对象使用的</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY2-4_BOM / DOM（上）</title>
    <url>/2021/09/27/DAY2-4/</url>
    <content><![CDATA[<h1 id="BOM-DOM（上）"><a href="#BOM-DOM（上）" class="headerlink" title="BOM / DOM（上）"></a>BOM / DOM（上）</h1><ul>
<li>今天开始我们开始使用 js 去操作浏览器和页面中的 html 元素了</li>
</ul><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ul>
<li>BOM（Browser Object Model）： 浏览器对象模型</li>
<li>其实就是操作浏览器的一些能力</li>
<li>我们可以操作哪些内容<ul>
<li>获取一些浏览器的相关信息（窗口的大小）</li>
<li>操作浏览器进行页面跳转</li>
<li>获取当前浏览器地址栏的信息</li>
<li>操作浏览器的滚动条</li>
<li>浏览器的信息（浏览器的版本）</li>
<li>让浏览器出现一个弹出框（alert/confirm/prompt）</li>
</ul>
</li>
<li>BOM 的核心就是 window 对象</li>
<li>window 是浏览器内置的一个对象，里面包含着操作浏览器的方法</li>
</ul><a id="more"></a>

<h3 id="获取浏览器窗口的尺寸"><a href="#获取浏览器窗口的尺寸" class="headerlink" title="获取浏览器窗口的尺寸"></a>获取浏览器窗口的尺寸</h3><ul>
<li><p><code>innerHeight</code> 和 <code>innerWidth</code></p>
</li>
<li><p>这两个方法分别是用来获取浏览器窗口的宽度和高度（包含滚动条的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> windowHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line"><span class="built_in">console</span>.log(windowHeight)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> windowWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line"><span class="built_in">console</span>.log(windowWidth)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="浏览器的弹出层"><a href="#浏览器的弹出层" class="headerlink" title="浏览器的弹出层"></a>浏览器的弹出层</h3><ul>
<li><p><code>alert</code> 是在浏览器弹出一个提示框</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">'我是一个提示框'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/alert.png)</p>
<ul>
<li>这个弹出层知识一个提示内容，只有一个确定按钮</li>
<li>点击确定按钮以后，这个提示框就消失了</li>
</ul>
</li>
<li><p><code>confirm</code> 是在浏览器弹出一个询问框</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> boo = <span class="built_in">window</span>.confirm(<span class="string">'我是一个询问框'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(boo)</span><br></pre></td></tr></table></figure>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/confirm.png)</p>
<ul>
<li>这个弹出层有一个询问信息和两个按钮</li>
<li>当你点击确定的时候，就会得到 true</li>
<li>当你点击取消的时候，就会得到 false</li>
</ul>
</li>
<li><p><code>prompt</code> 是在浏览器弹出一个输入框</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">window</span>.prompt(<span class="string">'请输入内容'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week2/assets/prompt.png)</p>
<ul>
<li>这个弹出层有一个输入框和两个按钮</li>
<li>当你点击取消的时候，得到的是 null</li>
<li>当你点击确定的时候得到的就是你输入的内容</li>
</ul>
</li>
</ul>
<h3 id="浏览器的地址信息"><a href="#浏览器的地址信息" class="headerlink" title="浏览器的地址信息"></a>浏览器的地址信息</h3><ul>
<li>在 window 中有一个对象叫做 <code>location</code> </li>
<li>就是专门用来存储浏览器的地址栏内的信息的</li>
</ul>
<h4 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h4><ul>
<li><p><code>location.href</code> 这个属性存储的是浏览器地址栏内 url 地址的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.href)</span><br></pre></td></tr></table></figure>
<ul>
<li>会把中文编程 url 编码的格式</li>
</ul>
</li>
<li><p><code>location.href</code> 这个属性也可以给他赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.href = <span class="string">'./index.html'</span></span><br><span class="line"><span class="comment">// 这个就会跳转页面到后面你给的那个地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="location-reload"><a href="#location-reload" class="headerlink" title="location.reload"></a>location.reload</h4><ul>
<li><p><code>location.reload()</code> 这个方法会重新加载一遍页面，就相当于刷新是一个道理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.reload()</span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>不要写在全局，不然浏览器就会一直处在刷新状态</strong></li>
</ul>
</li>
</ul>
<h3 id="浏览器的历史记录"><a href="#浏览器的历史记录" class="headerlink" title="浏览器的历史记录"></a>浏览器的历史记录</h3><ul>
<li>window 中有一个对象叫做 <code>history</code> </li>
<li>是专门用来存储历史记录信息的</li>
</ul>
<h4 id="history-back"><a href="#history-back" class="headerlink" title="history.back"></a>history.back</h4><ul>
<li><p><code>history.back</code> 是用来会退历史记录的，就是回到前一个页面，就相当于浏览器上的 ⬅️ 按钮</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.back()</span><br></pre></td></tr></table></figure>
<ul>
<li>前提是你要有上一条记录，不然就是一直在这个页面，也不会回退</li>
</ul>
</li>
</ul>
<h4 id="history-forword"><a href="#history-forword" class="headerlink" title="history.forword"></a>history.forword</h4><ul>
<li><p><code>history.forword</code> 是去到下一个历史记录里面，也就是去到下一个页面，就相当于浏览器上的 ➡️ 按钮</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.forward()</span><br></pre></td></tr></table></figure>
<ul>
<li>前提是你要之前有过回退操作，不然的话你现在就是最后一个页面，没有下一个</li>
</ul>
</li>
</ul>
<h3 id="浏览器的版本信息（了解）"><a href="#浏览器的版本信息（了解）" class="headerlink" title="浏览器的版本信息（了解）"></a>浏览器的版本信息（了解）</h3><ul>
<li>window 中有一个对象叫做 <code>navigator</code></li>
<li>是专门用来获取浏览器信息的</li>
</ul>
<h4 id="navigator-userAgent"><a href="#navigator-userAgent" class="headerlink" title="navigator.userAgent"></a>navigator.userAgent</h4><ul>
<li><p><code>navigator.userAgent</code> 是获取的浏览器的整体信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.navigator.userAgent)</span><br><span class="line"><span class="comment">// Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="navigator-appName"><a href="#navigator-appName" class="headerlink" title="navigator.appName"></a>navigator.appName</h4><ul>
<li><p><code>navigator.appName</code> 获取的是浏览器的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.navigator.appName)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="navigator-appVersion"><a href="#navigator-appVersion" class="headerlink" title="navigator.appVersion"></a>navigator.appVersion</h4><ul>
<li><p><code>navigator.appVersion</code> 获取的是浏览器的版本号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.navigator.appVersion)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="navigator-platform"><a href="#navigator-platform" class="headerlink" title="navigator.platform"></a>navigator.platform</h4><ul>
<li><p><code>navigator.platform</code> 获取到的是当前计算机的操作系统</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.navigator.platform)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="浏览器的-onload-事件"><a href="#浏览器的-onload-事件" class="headerlink" title="浏览器的 onload 事件"></a>浏览器的 onload 事件</h3><ul>
<li><p>这个不在是对象了，而是一个事件</p>
</li>
<li><p>是在页面所有资源加载完毕后执行的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'页面已经加载完毕'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="在-html-页面中把-js-写在-head-里面"><a href="#在-html-页面中把-js-写在-head-里面" class="headerlink" title="在 html 页面中把 js 写在 head 里面"></a>在 html 页面中把 js 写在 head 里面</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    	<span class="comment">// 这个代码执行的时候，body 还没有加载</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这个时候我们就获取不到 body 中的那个 div</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// 就需要使用 window.onload 事件</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这个函数会在页面加载完毕以后在执行</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="在-html-页面中把-js-写在-body-最后面"><a href="#在-html-页面中把-js-写在-body-最后面" class="headerlink" title="在 html 页面中把 js 写在 body 最后面"></a>在 html 页面中把 js 写在 body 最后面</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    	<span class="comment">// 这个代码执行的时候，body 已经加载完毕了</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在这里就可以获取到 div，写不写 window.onload 就无所谓了</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这个函数会在页面加载完毕以后在执行</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 那么这个时候页面的 DOM 元素都已经加载了，我们就可以获取 div 了</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="浏览器的-onscroll-事件"><a href="#浏览器的-onscroll-事件" class="headerlink" title="浏览器的 onscroll 事件"></a>浏览器的 onscroll 事件</h3><ul>
<li><p>这个 onscroll 事件是当浏览器的滚动条滚动的时候触发</p>
</li>
<li><p>或者鼠标滚轮滚动的时候出发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'浏览器滚动了'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<strong>前提是页面的高度要超过浏览器的可是窗口才可以</strong></li>
</ul>
</li>
</ul>
<h3 id="浏览器滚动的距离"><a href="#浏览器滚动的距离" class="headerlink" title="浏览器滚动的距离"></a>浏览器滚动的距离</h3><ul>
<li>浏览器内的内容即然可以滚动，那么我们就可以获取到浏览器滚动的距离</li>
<li>思考一个问题？<ul>
<li>浏览器真的滚动了吗？</li>
<li>其实我们的浏览器是没有滚动的，是一直在那里</li>
<li>滚动的是什么？是我们的页面</li>
<li>所以说，<strong>其实浏览器没有动，只不过是页面向上走了</strong></li>
</ul>
</li>
<li>所以，这个已经不能单纯的算是浏览器的内容了，而是我们页面的内容</li>
<li>所以不是在用 window 对象了，而是使用 document 对象</li>
</ul>
<h4 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h4><ul>
<li><p>获取的是页面向上滚动的距离</p>
</li>
<li><p>一共有两个获取方式</p>
<ul>
<li><code>document.body.scrollTop</code></li>
<li><code>document.documentElement.scrollTop</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.scrollTop)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.scrollTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个都是获取页面向上滚动的距离</li>
<li>区别：<ul>
<li>IE 浏览器<ul>
<li>没有 <code>DOCTYPE</code> 声明的时候，用这两个都行</li>
<li>有 <code>DOCTYPE</code> 声明的时候，只能用 <code>document.documentElement.scrollTop</code></li>
</ul>
</li>
<li>Chrome 和 FireFox<ul>
<li>没有 <code>DOCTYPE</code> 声明的时候，用 <code>document.body.scrollTop</code></li>
<li>有 <code>DOCTYPE</code> 声明的时候，用 <code>document.documentElement.scrollTop</code></li>
</ul>
</li>
<li>Safari<ul>
<li>两个都不用，使用一个单独的方法 <code>window.pageYOffset</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="scrollLeft"><a href="#scrollLeft" class="headerlink" title="scrollLeft"></a>scrollLeft</h4><ul>
<li><p>获取页面向左滚动的距离</p>
</li>
<li><p>也是两个方法</p>
<ul>
<li><p><code>document.body.scrollLeft</code></p>
</li>
<li><p><code>document.documentElementLeft</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.scrollLeft)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.scrollLeft)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个之间的区别和之前的 <code>scrollTop</code> 一样</p>
</li>
</ul>
</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li>在 js 里面，有两种定时器，<strong>倒计时定时器</strong> 和 <strong>间隔定时器</strong></li>
</ul>
<h4 id="倒计时定时器"><a href="#倒计时定时器" class="headerlink" title="倒计时定时器"></a>倒计时定时器</h4><ul>
<li><p>倒计时多少时间以后执行函数</p>
</li>
<li><p>语法： <code>setTimeout(要执行的函数，多长时间以后执行)</code></p>
</li>
<li><p>会在你设定的时间以后，执行函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我执行了'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(timerId) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间是按照毫秒进行计算的，1000 毫秒就是 1秒钟</li>
<li>所以会在页面打开 1 秒钟以后执行函数</li>
<li>只执行一次，就不在执行了</li>
<li>返回值是，当前这个定时器是页面中的第几个定时器</li>
</ul>
</li>
</ul>
<h4 id="间隔定时器"><a href="#间隔定时器" class="headerlink" title="间隔定时器"></a>间隔定时器</h4><ul>
<li><p>每间隔多少时间就执行一次函数</p>
</li>
<li><p>语法： <code>setInterval(要执行的函数，间隔多少时间)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我执行了'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间和刚才一样，是按照毫秒进行计算的</li>
<li>每间隔 1 秒钟执行一次函数</li>
<li>只要不关闭，会一直执行</li>
<li>返回值是，当前这个定时器是页面中的第几个定时器</li>
</ul>
</li>
</ul>
<h4 id="定时器的返回值"><a href="#定时器的返回值" class="headerlink" title="定时器的返回值"></a>定时器的返回值</h4><ul>
<li><p>设置定时器的时候，他的返回值是部分 <code>setTimeout</code> 和 <code>setInterval</code> 的</p>
</li>
<li><p>只要有一个定时器，那么就是一个数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'倒计时定时器'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timerId2 = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'间隔定时器'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(timerId) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(timerId2) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关闭定时器"><a href="#关闭定时器" class="headerlink" title="关闭定时器"></a>关闭定时器</h4><ul>
<li><p>我们刚才提到过一个 timerId，是表示这个定时器是页面上的第几个定时器</p>
</li>
<li><p>这个 timerId 就是用来关闭定时器的数字</p>
</li>
<li><p>我们有两个方法来关闭定时器 <code>clearTimeout</code> 和 <code>clearInterval</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'倒计时定时器'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">clearTimeout(timerId)</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭以后，定时器就不会在执行了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId2 = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'间隔定时器'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">coearInterval(timerId2)</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭以后定时器就不会在执行了</li>
</ul>
</li>
<li><p>原则上是 </p>
<ul>
<li><code>clearTimeout</code> 关闭 <code>setTimeout</code></li>
<li><code>clearInterval</code> 关闭 <code>setInterval</code></li>
</ul>
</li>
<li><p>但是其实是可以通用的，他们可以混着使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'倒计时定时器'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 关闭倒计时定时器</span></span><br><span class="line">clearInterval(timerId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timerId2 = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'间隔定时器'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 关闭间隔定时器</span></span><br><span class="line">clearTimeout(timerId2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="DOM（上）"><a href="#DOM（上）" class="headerlink" title="DOM（上）"></a>DOM（上）</h2><ul>
<li>DOM（Document Object Model）： 文档对象模型</li>
<li>其实就是操作 html 中的标签的一些能力</li>
<li>我们可以操作哪些内容<ul>
<li>获取一个元素</li>
<li>移除一个元素</li>
<li>创建一个元素</li>
<li>向页面里面添加一个元素</li>
<li>给元素绑定一些事件</li>
<li>获取元素的属性</li>
<li>给元素添加一些 css 样式</li>
<li>…</li>
</ul>
</li>
<li>DOM 的核心对象就是 docuemnt 对象</li>
<li>document 对象是浏览器内置的一个对象，里面存储着专门用来操作元素的各种方法</li>
<li>DOM： 页面中的标签，我们通过 js 获取到以后，就把这个对象叫做 DOM 对象</li>
</ul>
<p>###获取一个元素</p>
<ul>
<li>通过 js 代码来获取页面中的标签</li>
<li>获取到以后我们就可以操作这些标签了</li>
</ul>
<h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h4><ul>
<li><p><code>getElementById</code> 是通过标签的 id 名称来获取标签的</p>
</li>
<li><p>因为在一个页面中 id 是唯一的，所以获取到的就是一个元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span></span><br><span class="line"><span class="javascript">  	<span class="built_in">console</span>.log(box) <span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取到的就是页面中的那个 id 为 box 的 div 标签</li>
</ul>
</li>
</ul>
<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h4><ul>
<li><p><code>getElementsByClassName</code> 是用过标签的 class 名称来获取标签的</p>
</li>
<li><p>因为页面中可能有多个元素的 class 名称一样，所以获取到的是一组元素</p>
</li>
<li><p>哪怕你获取的 class 只有一个，那也是获取一组元素，只不过这一组中只有一个 DOM 元素而已</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>)</span></span><br><span class="line"><span class="javascript">  	<span class="built_in">console</span>.log(box) <span class="comment">// [&lt;div&gt;&lt;/div&gt;]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box[<span class="number">0</span>]) <span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取到的是一组元素，是一个长得和数组一样的数据结构，但是不是数组，是伪数组</li>
<li>这个一组数据也是按照索引排列的，所以我们想要准确的拿到这个 div，需要用索引来获取</li>
</ul>
</li>
</ul>
<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h4><ul>
<li><p><code>getElementsByTagName</code> 是用过标签的 标签 名称来获取标签的</p>
</li>
<li><p>因为页面中可能有多个元素的 标签 名称一样，所以获取到的是一组元素</p>
</li>
<li><p>哪怕真的只有一个这个标签名，那么也是获取一组元素，只不过这一组中只有一个 DOM 元素而已</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">  	<span class="built_in">console</span>.log(box) <span class="comment">// [&lt;div&gt;&lt;/div&gt;]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box[<span class="number">0</span>]) <span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和 <code>getElementsByClassName</code> 一样，获取到的是一个长得很像数组的元素</li>
<li>必须要用索引才能得到准确的 DOM 元素</li>
</ul>
</li>
</ul>
<h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h4><ul>
<li><p><code>querySelector</code> 是按照选择器的方式来获取元素</p>
</li>
<li><p>也就是说，按照我们写 css 的时候的选择器来获取</p>
</li>
<li><p>这个方法只能获取到一个元素，并且是页面中第一个满足条件的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)) <span class="comment">// 获取页面中的第一个 div 元素 </span></span><br><span class="line"><span class="built_in">console</span>.log(docuemnt.querySelector(<span class="string">'.box'</span>)) <span class="comment">// 获取页面中第一个有 box 类名的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'#box'</span>)) <span class="comment">// 获取页面中第一个 id 名为 box 的元素</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h4><ul>
<li><p><code>querySelectorAll</code> 是按照选择器的方式来获取元素</p>
</li>
<li><p>这个方法能获取到所有满足条件的元素，以一个伪数组的形式返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>)) <span class="comment">// 获取页面中的所有的 div 元素 </span></span><br><span class="line"><span class="built_in">console</span>.log(docuemnt.querySelectorAll(<span class="string">'.box'</span>)) <span class="comment">// 获取页面中所有有 box 类名的元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取到的是一组数据，也是需要用索引来获取到准确的每一个 DOM 元素</li>
</ul>
</li>
</ul>
<h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><ul>
<li>通过我们各种获取元素的方式获取到页面中的标签以后</li>
<li>我们可以直接操作 DOM 元素的属性，就能直接把效果展示在页面上</li>
</ul>
<h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><ul>
<li><p>获取元素内部的 HTML 结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.innerHTML)</span></span><br><span class="line">		/*</span><br><span class="line">			</span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">		</span><br><span class="line">		*/</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置元素的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="xml">   	div.innerHTML = '<span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span>'</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置完以后，页面中的 div 元素里面就会嵌套一个 p 元素</li>
</ul>
</li>
</ul>
<h4 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h4><ul>
<li><p>获取元素内部的文本（只能获取到文本内容，获取不到 html 标签）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.innerText) <span class="comment">// hello</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置元素内部的文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="xml">   	div.innerText = '<span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span>'</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置完毕以后，会把 <code>&lt;p&gt;hello&lt;/p&gt;</code> 当作一个文本出现在 div 元素里面，而不会把 p 解析成标签</li>
</ul>
</li>
</ul>
<h4 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h4><ul>
<li><p>获取元素的某个属性（包括自定义属性）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">a</span>=<span class="string">"100"</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">   	<span class="built_in">console</span>.log(div.getAttribute(<span class="string">'a'</span>)) <span class="comment">// 100</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.getAttribute(<span class="string">'class'</span>)) <span class="comment">// box</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h4><ul>
<li><p>给元素设置一个属性（包括自定义属性）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">   	div.setAttribute(<span class="string">'a'</span>, <span class="number">100</span>)</span></span><br><span class="line"><span class="javascript">    div.setAttribute(<span class="string">'class'</span>, <span class="string">'box'</span>)</span></span><br><span class="line"><span class="xml">    console.log(div) // <span class="tag">&lt;<span class="name">div</span> <span class="attr">a</span>=<span class="string">"100"</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="removeAttribute"><a href="#removeAttribute" class="headerlink" title="removeAttribute"></a>removeAttribute</h4><ul>
<li><p>直接移除元素的某个属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">a</span>=<span class="string">"100"</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">   	div.removeAttribute(<span class="string">'class'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div) <span class="comment">// &lt;div a="100"&gt;&lt;/div&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><ul>
<li><p>专门用来给元素添加 css 样式的</p>
</li>
<li><p>添加的都是行内样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">   	div.style.width = <span class="string">"100px"</span></span></span><br><span class="line"><span class="javascript">    div.style.height = <span class="string">"100px"</span></span></span><br><span class="line"><span class="javascript">    div.style.backgroundColor = <span class="string">"pink"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div) </span></span><br><span class="line"><span class="xml">    // <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px; height: 100px; background-color: pink;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>页面中的 div 就会变成一个宽高都是100，背景颜色是粉色</li>
</ul>
</li>
</ul>
<h4 id="className"><a href="#className" class="headerlink" title="className"></a>className</h4><ul>
<li><p>专门用来操作元素的 类名的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">   	<span class="built_in">console</span>.log(div.className) <span class="comment">// box</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以设置元素的类名，不过是全覆盖式的操作</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">   	div.className = <span class="string">'test'</span></span></span><br><span class="line"><span class="xml">    console.log(div) // <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在设置的时候，不管之前有没有类名，都会全部被设置的值覆盖</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY2-5_DOM（下）</title>
    <url>/2021/09/27/DAY2-5/</url>
    <content><![CDATA[<h1 id="DOM（下）"><a href="#DOM（下）" class="headerlink" title="DOM（下）"></a>DOM（下）</h1><ul>
<li>DOM 就是我们 html 结构中一个一个的节点构成的</li>
<li>不光我们的标签是一个节点，我们写的文本内容也是一个节点，注释，包括空格都是节点</li>
</ul><h2 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h2><ul>
<li>DOM 的节点我们一般分为常用的三大类 <strong>元素节点</strong> / <strong>文本节点</strong> / <strong>属性节点</strong></li>
<li>什么是分类，比如我们在获取元素的时候，通过各种方法获取到的我们叫做元素节点（标签节点）</li>
<li>比如我们标签里面写的文字，那么就是文本节点</li>
<li>写在每一个标签上的属性，就是属性节点</li>
</ul><a id="more"></a>

<h3 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h3><ul>
<li>我们通过 <code>getElementBy...</code> 获取到的都是元素节点</li>
</ul>
<h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><ul>
<li>我们通过 <code>getAttribute</code> 获取的就是元素的属性节点</li>
</ul>
<h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><ul>
<li>我们通过 <code>innerText</code> 获取到的就是元素的文本节点</li>
</ul>
<h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><ul>
<li><p><code>childNodes</code>：获取某一个节点下 <strong>所有的子一级节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.childNodes) </span></span><br><span class="line">    /*</span><br><span class="line">    	NodeList(3) [text, p, text]</span><br><span class="line">      0: text</span><br><span class="line">      1: p</span><br><span class="line">      2: text</span><br><span class="line">      length: 3</span><br><span class="line">      __proto__: NodeList</span><br><span class="line">    */</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们会发现，拿到以后是一个伪数组，里面有三个节点</li>
<li>一个 text：从 <div> 一直到 <p> 中间有一个换行和一堆空格，这个是第一个节点，是一个文本节点</p></div></li>
<li>一个 p：这个 p 标签就是第二个节点，这个是一个元素节点</li>
<li>一个 text：从 <p></p> 一直到  中间有一个换行和一堆空格，这个是第三个节点，是一个文本节点</li>
<li>这个时候就能看到我们有不同的节点类型了</li>
</ul>
</li>
<li><p><code>children</code> ：获取某一节点下所有的子一级 <strong>元素节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.children) </span></span><br><span class="line">    /*</span><br><span class="line">    	HTMLCollection [p]</span><br><span class="line">      0: p</span><br><span class="line">      length: 1</span><br><span class="line">      __proto__: HTMLCollection</span><br><span class="line">    */</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们发现只有一个节点了，因为 <code>children</code> 只要元素节点</li>
<li>div 下面又只有一个元素节点，就是 p</li>
<li>所以就只有一个，虽然只有一个，但是也是一个 <strong>伪数组</strong></li>
</ul>
</li>
<li><p><code>firstChild</code>：获取某一节点下子一级的 <strong>第一个节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.firstChild) <span class="comment">// #text </span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个是只获取一个节点，不再是伪数组了</li>
<li>获取的是第一个</li>
<li>第一个就是 <div> 一直到 <p> 的那个换行和空格，是个文本节点</p></div></li>
</ul>
</li>
<li><p><code>lastChild</code>：获取某一节点下子一级的 <strong>最后一个节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.lastChild) <span class="comment">// #text </span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不再是伪数组</li>
<li>获取的是最后一个</li>
<li>最后一个就是 <p></p> 一直到  之间的换行和空格，是个文本节点</li>
</ul>
</li>
<li><p><code>firstElementChild</code>：获取某一节点下子一级 <strong>第一个元素节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.firstElementChild) <span class="comment">// &lt;p&gt;hello&lt;/p&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是第一个 <strong>元素节点</strong></li>
<li>第一个元素节点就是 p 标签，是一个元素节点</li>
</ul>
</li>
<li><p><code>lastElementChild</code>：获取某一节点下子一级 <strong>最后一个元素节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oDiv 获取的是页面中的 div 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.lastElementChild) <span class="comment">// &lt;p&gt;world&lt;/p&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是最后一个 <strong>元素节点</strong></li>
<li>最后一个元素节点是 <code>&lt;p&gt;world&lt;/p&gt;</code>，是一个元素节点</li>
</ul>
</li>
<li><p><code>nextSibling</code>：获取某一个节点的 <strong>下一个兄弟节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>!!!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oLi = <span class="built_in">document</span>.querySelector(<span class="string">'#b'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oLi.nextSibling) <span class="comment">// #text</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是 <code>id=&quot;b&quot;</code> 这个 li 的下一个兄弟节点</li>
<li>因为 <code>id=&quot;b&quot;</code> 的下一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点</li>
</ul>
</li>
<li><p><code>previousSibling</code>：获取某一个节点的 <strong>上一个兄弟节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>!!!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oLi = <span class="built_in">document</span>.querySelector(<span class="string">'#b'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oLi.previousSibling) <span class="comment">// #text</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是 <code>id=&quot;b&quot;</code> 这个 li 的上一个兄弟节点</li>
<li>因为 <code>id=&quot;b&quot;</code> 的上一个节点，是两个 li 标签之间的换行和空格，所以是一个文本节点</li>
</ul>
</li>
<li><p><code>nextElementSibling</code>：获取某一个节点的 <strong>下一个元素节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>!!!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oLi = <span class="built_in">document</span>.querySelector(<span class="string">'#b'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="xml">    console.log(oLi.nextElementSibling) // <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>!!!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是 <code>id=&quot;b&quot;</code> 这个 li 的下一个兄弟元素节点</li>
<li>因为 <code>id=&quot;b&quot;</code> 的下一个兄弟元素节点就是 <code>id=&quot;c&quot;</code> 的 li，是一个元素节点</li>
</ul>
</li>
<li><p><code>previousElementSibling</code>：获取某一个节点的 <strong>上一个元素节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>!!!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oLi = <span class="built_in">document</span>.querySelector(<span class="string">'#b'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oLi.previousElementSibling) <span class="comment">// &lt;li id="a"&gt;hello&lt;/li&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是 <code>id=&quot;b&quot;</code> 这个 li 的上一个兄弟元素节点</li>
<li>因为 <code>id=&quot;b&quot;</code> 的上一个兄弟元素节点就是 <code>id=&quot;a&quot;</code> 的 li，是一个元素节点</li>
</ul>
</li>
<li><p><code>parentNode</code>：获取某一个节点的 <strong>父节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>world<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>!!!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oLi = <span class="built_in">document</span>.querySelector(<span class="string">'#b'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oLi.parentNode) <span class="comment">// &lt;ul&gt;...&lt;/ul&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只获取一个节点，不在是伪数组</li>
<li>获取的是当前这个 li 的父元素节点</li>
<li>因为这个 li 的父亲就是 ul，所以获取到的就是 ul，是一个元素节点</li>
</ul>
</li>
<li><p><code>attributes</code>：获取某一个 <strong>元素节点</strong> 的所有 <strong>属性节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">a</span>=<span class="string">"100"</span> <span class="attr">test</span>=<span class="string">"test"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这个 oLi 获取的是页面中的 li 元素，就是一个元素节点</span></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oLi = <span class="built_in">document</span>.querySelector(<span class="string">'#a'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oLi.attributes) </span></span><br><span class="line">    /*</span><br><span class="line">    	NamedNodeMap &#123;0: id, 1: a, 2: test, id: id, a: a, test: test, length: 3&#125;</span><br><span class="line">      0: id</span><br><span class="line">      1: a</span><br><span class="line">      2: test</span><br><span class="line">      length: 3</span><br><span class="line">      a: a</span><br><span class="line">      id: id</span><br><span class="line">      test: test</span><br><span class="line">      __proto__: NamedNodeMap</span><br><span class="line">    </span><br><span class="line">    */</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取的是一组数据，是该元素的所有属性，也是一个伪数组</li>
<li>这个 li 有三个属性，id / a / test 三个，所以就获取到了这三个</li>
</ul>
</li>
</ul>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><ul>
<li><p>我们已经知道节点会分成很多种，而且我们也能获取到各种不同的节点</p>
</li>
<li><p>接下来我们就来聊一些各种节点之间属性的区别</p>
</li>
<li><p>我们先准备一段代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">test</span>=<span class="string">"我是 ul 的一个属性"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 先获取 ul</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oUl = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 获取到 ul 下的第一个子元素节点，是一个元素节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> eleNode = oUl.firstElementChild</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 获取到 ul 的属性节点组合，因为是个组合，我们要拿到节点的话要用索引</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> attrNode = oUl.attributes[<span class="number">0</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取到 ul 下的第一个子节点，是一个文本节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> textNode = oUl.firstChild</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h4><ul>
<li><p><code>nodeType</code>：获取节点的节点类型，用数字表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(eleNode.nodeType) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(attrNode.nodeType) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(textNode.nodeType) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>nodeType === 1</code> 就表示该节点是一个 <strong>元素节点</strong></li>
<li><code>nodeType === 2</code> 就表示该节点是一个 <strong>属性节点</strong></li>
<li><code>nodeType === 3</code> 就表示该节点是一个 <strong>注释节点</strong></li>
</ul>
</li>
</ul>
<h4 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h4><ul>
<li><p><code>nodeName</code>：获取节点的节点名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(eleNode.nodeName) <span class="comment">// LI</span></span><br><span class="line"><span class="built_in">console</span>.log(attrNode.nodeName) <span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(textNode.nodeName) <span class="comment">// #text</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元素节点的 <code>nodeName</code> 就是 <strong>大写标签名</strong></li>
<li>属性节点的 <code>nodeName</code> 就是 <strong>属性名</strong></li>
<li>文本节点的 <code>nodeName</code> 都是 <strong>#text</strong></li>
</ul>
</li>
</ul>
<h4 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h4><ul>
<li><p><code>nodeValue</code>： 获取节点的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(eleNode.nodeValue) <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(attrNode.nodeValue) <span class="comment">// 我是 ul 的一个属性</span></span><br><span class="line"><span class="built_in">console</span>.log(textNode.nodeValue) <span class="comment">// 换行 + 空格</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元素节点没有 <code>nodeValue</code></li>
<li>属性节点的 <code>nodeValue</code> 就是 <strong>属性值</strong></li>
<li>文本节点的 <code>nodeValue</code> 就是 <strong>文本内容</strong></li>
</ul>
</li>
</ul>
<h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><table>
<thead>
<tr>
<th>-</th>
<th>nodeType</th>
<th>nodeName</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素节点</td>
<td>1</td>
<td>大写标签名</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>2</td>
<td>属性名</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>3</td>
<td>#text</td>
<td>文本内容</td>
</tr>
</tbody>
</table>
<h2 id="操作-DOM-节点"><a href="#操作-DOM-节点" class="headerlink" title="操作 DOM 节点"></a>操作 DOM 节点</h2><ul>
<li>我们所说的操作无非就是 <strong>增删改查（CRUD）</strong></li>
<li>创建一个节点（因为向页面中增加之前，我们需要先创建一个节点出来）</li>
<li>向页面中增加一个节点</li>
<li>删除页面中的某一个节点</li>
<li>修改页面中的某一个节点</li>
<li>获取页面中的某一个节点</li>
</ul>
<h3 id="创建一个节点"><a href="#创建一个节点" class="headerlink" title="创建一个节点"></a>创建一个节点</h3><ul>
<li><p><code>createElement</code>：用于创建一个元素节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 div 元素节点</span></span><br><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oDiv) <span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建出来的就是一个可以使用的 div 元素</li>
</ul>
</li>
<li><p><code>createTextNode</code>：用于创建一个文本节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个文本节点</span></span><br><span class="line"><span class="keyword">var</span> oText = <span class="built_in">document</span>.createTextNode(<span class="string">'我是一个文本'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oText) <span class="comment">// "我是一个文本"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="向页面中加入一个节点"><a href="#向页面中加入一个节点" class="headerlink" title="向页面中加入一个节点"></a>向页面中加入一个节点</h3><ul>
<li><p><code>appendChild</code>：是向一个元素节点的末尾追加一个节点</p>
</li>
<li><p>语法： <code>父节点.appendChild(要插入的子节点)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 div 元素节点</span></span><br><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">var</span> oText = <span class="built_in">document</span>.createTextNode(<span class="string">'我是一个文本'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 div 中追加一个文本节点</span></span><br><span class="line">oDiv.appendChild(oText)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oDiv) <span class="comment">// &lt;div&gt;我是一个文本&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>insertBefore</code>：向某一个节点前插入一个节点</p>
</li>
<li><p>语法： <code>父节点.insertBefore(要插入的节点，插入在哪一个节点的前面)</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oP = oDiv.querySelector(<span class="string">'p'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 创建一个元素节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 将这个元素节点添加到 div 下的 p 的前面</span></span></span><br><span class="line">    oDiv.insertBefore(oSpan, oP)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv)</span></span><br><span class="line">    /*</span><br><span class="line"><span class="xml">    	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    		<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    		<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    */</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="删除页面中的某一个节点"><a href="#删除页面中的某一个节点" class="headerlink" title="删除页面中的某一个节点"></a>删除页面中的某一个节点</h3><ul>
<li><p><code>removeChild</code>：移除某一节点下的某一个节点</p>
</li>
<li><p>语法：<code>父节点.removeChild(要移除的字节点)</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oP = oDiv.querySelector(<span class="string">'p'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 移除 div 下面的 p 标签</span></span></span><br><span class="line">    oDiv.removeChild(oP)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv) <span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改页面中的某一个节点"><a href="#修改页面中的某一个节点" class="headerlink" title="修改页面中的某一个节点"></a>修改页面中的某一个节点</h3><ul>
<li><p><code>replaceChild</code>：将页面中的某一个节点替换掉</p>
</li>
<li><p>语法： <code>父节点.replaceChild(新节点，旧节点)</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oP = oDiv.querySelector(<span class="string">'p'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 创建一个 span 节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向 span 元素中加点文字</span></span></span><br><span class="line"><span class="javascript">    oSpan.innerHTML = <span class="string">'我是新创建的 span 标签'</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">   	<span class="comment">// 用创建的 span 标签替换原先 div 下的 p 标签</span></span></span><br><span class="line">    oDiv.replaceChild(oSpan, oP)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv)</span></span><br><span class="line">    /*</span><br><span class="line"><span class="xml">    	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    		<span class="tag">&lt;<span class="name">span</span>&gt;</span>我是新创建的 span 标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    */</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="获取元素的非行间样式"><a href="#获取元素的非行间样式" class="headerlink" title="获取元素的非行间样式"></a>获取元素的非行间样式</h2><ul>
<li><p>我们在操作 DOM 的时候，很重要的一点就是要操作元素的 css 样式</p>
</li>
<li><p>那么在操作 css 样式的时候，我们避免不了就要获取元素的样式</p>
</li>
<li><p>之前我们说过可以用 <code>元素.style.xxx</code> 来获取</p>
</li>
<li><p>但是这个方法只能获取到元素 <strong>行间样式</strong>，也就是写在行内的样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(oDiv.style.height) <span class="comment">// 100px</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDIv.style.width) <span class="comment">// ''</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不管是外链式还是内嵌式，我们都获取不到该元素的样式</p>
</li>
<li><p>这里我们就要使用方法来获取了 <strong>getComputedStyle</strong> 和 <strong>currentStyle</strong></p>
</li>
<li><p>这两个方法的作用是一样的，只不过一个在 <strong>非 IE</strong> 浏览器，一个在 <strong>IE</strong> 浏览器</p>
</li>
</ul>
<h3 id="getComputedStyle（非IE使用）"><a href="#getComputedStyle（非IE使用）" class="headerlink" title="getComputedStyle（非IE使用）"></a>getComputedStyle（非IE使用）</h3><ul>
<li><p>语法：<code>window.getComputedStyle(元素, null).要获取的属性</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="built_in">window</span>.getComputedStyle(oDiv).width) <span class="comment">// 100px</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.getComputedStyle(oDiv).height) <span class="comment">// 100px</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个方法获取行间样式和非行间样式都可以</li>
</ul>
</li>
</ul>
<h3 id="currentStyle（IE使用）"><a href="#currentStyle（IE使用）" class="headerlink" title="currentStyle（IE使用）"></a>currentStyle（IE使用）</h3><ul>
<li><p>语法： <code>元素.currentStyle.要获取的属性</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(oDiv.currentStyle.width) <span class="comment">// 100px</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(oDiv.currentStyle.height) <span class="comment">// 100px</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="获取元素的偏移量"><a href="#获取元素的偏移量" class="headerlink" title="获取元素的偏移量"></a>获取元素的偏移量</h2><ul>
<li>就是元素在页面上的什么位置</li>
<li>我们有几个属性来获取，<strong>offsetLeft</strong> 和 <strong>offsetTop</strong> 和 <strong>offsetWidth</strong> 和 <strong>offsetHeight</strong></li>
</ul>
<h3 id="offsetLeft-和-offsetTop"><a href="#offsetLeft-和-offsetTop" class="headerlink" title="offsetLeft 和 offsetTop"></a>offsetLeft 和 offsetTop</h3><ul>
<li>获取的是元左边的偏移量和上边的偏移量</li>
<li>分成两个情况来看</li>
<li>没有定位的情况下<ul>
<li>获取元素边框外侧到页面内侧的距离</li>
</ul>
</li>
<li>有定位的情况下<ul>
<li>获取元素边框外侧到定位父级边框内侧的距离（其实就是我们写的 left 和 top 值）</li>
</ul>
</li>
</ul>
<h3 id="offsetWidth-和-offsetHeight"><a href="#offsetWidth-和-offsetHeight" class="headerlink" title="offsetWidth 和 offsetHeight"></a>offsetWidth 和 offsetHeight</h3><ul>
<li>获取元素 <code>内容宽高 + padding宽高 + border宽高</code> 的和</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY3-3_正则</title>
    <url>/2021/09/27/DAY3-3/</url>
    <content><![CDATA[<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><ul>
<li><p>正则表达式，又名 “规则表达式”</p>
</li>
<li><p>由我们自己来书写 “规则”，专门用来检测 <strong>字符串</strong> 是否符合 “规则” 使用的</p>
</li>
<li><p>我们使用一些特殊的字符或者符号定义一个 “规则公式”，然后用我们定义好的 “规则公式” 去检测字符串是不是合格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str1)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的变量 <code>reg</code> 就是定制好的规则</li>
<li>检测 <code>str1</code> 这个字符串的时候，符合规则</li>
<li>检测 <code>str2</code> 这个字符串的时候，不符合规则</li>
</ul>
</li>
</ul><a id="more"></a>
<h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><ul>
<li>想制定 “规则”，必须要按照人家要求的方式来制定</li>
<li>把一些字母和符号写在 <code>//</code> 中间的东西，叫做正则表达式，比如 <code>/abcdefg/</code></li>
<li>创建正则表达式有两个方式 <strong>字面量</strong> 和 <strong>构造函数创建</strong></li>
</ul>
<h3 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面就是字面量创建一个正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abcdefg/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个正则表达式就可以去检测字符串了</li>
</ul>
<h3 id="构造函数创建"><a href="#构造函数创建" class="headerlink" title="构造函数创建"></a>构造函数创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面就是构造函数创建一个正则表达式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'abcdefg'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(reg) <span class="comment">//  /abcdefg/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用构造函数方式创建的和字面量创建的，得到的结果一样</li>
</ul>
<h2 id="正则表达式里面的符号"><a href="#正则表达式里面的符号" class="headerlink" title="正则表达式里面的符号"></a>正则表达式里面的符号</h2><ul>
<li>知道了怎么创建一个正则表达式以后，我们就来详细的说一下正则表达式里面涉及到的一些符号了</li>
</ul>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul>
<li><code>.</code> ： 匹配非换行的任意字符</li>
<li><code>\</code> ： 转译符号，把有意义的 <strong>符号</strong> 转换成没有意义的 <strong>字符</strong>，把没有意义的 <strong>字符</strong> 转换成有意义的 <strong>符号</strong></li>
<li><code>\s</code> ： 匹配空白字符（空格/制表符/…）</li>
<li><code>\S</code> ： 匹配非空白字符</li>
<li><code>\d</code> ： 匹配数字</li>
<li><code>\D</code> ： 匹配非数字</li>
<li><code>\w</code> ： 匹配数字字母下划线</li>
<li><code>\W</code> ： 匹配非数字字母下划线</li>
</ul>
<ul>
<li><p>有了元字符我们就可以简单的制定一些规则了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\s/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'a b'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'ab'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc1'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'a1'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'#@$'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><ul>
<li><code>*</code> ： 前一个内容重复至少 0 次，也就是可以出现 <strong>0 ～ 正无穷</strong> 次</li>
<li><code>+</code> ： 前一个内容重复至少 1 次，也就是可以出现 <strong>1 ～ 正无穷</strong> 次</li>
<li><code>?</code> ： 前一个内容重复 0 或者 1 次，也就是可以出现 <strong>0 ～ 1</strong> 次</li>
<li><code>{n}</code> ： 前一个内容重复 n 次，也就是必须出现 <strong>n</strong> 次</li>
<li><code>{n,}</code> ： 前一个内容至少出现 n 次，也就是出现 <strong>n ～ 正无穷</strong> 次</li>
<li><code>{n,m}</code> ： 前一个内容至少出现 n 次至多出现 m 次，也就是出现 <strong>n ～ m</strong> 次</li>
</ul>
<ul>
<li><p>限定符是配合元字符使用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面正则表示验证数字出现 0 ～ 正无穷次都可以</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d*/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc1'</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'abc123'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面正则表示验证数字出现 1 ～ 正无穷次都可以</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc1'</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'abc123'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面正则表示验证数字出现 0 ~ 1 次都可以</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d?/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc1'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面正则表示验证数字必须出现 3 次</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc1'</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'abc123'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面正则表示验证数字出现 3 ～ 正无穷次</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3,&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc1'</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'abc123'</span></span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">'abcd1234567'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str4)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面正则表示验证数字只能出现 3 ～ 5 次</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3,5&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc1'</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'abc123'</span></span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">'abc12345'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str4)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h3><ul>
<li><code>^</code> ： 表示开头</li>
<li><code>$</code> ： 表示结尾</li>
</ul>
<ul>
<li><p>边界符是限定字符串的开始和结束的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面表示从开头到结尾只能有数字，并且出现 3 ～ 5 次</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;3,5&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abc123'</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">'1234567'</span></span><br><span class="line"><span class="keyword">var</span> str5 = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> str6 = <span class="string">'12345'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str3)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str4)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str5)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str6)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ul>
<li><code>()</code> ： 限定一组元素</li>
<li><code>[]</code> ： 字符集合，表示写在 <code>[]</code> 里面的任意一个都行</li>
<li><code>[^]</code> ： 反字符集合，表示写在 <code>[^]</code> 里面之外的任意一个都行</li>
<li><code>-</code> ： 范围，比如 <code>a-z</code> 表示从字母 a 到字母 z 都可以</li>
<li><code>|</code> ： 或，正则里面的或 <code>a|b</code> 表示字母 a 或者 b 都可以</li>
</ul>
<ul>
<li><p>现在我们就可以把若干符号组合在一起使用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是一个简单的邮箱验证</span></span><br><span class="line"><span class="comment">// 非_$开头，任意字符出现至少6次，一个@符号，(163|126|qq|sina)中的任意一个，一个点，(com|cn|net)中的任意一个</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[^_$].&#123;6,&#125;@(163|126|qq|sina)\.(com|cn|net)$/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h3><ul>
<li><code>i</code> ： 表示忽略大小写<ul>
<li>这个 i 是写在正则的最后面的</li>
<li><code>/\w/i</code></li>
<li>就是在正则匹配的时候不去区分大小写</li>
</ul>
</li>
<li><code>g</code> ： 表示全局匹配<ul>
<li>这个 g 是写在正则的最后面的</li>
<li><code>/\w/g</code></li>
<li>就是全局匹配字母数字下划线</li>
</ul>
</li>
</ul>
<h2 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h2><ul>
<li>正则提供了一些方法给我们使用</li>
<li>用来检测和捕获字符串中的内容的</li>
</ul>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><ul>
<li><p><code>test</code> 是用来检测字符串是否符合我们正则的标准</p>
</li>
<li><p>语法： <code>正则.test(字符串)</code></p>
</li>
<li><p>返回值： boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d+/</span>.test(<span class="string">'123'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d+/</span>.test(<span class="string">'abc'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><ul>
<li><p><code>exec</code> 是把字符串中符合条件的内容捕获出来</p>
</li>
<li><p>语法： <code>正则.exec(字符串)</code></p>
</li>
<li><p>返回值： 把字符串中符合正则要求的第一项以及一些其他信息，以数组的形式返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello123world456你好789'</span></span><br><span class="line"><span class="keyword">var</span> res = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	["123", index: 5, input: "hello123world456你好789", groups: undefined]</span></span><br><span class="line"><span class="comment">    0: "123"</span></span><br><span class="line"><span class="comment">    groups: undefined</span></span><br><span class="line"><span class="comment">    index: 5</span></span><br><span class="line"><span class="comment">    input: "hello123world456你好789"</span></span><br><span class="line"><span class="comment">    length: 1</span></span><br><span class="line"><span class="comment">  	__proto__: Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组第 0 项就是匹配到的字符串内容</li>
<li>index 属性表示从字符串的索引几开始是匹配的到字符串</li>
</ul>
</li>
</ul>
<h2 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h2><ul>
<li>字符串中有一些方法也是可以和正则一起使用的</li>
</ul>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><ul>
<li><p><code>search</code> 是查找字符串中是否有满足正则条件的内容</p>
</li>
<li><p>语法： <code>字符串.search(正则)</code></p>
</li>
<li><p>返回值 ： 有的话返回开始索引，没有返回 -1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello123'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(reg)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.search(reg)) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><ul>
<li><p><code>match</code> 找到字符串中符合正则条件的内容返回</p>
</li>
<li><p>语法： <code>字符串.match(正则)</code></p>
</li>
<li><p>返回值 ： </p>
<ul>
<li>没有标示符 g 的时候，是和 exec 方法一样</li>
<li>有标示符 g 的时候，是返回一个数组，里面是匹配到的每一项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello123world456'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)) </span><br><span class="line"><span class="comment">// ["123", index: 5, input: "hello123wor456", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.match(reg)) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello123world456'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)) </span><br><span class="line"><span class="comment">// ["123", "456"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.match(reg)) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><ul>
<li><p><code>replace</code> 是将字符串中满足正则条件的字符串替换掉</p>
</li>
<li><p>语法： <code>字符串.replace(正则，要替换的字符串)</code></p>
</li>
<li><p>返回值 ： 替换后的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello123world456'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg)) <span class="comment">// hello666world456</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.replace(reg)) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3&#125;/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello123world456'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg)) <span class="comment">// hello666world666</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.replace(reg)) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY3-1_EVENT（上）</title>
    <url>/2021/09/27/DAY3-1/</url>
    <content><![CDATA[<h1 id="EVENT（上）"><a href="#EVENT（上）" class="headerlink" title="EVENT（上）"></a>EVENT（上）</h1><ul>
<li>之前我们简单的了解过一些事件，比如 <code>onclick</code> / <code>onload</code> / <code>onscroll</code> / …</li>
<li>今天开始，我们详细的学习一些 <strong>事件</strong></li>
</ul><h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><ul>
<li><p>一个事件由什么东西组成</p>
<ul>
<li>触发谁的事件：事件源</li>
<li>触发什么事件：事件类型</li>
<li>触发以后做什么：事件处理函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span><br><span class="line"></span><br><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 谁来触发事件 =&gt; oDiv =&gt; 这个事件的事件源就是 oDiv</span></span><br><span class="line"><span class="comment">// 触发什么事件 =&gt; onclick =&gt; 这个事件类型就是 click</span></span><br><span class="line"><span class="comment">// 触发之后做什么 =&gt; function () &#123;&#125; =&gt; 这个事件的处理函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们想要在点击 div 以后做什么事情，就把我们要做的事情写在事件处理函数里面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span><br><span class="line"></span><br><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你点击了 div'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们点击 div 的时候，就会执行事件处理函数内部的代码</li>
<li>每点击一次，就会执行一次事件处理函数</li>
</ul>
</li>
</ul><a id="more"></a>

<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul>
<li><p>什么是事件对象？</p>
</li>
<li><p>就是当你触发了一个事件以后，对该事件的一些描述信息</p>
</li>
<li><p>例如：</p>
<ul>
<li>你触发一个点击事件的时候，你点在哪个位置了，坐标是多少</li>
<li>你触发一个键盘事件的时候，你按的是哪个按钮</li>
<li>…</li>
</ul>
</li>
<li><p>每一个事件都会有一个对应的对象来描述这些信息，我们就把这个对象叫做 <strong>事件对象</strong></p>
</li>
<li><p>浏览器给了我们一个 <strong>黑盒子</strong>，叫做 <code>window.event</code>，就是对事件信息的所有描述</p>
<ul>
<li>比如点击事件</li>
<li>你点在了 <code>0，0</code> 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性</li>
<li>你点在了 <code>10, 10</code> 位置，那么你得到的这个事件对象里面对应的就会有这个点位的属性</li>
<li>…</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.event.X轴坐标点信息)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.event.Y轴坐标点信息)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个玩意很好用，但是一般来说，好用的东西就会有 <strong>兼容性问题</strong></p>
</li>
<li><p>在 <code>IE低版本</code> 里面这个东西好用，但是在 <code>高版本IE</code> 和 <code>Chrome</code> 里面不好使了</p>
</li>
<li><p>我们就得用另一种方式来获取 <strong>事件对象</strong></p>
</li>
<li><p>在每一个事件处理函数的行参位置，默认第一个就是 <strong>事件对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e 就是和 IE 的 window.event 一样的东西</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.X轴坐标点信息)</span><br><span class="line">  <span class="built_in">console</span>.log(e.Y轴坐标点信息)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>综上所述，我们以后在每一个事件里面，想获取事件对象的时候，都用兼容写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e = e || <span class="built_in">window</span>.event</span><br><span class="line">  <span class="built_in">console</span>.log(e.X轴坐标点信息)</span><br><span class="line">  <span class="built_in">console</span>.log(e.Y轴坐标点信息)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="点击事件的光标坐标点获取"><a href="#点击事件的光标坐标点获取" class="headerlink" title="点击事件的光标坐标点获取"></a>点击事件的光标坐标点获取</h2><ul>
<li>刚才即然说了，可以获取到坐标点，那么接下来我们就学习一下怎么获取坐标点</li>
<li>我们的每一个点击事件的坐标点都不是一对，因为要有一个相对的坐标系</li>
<li>例如：<ul>
<li>相对事件源（你点击的元素）</li>
<li>相对页面</li>
<li>相对浏览器窗口</li>
<li>…</li>
</ul>
</li>
<li>因为都不一样，所以我们获取的 <strong>事件对象</strong> 里面的属性也不一样</li>
</ul>
<h3 id="相对于你点击的元素来说"><a href="#相对于你点击的元素来说" class="headerlink" title="相对于你点击的元素来说"></a>相对于你点击的元素来说</h3><ul>
<li><p><code>offsetX</code> 和 <code>offsetY</code></p>
</li>
<li><p>是相对于你点击的元素的边框内侧开始计算</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    border: 10px solid #333;</span><br><span class="line">    margin: 20px 0 0 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 注册点击事件</span></span></span><br><span class="line"><span class="javascript">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 事件对象兼容写法</span></span></span><br><span class="line"><span class="javascript">      e = e || <span class="built_in">window</span>.event</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.offsetX)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.offsetY)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week3/assets/offset.jpg)</p>
</li>
</ul>
<h3 id="相对于浏览器窗口你点击的坐标点"><a href="#相对于浏览器窗口你点击的坐标点" class="headerlink" title="相对于浏览器窗口你点击的坐标点"></a>相对于浏览器窗口你点击的坐标点</h3><ul>
<li><p><code>clientX</code> 和 <code>clientY</code></p>
</li>
<li><p>是相对于浏览器窗口来计算的，不管你页面滚动到什么情况，都是根据窗口来计算坐标</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  body &#123;</span><br><span class="line">    width: 2000px;</span><br><span class="line">    height: 2000px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    border: 10px solid #333;</span><br><span class="line">    margin: 20px 0 0 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 注册点击事件</span></span></span><br><span class="line"><span class="javascript">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 事件对象兼容写法</span></span></span><br><span class="line"><span class="javascript">      e = e || <span class="built_in">window</span>.event</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.clientX)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.clientY)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week3/assets/client.jpg)</p>
</li>
</ul>
<h3 id="相对于页面你点击的坐标点"><a href="#相对于页面你点击的坐标点" class="headerlink" title="相对于页面你点击的坐标点"></a>相对于页面你点击的坐标点</h3><ul>
<li><p><code>pageX</code> 和 <code>pageY</code></p>
</li>
<li><p>是相对于整个页面的坐标点，不管有没有滚动，都是相对于页面拿到的坐标点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  body &#123;</span><br><span class="line">    width: 2000px;</span><br><span class="line">    height: 2000px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    border: 10px solid #333;</span><br><span class="line">    margin: 20px 0 0 30px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 注册点击事件</span></span></span><br><span class="line"><span class="javascript">    oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 事件对象兼容写法</span></span></span><br><span class="line"><span class="javascript">      e = e || <span class="built_in">window</span>.event</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.pageX)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.pageY)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week3/assets/page.jpg)</p>
</li>
<li><p>根据页面左上角来说</p>
<ul>
<li>margin-left 是 30</li>
<li>左边框是 10</li>
<li>左右 padding 各是 20</li>
<li>内容区域是 300</li>
<li><strong>pageX : 300 + 20 + 20 + 10 + 30 = 380</strong></li>
<li>margin-top 是 20</li>
<li>上边框是 10</li>
<li>上下 padding 各是 20</li>
<li>内容区域是 300</li>
<li><strong>pageY : 300 + 20 + 20 + 10 + 20 = 270</strong></li>
</ul>
</li>
</ul>
<h2 id="点击按键信息（了解）"><a href="#点击按键信息（了解）" class="headerlink" title="点击按键信息（了解）"></a>点击按键信息（了解）</h2><ul>
<li>我们的鼠标一般都有两个按键，一个左键一个右键</li>
<li>我们的事件对象里面也有这个信息，确定你点击的是左键还是右键</li>
<li>我们使用 <code>事件对象.button</code> 来获取信息</li>
<li><code>1</code> 为鼠标左键，<code>2</code> 为鼠标右键</li>
</ul>
<h2 id="常见的事件（了解）"><a href="#常见的事件（了解）" class="headerlink" title="常见的事件（了解）"></a>常见的事件（了解）</h2><ul>
<li>我们在写页面的时候经常用到的一些事件</li>
<li>大致分为几类，<strong>浏览器事件</strong> / <strong>鼠标事件</strong> / <strong>键盘事件</strong> / <strong>表单事件</strong> / <strong>触摸事件</strong></li>
<li>不需要都记住，但是大概要知道</li>
</ul>
<h3 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h3><ul>
<li><code>load</code> ： 页面全部资源加载完毕</li>
<li><code>scroll</code> ： 浏览器滚动的时候触发</li>
<li>…</li>
</ul>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li><code>click</code> ：点击事件</li>
<li><code>dblclick</code> ：双击事件</li>
<li><code>contextmenu</code> ： 右键单击事件</li>
<li><code>mousedown</code> ：鼠标左键按下事件</li>
<li><code>mouseup</code> ：鼠标左键抬起事件</li>
<li><code>mousemove</code> ：鼠标移动</li>
<li><code>mouseover</code> ：鼠标移入事件</li>
<li><code>mouseout</code> ：鼠标移出事件</li>
<li><code>mouseenter</code> ：鼠标移入事件</li>
<li><code>mouseleave</code> ：鼠标移出事件</li>
<li>…</li>
</ul>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li><code>keyup</code> ： 键盘抬起事件</li>
<li><code>keydown</code> ： 键盘按下事件</li>
<li><code>keypress</code> ： 键盘按下再抬起事件</li>
<li>…</li>
</ul>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><ul>
<li><code>change</code> : 表单内容改变事件</li>
<li><code>input</code> : 表单内容输入事件</li>
<li><code>submit</code> : 表单提交事件</li>
<li>…</li>
</ul>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><ul>
<li><code>touchstart</code> ： 触摸开始事件</li>
<li><code>touchend</code> ： 触摸结束事件</li>
<li><code>touchmove</code> ： 触摸移动事件</li>
<li>…</li>
</ul>
<h2 id="键盘事件-1"><a href="#键盘事件-1" class="headerlink" title="键盘事件"></a>键盘事件</h2><ul>
<li><p>刚才了解了一下鼠标事件，现在来聊聊键盘事件</p>
</li>
<li><p>我们在键盘事件里面最主要的就是要做两个事情</p>
<ul>
<li>判断点击的是哪个按键</li>
<li>有没有组合按键，<strong>shift + a</strong> / <strong>ctrl + b</strong> / …</li>
</ul>
</li>
<li><p>我们先要明确一个问题，就是是不是所有元素都可以绑定键盘事件</p>
<ul>
<li>我们说事件有一个关键的东西是，该事件是由谁来触发的</li>
<li>一个 div 元素在页面上，我怎么能让一个键盘事件触发在 div 上</li>
<li>所以说，我们一般只给能在页面上选中的元素（表单元素） 和 <code>document</code> 来绑定键盘事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// code.. &#125; </span></span><br><span class="line">oInput.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// code.. &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="确定按键"><a href="#确定按键" class="headerlink" title="确定按键"></a>确定按键</h3><ul>
<li><p>我们的键盘上每一个按键都有一个自己独立的编码</p>
</li>
<li><p>我们就是靠这个编码来确定我们按下的是哪个按键的</p>
</li>
<li><p>我们通过 <code>事件对象.keyCode</code> 或者 <code>事件对象.which</code> 来获取</p>
</li>
<li><p>为什么要有两个呢，是因为 FireFox2.0 不支持 <code>keycode</code> 所以要用 <code>which</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.keyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件对象的兼容写法</span></span><br><span class="line">  e = e || <span class="built_in">window</span>.event</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取键盘码的兼容写法</span></span><br><span class="line">  <span class="keyword">var</span> keyCode = e.keyCode || e.which</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(keyCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常见的键盘码（了解）"><a href="#常见的键盘码（了解）" class="headerlink" title="常见的键盘码（了解）"></a>常见的键盘码（了解）</h4><ul>
<li>8： 删除键（delete）</li>
<li>9： 制表符（tab）</li>
<li>13： 回车键（ebter）</li>
<li>16： 上档键（shift）</li>
<li>17： ctrl 键</li>
<li>18： alt 键</li>
<li>27： 取消键（esc）</li>
<li>32： 空格键（space）</li>
<li>…</li>
</ul>
<h3 id="组合按键"><a href="#组合按键" class="headerlink" title="组合按键"></a>组合按键</h3><ul>
<li><p>组合案件最主要的就是 <code>alt</code> / <code>shift</code> / <code>ctrl</code> 三个按键</p>
</li>
<li><p>在我点击某一个按键的时候判断一下这三个键有没有按下，有就是组合了，没有就是没有组合</p>
</li>
<li><p>事件对象里面也为我们提供了三个属性</p>
<ul>
<li><code>altKey</code> ：alt 键按下得到 true，否则得到 false</li>
<li><code>shiftKey</code> ：shift 键按下得到 true，否则得到 false</li>
<li><code>ctrlKey</code> ：ctrl 键按下得到 true，否则得到 false</li>
</ul>
</li>
<li><p>我们就可以通过这三个属性来判断是否按下了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e = e || <span class="built_in">window</span>.event</span><br><span class="line">  keyCode = e.keyCode || e.which</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (e.altKey &amp;&amp; keyCode === <span class="number">65</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你同时按下了 alt 和 a'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="事件的绑定方式"><a href="#事件的绑定方式" class="headerlink" title="事件的绑定方式"></a>事件的绑定方式</h2><ul>
<li><p>我们现在给一个注册事件都是使用 <code>onxxx</code> 的方式</p>
</li>
<li><p>但是这个方式不是很好，只能给一个元素注册一个事件</p>
</li>
<li><p>一旦写了第二个事件，那么第一个就被覆盖了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是第一个事件'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是第二个事件'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当你点击的时候，只会执行第二个，第一个就没有了</li>
</ul>
</li>
<li><p>我们还有一种事件监听的方式去给元素绑定事件</p>
</li>
<li><p>使用 <code>addEventListener</code> 的方式添加</p>
<ul>
<li>这个方法不兼容，在 IE 里面要使用 <code>attachEvent</code></li>
</ul>
</li>
</ul>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><ul>
<li><p><code>addEventListener</code> :  非 IE 7 8 下使用</p>
</li>
<li><p>语法： <code>元素.addEventListener(&#39;事件类型&#39;， 事件处理函数， 冒泡还是捕获)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是第一个事件'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">oDiv.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是第二个事件'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序执行</li>
<li>先打印 <code>我是第一个事件</code> 再打印 <code>我是第二个事件</code></li>
<li>注意： <strong>事件类型的时候不要写 on，点击事件就是 click，不是 onclick</strong></li>
</ul>
</li>
<li><p><code>attachEvent</code> ：IE 7 8 下使用</p>
</li>
<li><p>语法： <code>元素.attachEvent(&#39;事件类型&#39;， 事件处理函数)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是第一个事件'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">oDiv.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是第二个事件'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>当你点击 div 的时候，两个函数都会执行，并且会按照你注册的顺序倒叙执行</li>
<li>先打印 <code>我是第二个事件</code> 再打印 <code>我是第一个事件</code></li>
<li>注意： <strong>事件类型的时候要写 on，点击事件就行 onclick</strong></li>
</ul>
</li>
</ul>
<h3 id="两个方式的区别"><a href="#两个方式的区别" class="headerlink" title="两个方式的区别"></a>两个方式的区别</h3><ul>
<li>注册事件的时候事件类型参数的书写<ul>
<li><code>addEventListener</code> ： 不用写 on</li>
<li><code>attachEvent</code> ： 要写 on</li>
</ul>
</li>
<li>参数个数<ul>
<li><code>addEventListener</code> ： 一般是三个常用参数</li>
<li><code>attachEvent</code> ： 两个参数</li>
</ul>
</li>
<li>执行顺序<ul>
<li><code>addEventListener</code> ： 顺序注册，顺序执行</li>
<li><code>attachEvent</code> ： 顺序注册，倒叙执行</li>
</ul>
</li>
<li>适用浏览器<ul>
<li><code>addEventListener</code> ： 非 IE 7 8 的浏览器</li>
<li><code>attachEvent</code> ： IE 7 8 浏览器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY3-2_EVENT（下）</title>
    <url>/2021/09/27/DAY3-2/</url>
    <content><![CDATA[<h1 id="EVENT（下）"><a href="#EVENT（下）" class="headerlink" title="EVENT（下）"></a>EVENT（下）</h1><ul>
<li><p>今天来聊一聊事件的执行机制</p>
</li>
<li><p>什么是事件的执行机制呢？</p>
<ul>
<li><p>思考一个问题？</p>
</li>
<li><p>当一个大盒子嵌套一个小盒子的时候，并且两个盒子都有点击事件</p>
</li>
<li><p>你点击里面的小盒子，外面的大盒子上的点击事件要不要执行</p>
<p><img src="J:/qf(二阶段" alt>资料/day1-1/课程资料/课程资料/week3/assets/event传播.jpg)</p>
</li>
</ul>
</li>
</ul><a id="more"></a>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><ul>
<li>就像上面那个图片一样，我们点击在红色盒子身上的同时，也是点击在了粉色盒子上</li>
<li>这个是既定事实，那么两个盒子的点击事件都会触发</li>
<li>这个就叫做 <strong>事件的传播</strong><ul>
<li><strong>当元素触发一个事件的时候，其父元素也会触发相同的事件，父元素的父元素也会触发相同的事件</strong></li>
<li>就像上面的图片一样</li>
<li>点击在红色盒子上的时候，会触发红色盒子的点击事件</li>
<li>也是点击在了粉色的盒子上，也会触发粉色盒子的点击事件</li>
<li>也是点击在了 body 上，也会触发 body 的点击事件</li>
<li>也是点击在了 html 上，也会触发 html 的点击事件</li>
<li>也是点击在了 document 上，也会触发 document 的点击事件</li>
<li>也是点击在了 window 上，也会触发 window 的点击事件</li>
<li>也就是说，页面上任何一个元素触发事件，都会一层一层最终导致 window 的相同事件触发，前提是各层级元素得有注册相同的事件，不然不会触发</li>
</ul>
</li>
<li>在事件传播的过程中，有一些注意的点：<ol>
<li>只会传播同类事件</li>
<li>只会从点击元素开始按照 html 的结构逐层向上元素的事件会被触发</li>
<li>内部元素不管有没有该事件，只要上层元素有该事件，那么上层元素的事件就会被触发</li>
</ol>
</li>
<li>到现在，我们已经了解了事件的传播，我们再来思考一个问题<ul>
<li>事件确实会从自己开始，到 window 的所有相同事件都会触发</li>
<li>是因为我们点在自己身上，也确实逐层的点在了直至 window 的每一个元素身上</li>
<li>但是到底是先点在自己身上，还是先点在了 window 身上呢</li>
<li>先点在自己身上，就是先执行自己的事件处理函数，逐层向上最后执行 window 的事件处理函数</li>
<li>反之，则是先执行 window 的事件处理函数，逐层向下最后执行自己身上的事件处理函数</li>
</ul>
</li>
</ul>
<h2 id="冒泡、捕获、目标"><a href="#冒泡、捕获、目标" class="headerlink" title="冒泡、捕获、目标"></a>冒泡、捕获、目标</h2><ul>
<li>我们刚才聊过了，每一个事件，都是有可能从自己到 window ，有可能要执行多个同类型事件</li>
<li>那么这个执行的顺序就有一些说法了</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>你是点击在哪个元素身上了，那么这个事件的 <strong>目标</strong> 就是什么</li>
</ul>
<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><ul>
<li>就是从事件 <strong>目标</strong> 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发</li>
<li>也就是从下向上的执行事件处理函数</li>
</ul>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><ul>
<li>就是从 window 的事件处理函数开始，依次向内，只要事件 <strong>目标</strong> 的事件处理函数执行</li>
<li>也就是从上向下的执行事件处理函数</li>
</ul>
<h3 id="冒泡和捕获的区别"><a href="#冒泡和捕获的区别" class="headerlink" title="冒泡和捕获的区别"></a>冒泡和捕获的区别</h3><ul>
<li>就是在事件的传播中，多个同类型事件处理函数的执行顺序不同</li>
</ul>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul>
<li>就是把我要做的事情委托给别人来做</li>
<li>因为我们的冒泡机制，点击子元素的时候，也会同步触发父元素的相同事件</li>
<li>所以我们就可以把子元素的事件委托给父元素来做</li>
</ul>
<h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><ul>
<li><p>点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oUl = docuemnt.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    oUl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'我是 ul 的点击事件，我被触发了'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>像上面一段代码，当你点击 ul 的时候肯定会触发</li>
<li>但是当你点击 li 的时候，其实也会触发</li>
</ul>
</li>
</ul>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><ul>
<li><p>target 这个属性是事件对象里面的属性，表示你点击的目标</p>
</li>
<li><p>当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素</p>
</li>
<li><p>这个 target 也不兼容，在 IE 下要使用 srcElement</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oUl = docuemnt.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    oUl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      e = e || <span class="built_in">window</span>.event</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> target = e.target || e.srcElement</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(target)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码，当你点击 ul 的时候，target 就是 ul</li>
<li>当你点击在 li 上面的时候，target 就是 li</li>
</ul>
</li>
</ul>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><ul>
<li><p>这个时候，当我们点击 li 的时候，也可以触发 ul 的点事件</p>
</li>
<li><p>并且在事件内不，我们也可以拿到你点击的到底是 ul 还是 li</p>
</li>
<li><p>这个时候，我们就可以把 li 的事件委托给 ul 来做</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> oUl = docuemnt.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    oUl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      e = e || <span class="built_in">window</span>.event</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> target = e.target || e.srcElement</span></span><br><span class="line">     </span><br><span class="line"><span class="javascript">      <span class="comment">// 判断你点击的是 li</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (target.nodeName.toUpperCase === <span class="string">'LI'</span>) &#123;</span></span><br><span class="line"><span class="javascript">      	<span class="comment">// 确定点击的是 li</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 因为当你点击在 ul 上面的时候，nodeName 应该是 'UL'</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 去做点击 li 的时候该做的事情了</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'我是 li，我被点击了'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码，我们就可以把 li 要做的事情委托给 ul 来做</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>为什么要用事件委托<ul>
<li>我页面上本身没有 li</li>
<li>我通过代码添加了一些 li</li>
<li>添加进来的 li 是没有点击事件的</li>
<li>我每次动态的操作完 li 以后都要从新给 li 绑定一次点击事件</li>
<li>比较麻烦</li>
<li>这个时候只要委托给 ul 就可以了</li>
<li>因为新加进来的 li 也是 ul 的子元素，点击的时候也可以触发 ul 的点击事件</li>
</ul>
</li>
<li>事件委托的书写<ul>
<li>元素的事件只能委托给结构父级或者再结构父级的同样的事件上</li>
<li>li 的点击事件，就不能委托给 ul 的鼠标移入事件</li>
<li>li 的点击事件，只能委托给 ul 或者在高父级的点击事件上</li>
</ul>
</li>
</ul>
<h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h2><ul>
<li>默认行为，就是不用我们注册，它自己就存在的事情<ul>
<li>比如我们点击鼠标右键的时候，会自动弹出一个菜单</li>
<li>比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面</li>
<li>…</li>
</ul>
</li>
<li>这些不需要我们注册就能实现的事情，我们叫做 <strong>默认事件</strong></li>
</ul>
<h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><ul>
<li><p>有的时候，我们不希望浏览器执行默认事件</p>
<ul>
<li>比如我给 a 标签绑定了一个点击事件，我点击你的时候希望你能告诉我你的地址是什么</li>
<li>而不是直接跳转链接</li>
<li>那么我们就要把 a 标签原先的默认事件阻止，不让他执行默认事件</li>
</ul>
</li>
<li><p>我们有两个方法来阻止默认事件</p>
<ul>
<li><code>e.preventDefault()</code> : 非 IE 使用</li>
<li><code>e.returnValue = false</code> ：IE 使用</li>
</ul>
</li>
<li><p>我们阻止默认事件的时候也要写一个兼容的写法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>点击我试试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> oA = <span class="built_in">document</span>.querySelector(<span class="string">'a'</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  a.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    e = e || <span class="built_in">window</span>.event</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.href)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    e.preventDefault ? e.preventDefault() : e.returnValue = <span class="literal">false</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这样写完以后，你点击 a 标签的时候，就不会跳转链接了</li>
<li>而是会在控制台打印出 a 标签的 href 属性的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY3-4_ES5和ES6</title>
    <url>/2021/09/27/DAY3-4/</url>
    <content><![CDATA[<h1 id="ES5和ES6"><a href="#ES5和ES6" class="headerlink" title="ES5和ES6"></a>ES5和ES6</h1><ul>
<li>我们所说的 ES5 和 ES6 其实就是在 js 语法的发展过程中的一个版本而已</li>
<li>比如我们使用的微信<ul>
<li>最早的版本是没有支付功能的</li>
<li>随着时间的流逝，后来出现了一个版本，这个版本里面有支付功能了</li>
</ul>
</li>
<li>ECMAScript 就是 js 的语法<ul>
<li>以前的版本没有某些功能</li>
<li>在 ES5 这个版本的时候增加了一些功能</li>
<li>在 ES6 这个版本的时候增加了一些功能</li>
</ul>
</li>
<li>因为浏览器是浏览器厂商生产的<ul>
<li>ECMAScript 发布了新的功能以后，浏览器厂商需要让自己的浏览器支持这些功能</li>
<li>这个过程是需要时间的</li>
<li>所以到现在，基本上大部分浏览器都可以比较完善的支持了</li>
<li>只不过有些浏览器还是不能全部支持</li>
<li>这就出现了兼容性问题</li>
<li>所以我们写代码的时候就要考虑哪些方法是 ES5 或者 ES6 的，看看是不是浏览器都支持</li>
</ul>
</li>
</ul><a id="more"></a>
<h2 id="ES5-增加的数组常用方法"><a href="#ES5-增加的数组常用方法" class="headerlink" title="ES5 增加的数组常用方法"></a>ES5 增加的数组常用方法</h2><h3 id="数组方法之-forEach"><a href="#数组方法之-forEach" class="headerlink" title="数组方法之 forEach"></a>数组方法之 forEach</h3><ul>
<li><p><code>forEach</code> 用于遍历数组，和 for 循环遍历数组一个道理</p>
</li>
<li><p>语法： <code>数组.forEach(function (item, index, arr) {})</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="comment">// forEach 就是将数组循环遍历，数组中有多少项，那么这个函数就执行多少回</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这个函数内部</span></span><br><span class="line">  <span class="comment">// item 就是数组中的每一项</span></span><br><span class="line">  <span class="comment">// index 就是每一项对应的索引</span></span><br><span class="line">  <span class="comment">// arr 就是原始数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(item) </span><br><span class="line">  <span class="built_in">console</span>.log(index) </span><br><span class="line">  <span class="built_in">console</span>.log(arr) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码就等价于</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  fn(arr[i], i, arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">  <span class="built_in">console</span>.log(index)</span><br><span class="line">  <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组方法之-map"><a href="#数组方法之-map" class="headerlink" title="数组方法之 map"></a>数组方法之 map</h3><ul>
<li><p><code>map</code> 用于遍历数组，和 forEach 基本一致，只不过是有一个返回值</p>
</li>
<li><p>语法： <code>数组.map(function (item, index, arr) {})</code></p>
</li>
<li><p>返回值： 一个新的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="comment">// forEach 就是将数组循环遍历，数组中有多少项，那么这个函数就执行多少回</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数里面的三个参数和 forEach 一样</span></span><br><span class="line">  <span class="comment">// 我们可以在这里操作数组中的每一项，</span></span><br><span class="line">  <span class="comment">// return 操作后的每一项</span></span><br><span class="line">  <span class="keyword">return</span> item + <span class="string">'11'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// ["a11", "b11", "c11"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值就是我们每次对数组的操作</li>
<li>等价于</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  newArr.push(fn(arr[i], i, arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="string">'11'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组方法之-filter"><a href="#数组方法之-filter" class="headerlink" title="数组方法之 filter"></a>数组方法之 filter</h3><ul>
<li><p><code>filter</code> ： 是将数组遍历一遍，按照我们的要求把数数组中符合的内容过滤出来</p>
</li>
<li><p>语法： <code>数组.filter(function (item, index, arr) {})</code></p>
</li>
<li><p>返回值： 根据我们的条件过滤出来的新数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内部的三个参数和 forEach 一样</span></span><br><span class="line">  <span class="comment">// 我们把我们的条件 return 出去</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>新数组里面全都是大于 2 的数字</li>
<li>等价于</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fn(arr[i], i, arr)) &#123;</span><br><span class="line">    newArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JSON-方法"><a href="#JSON-方法" class="headerlink" title="JSON 方法"></a>JSON 方法</h2><ul>
<li><p><code>json</code> 是一种特殊的字符串个是，本质是一个字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="string">'&#123; "name": "Jack", "age": 18, "gender": "男" &#125;'</span></span><br><span class="line"><span class="keyword">var</span> jsonArr = <span class="string">'[&#123; "name": "Jack", "age": 18, "gender": "男" &#125;, &#123; "name": "Jack", "age": 18, "gender": "男" &#125;, &#123; "name": "Jack", "age": 18, "gender": "男" &#125;]'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>就是对象内部的 <code>key</code> 和 <code>value</code> 都用双引号包裹的字符串（必须是双引号）</p>
</li>
</ul>
<h2 id="JSON的两个方法"><a href="#JSON的两个方法" class="headerlink" title="JSON的两个方法"></a>JSON的两个方法</h2><ul>
<li>我们有两个方法可以使用 <strong>JSON.parse</strong></li>
<li></li>
<li><code>json.stringify</code> 是将 js 的对象或者数组转换成为 json 格式的字符串</li>
</ul>
<h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><ul>
<li><p><code>JSON.parse</code>  是将 json 格式的字符串转换为 js 的对象或者数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="string">'&#123; "name": "Jack", "age": 18, "gender": "男" &#125;'</span></span><br><span class="line"><span class="keyword">var</span> jsonArr = <span class="string">'[&#123; "name": "Jack", "age": 18, "gender": "男" &#125;, &#123; "name": "Jack", "age": 18, "gender": "男" &#125;, &#123; "name": "Jack", "age": 18, "gender": "男" &#125;]'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(jsonStr)</span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">JSON</span>.parse(jsonArr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj</code> 就是我们 js 的对象</li>
<li><code>arr</code> 就是我们 js 的数组</li>
</ul>
</li>
</ul>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><ul>
<li><p><code>JSON.parse</code>  是将 json 格式的字符串转换为 js 的对象或者数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    gender: <span class="string">'男'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    gender: <span class="string">'男'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    gender: <span class="string">'男'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line"><span class="keyword">var</span> jsonArr = <span class="built_in">JSON</span>.stringify(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonObj)</span><br><span class="line"><span class="built_in">console</span>.log(jsonArr)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>jsonObj</code> 就是 json 格式的对象字符串</li>
<li><code>jsonArr</code> 就是 json 格式的数组字符串</li>
</ul>
</li>
</ul>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><ul>
<li><p>每一个函数内部都有一个关键字是 <code>this</code> </p>
</li>
<li><p>可以让我们直接使用的</p>
</li>
<li><p>重点： <strong>函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系</strong></p>
</li>
<li><p>函数内部的 this 指向谁，取决于函数的调用方式</p>
<ul>
<li><p>全局定义的函数直接调用，<code>this =&gt; window</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// 此时 this 指向 window</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象内部的方法调用，<code>this =&gt; 调用者</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br><span class="line"><span class="comment">// 此时 this 指向 obj</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器的处理函数，<code>this =&gt; window</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 此时定时器处理函数里面的 this 指向 window</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件处理函数，<code>this =&gt; 事件源</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当你点击 div 的时候，this 指向 div</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自调用函数，<code>this =&gt; window</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 此时 this 指向 window</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="call-和-apply-和-bind"><a href="#call-和-apply-和-bind" class="headerlink" title="call 和 apply 和 bind"></a>call 和 apply 和 bind</h3><ul>
<li>刚才我们说过的都是函数的基本调用方式里面的 this 指向</li>
<li>我们还有三个可以忽略函数本身的 this 指向转而指向别的地方</li>
<li>这三个方法就是 <strong>call</strong> / <strong>apply</strong> / <strong>bind</strong></li>
<li>是强行改变 this 指向的方法</li>
</ul>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><ul>
<li><p><code>call</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向</p>
</li>
<li><p>语法： <code>函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fn.call(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fn()</code> 的时候，函数内部的 this 指向 window</li>
<li><code>fn.call(obj, 1, 2)</code> 的时候，函数内部的 this 就指向了 obj 这个对象</li>
<li>使用 call 方法的时候<ul>
<li>会立即执行函数</li>
<li>第一个参数是你要改变的函数内部的 this 指向</li>
<li>第二个参数开始，依次是向函数传递参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><ul>
<li><p><code>apply</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向</p>
</li>
<li><p>语法： <code>函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fn.call(obj, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fn()</code> 的时候，函数内部的 this 指向 window</li>
<li><code>fn.apply(obj, [1, 2])</code> 的时候，函数内部的 this 就指向了 obj 这个对象</li>
<li>使用 apply 方法的时候<ul>
<li>会立即执行函数</li>
<li>第一个参数是你要改变的函数内部的 this 指向</li>
<li>第二个参数是一个 <strong>数组</strong>，数组里面的每一项依次是向函数传递的参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><ul>
<li><p><code>bind</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 this 指向</p>
</li>
<li><p>和 call / apply 有一些不一样，就是不会立即执行函数，而是返回一个已经改变了 this 指向的函数</p>
</li>
<li><p>语法： <code>var newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> newFn = fn.bind(obj)</span><br><span class="line">newFn(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>bind 调用的时候，不会执行 fn 这个函数，而是返回一个新的函数</li>
<li>这个新的函数就是一个改变了 this 指向以后的 fn 函数</li>
<li><code>fn(1, 2)</code> 的时候 this 指向 window</li>
<li><code>newFn(1, 2)</code> 的时候执行的是一个和 fn 一摸一样的函数，只不过里面的 this 指向改成了 obj</li>
</ul>
</li>
</ul>
<h2 id="ES6新增的内容"><a href="#ES6新增的内容" class="headerlink" title="ES6新增的内容"></a>ES6新增的内容</h2><ul>
<li>之前的都是 ES5 的内容</li>
<li>接下来我们聊一下 ES6 的内容</li>
</ul>
<h3 id="let-和-const-关键字"><a href="#let-和-const-关键字" class="headerlink" title="let 和 const 关键字"></a>let 和 const 关键字</h3><ul>
<li><p>我们以前都是使用 <code>var</code> 关键字来声明变量的</p>
</li>
<li><p>在 ES6 的时候，多了两个关键字 <code>let</code> 和 <code>const</code>，也是用来声明变量的</p>
</li>
<li><p>只不过和 var 有一些区别</p>
<ol>
<li><p><code>let</code> 和 <code>const</code> 不允许重复声明变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 let 重复声明变量的时候就会报错了</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">200</span> <span class="comment">// 这里就会报错了</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 const 重复声明变量的时候就会报错</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">200</span> <span class="comment">// 这里就会报错了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>let</code> 和 <code>const</code> 声明的变量不会在预解析的时候解析（也就是没有变量提升）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 let 不会进行预解析（变量提升），所以直接报错了</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 const 不会进行预解析（变量提升），所以直接报错了</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>let</code> 和 <code>const</code> 声明的变量会被所有代码块限制作用范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 声明的变量只有函数能限制其作用域，其他的不能限制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>let</code> 和 <code>const</code> 的区别</p>
<ol>
<li><p><code>let</code> 声明的变量的值可以改变，<code>const</code> 声明的变量的值不可以改变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line">num = <span class="number">200</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line">num = <span class="number">200</span> <span class="comment">// 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>let</code> 声明的时候可以不赋值，<code>const</code> 声明的时候必须赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num</span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num <span class="comment">// 这里就会报错了，因为 const 声明的时候必须赋值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul>
<li><p>箭头函数是 ES6 里面一个简写函数的语法方式</p>
</li>
<li><p>重点： <strong>箭头函数只能简写函数表达式，不能简写声明式函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 不能简写</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 可以简写</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 可以简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>语法： <code>(函数的行参) =&gt; { 函数体内要执行的代码 }</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用箭头函数写成</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用箭头函数写成</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  fn: <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="箭头函数的特殊性"><a href="#箭头函数的特殊性" class="headerlink" title="箭头函数的特殊性"></a>箭头函数的特殊性</h4><ul>
<li><p>箭头函数内部没有 this，箭头函数的 this 是上下文的 this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的</span></span><br><span class="line"><span class="comment">// 因为这里的 this 是 window</span></span><br><span class="line"><span class="comment">// 所以箭头函数内部的 this 就是 window</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这个位置是箭头函数的上一行，但是不能打印出 this</span></span><br><span class="line">  fun: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()</span><br><span class="line">obj.fun()</span><br></pre></td></tr></table></figure>
<ul>
<li>按照我们之前的 this 指向来判断，两个都应该指向 obj</li>
<li>但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window</li>
</ul>
</li>
<li><p>箭头函数内部没有 <code>arguments</code> 这个参数集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fun: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 会打印一个伪数组 [1, 2, 3]</span></span><br><span class="line">obj.fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 会直接报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的行参只有一个的时候可以不写 <code>()</code> 其余情况必须写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'没有参数，必须写小括号'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fn2: <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'一个行参，可以不写小括号'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fn3: <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'两个或两个以上参数，必须写小括号'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体只有一行代码的时候，可以不写 <code>{}</code> ，并且会自动 return</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  fun: <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(fun(<span class="number">10</span>)) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数传递参数的时候的默认值"><a href="#函数传递参数的时候的默认值" class="headerlink" title="函数传递参数的时候的默认值"></a>函数传递参数的时候的默认值</h3><ul>
<li><p>我们在定义函数的时候，有的时候需要一个默认值出现</p>
</li>
<li><p>就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a = a || <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()   <span class="comment">// 不传递参数的时候，函数内部的 a 就是 10</span></span><br><span class="line">fn(<span class="number">20</span>) <span class="comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 ES6 中我们可以直接把默认值写在函数的行参位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()   <span class="comment">// 不传递参数的时候，函数内部的 a 就是 10</span></span><br><span class="line">fn(<span class="number">20</span>) <span class="comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个默认值的方式箭头函数也可以使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a = <span class="number">10</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()   <span class="comment">// 不传递参数的时候，函数内部的 a 就是 10</span></span><br><span class="line">fn(<span class="number">20</span>) <span class="comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （）</strong></li>
</ul>
</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul>
<li>解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式</li>
</ul>
<h4 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h4><ul>
<li><p>快速的从对象中获取成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的方法向得到对象中的成员</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = obj.name</span><br><span class="line"><span class="keyword">let</span> age = obj.age</span><br><span class="line"><span class="keyword">let</span> gender = obj.gender</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构赋值的方式从对象中获取成员</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的 &#123;&#125; 表示我要从 obj 这个对象中获取成员了</span></span><br><span class="line"><span class="comment">// name age gender 都得是 obj 中有的成员</span></span><br><span class="line"><span class="comment">// obj 必须是一个对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, gender &#125; = obj</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h4><ul>
<li><p>快速的从数组中获取成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的方式从数组中获取成员</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Jack'</span>, <span class="string">'Rose'</span>, <span class="string">'Tom'</span>]</span><br><span class="line"><span class="keyword">let</span> a = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> b = arr[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> c = arr[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用解构赋值的方式从数组中获取成员</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Jack'</span>, <span class="string">'Rose'</span>, <span class="string">'Tom'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的 [] 表示要从 arr 这个数组中获取成员了</span></span><br><span class="line"><span class="comment">// a b c 分别对应这数组中的索引 0 1 2</span></span><br><span class="line"><span class="comment">// arr 必须是一个数组</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><code>{}</code> 是专门解构对象使用的</li>
<li><code>[]</code> 是专门解构数组使用的</li>
<li>不能混用</li>
</ul>
<h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h3><ul>
<li><p>ES5 中我们表示字符串的时候使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code></p>
</li>
<li><p>在 ES6 中，我们还有一个东西可以表示字符串，就是 <strong><code></code></strong>（反引号）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`hello world`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str) <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和单引号好友双引号的区别</p>
<ol>
<li><p>反引号可以换行书写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个单引号或者双引号不能换行，换行就会报错了</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello world'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个就报错了</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'hello </span></span><br><span class="line"><span class="string">world'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">	hello</span></span><br><span class="line"><span class="string">	world</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 是可以使用的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>反引号可以直接在字符串里面拼接变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 需要字符串拼接变量的时候</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span> + num + <span class="string">'world'</span> + num</span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// hello100world100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写在字符串里面不好使</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'hellonumworldnum'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2) <span class="comment">// hellonumworldnum</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模版字符串拼接变量</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`hello<span class="subst">$&#123;num&#125;</span>world<span class="subst">$&#123;num&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// hello100world100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 <strong><code></code></strong> 里面的 <code>${}</code> 就是用来书写变量的位置</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><ul>
<li><p>ES6 里面号新添加了一个运算符 <code>...</code> ，叫做展开运算符</p>
</li>
<li><p>作用是把数组展开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数组的时候可以使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以合并对象使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数传递参数的时候也可以使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line">fn(...arr)</span><br><span class="line"><span class="comment">// 等价于 fn(1, 2, 3)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY5-1_PHP</title>
    <url>/2021/11/03/DAY5-1-PHP/</url>
    <content><![CDATA[<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><ul>
<li>PHP 一门后端语言</li>
<li>为什么要学习一个后端语言呢？<ul>
<li>目前市场上的需求，要求前端人员掌握一个后端语言</li>
<li>方便和后端开发人员进行交互</li>
</ul>
</li>
</ul><h2 id="基本组织架构"><a href="#基本组织架构" class="headerlink" title="基本组织架构"></a>基本组织架构</h2><ul>
<li>在讲后端语言之前，我们简单的了解一下我们基本的组织架构</li>
<li>我们是一个 <strong>前端开发工程师</strong></li>
<li>还有一个工作叫做 <strong>后端开发工程师</strong></li>
<li>我们一个网站的组织架构基本上由下面的步骤完成<ul>
<li><strong>用户</strong> =&gt; <strong>前端</strong> =&gt; <strong>后端</strong> =&gt; <strong>数据库</strong></li>
</ul>
</li>
</ul><a id="more"></a>

<ul>
<li>整个过程中<ul>
<li>用户向前端人员要一个网页</li>
<li>前端人员准备一个网页给用户，但是网页中的数据是找后端人员要的</li>
<li>后端人员接受到前端人员要数据以后，去数据库里面找到对应的数据，给到前端人员</li>
<li>前端人员拿到数据以后渲染在页面上</li>
<li>最后把这个页面给到用户看</li>
</ul>
</li>
</ul>
<ul>
<li>比如： 我们浏览一个新闻网站<ul>
<li>用户输入网址</li>
<li>前端人员就要把对应的页面给到用户，在页面打开的过程中，想后端人员索要新闻信息</li>
<li>后端人员接收到前端人员索要新闻信息以后，就去数据库中找到对应的新闻信息数据给前端人员</li>
<li>前端人员接收到后端人员给的新闻信息以后，使用我们的办法吧新闻信息数据渲染在页面上</li>
<li>页面就打开了，用户就可以看到一个新闻网站了</li>
</ul>
</li>
</ul>
<ul>
<li>比如： 用户登陆一个网站<ul>
<li>当用户书写完表单内容以后，点击提交按钮的时候</li>
<li>前端人员拿到用户填写的内容，把数据整合好传送给后端人员</li>
<li>后端人员接收到数据以后，去数据库中进行比对，看看有没有对应的数据</li>
<li>然后告诉前端人员，你给我的用户名和密码是否正确</li>
<li>前端吧信息反馈给客户看到<ul>
<li>如果正确就是跳转页面</li>
<li>如果不正确提示用户名或者密码有问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="服务器的简单理解"><a href="#服务器的简单理解" class="headerlink" title="服务器的简单理解"></a>服务器的简单理解</h2><ul>
<li>我们不可能把数据库丢在用户的电脑上</li>
<li>一个是太大，一个是不安全</li>
<li>所以我们要把数据库放在网络的另一端（远程）</li>
<li>所以当前端人员向后端人员索要数据的时候需要网络</li>
<li>我们也不可能把页面也放在用户的电脑上</li>
<li>所以用户也是需要网络来向前端人员所有页面</li>
</ul>
<h2 id="服务器的认识"><a href="#服务器的认识" class="headerlink" title="服务器的认识"></a>服务器的认识</h2><ul>
<li>我们现在的市场上有一些常见的服务器可以承载内容</li>
<li>我们目前比较常用的就是 <code>Apache</code> 和 <code>Tomcat</code></li>
<li>我们今天要学习的就是 <code>Apache</code> 服务器</li>
<li>是一个和 <code>php</code> 语言合作比较紧密的一个服务器</li>
</ul>
<h3 id="到底什么是服务器"><a href="#到底什么是服务器" class="headerlink" title="到底什么是服务器"></a>到底什么是服务器</h3><ul>
<li>其实说白了，服务器就是一个电脑，当他跑起来一些程序的时候，就变成了一个服务器</li>
<li>只不过会跑一些特殊的程序，需要一些特殊的环境，电脑不他一样而已</li>
<li>换句话说，我们自己的电脑，跑一些特殊的程序的时候，也可以当作一个小型的服务器来用<ul>
<li>只不过计算能力/存储能力/转存能力没有专业的服务器电脑厉害而已</li>
</ul>
</li>
</ul>
<h3 id="服务器是怎么访问的呢"><a href="#服务器是怎么访问的呢" class="headerlink" title="服务器是怎么访问的呢"></a>服务器是怎么访问的呢</h3><ul>
<li>涉及到我们的 <code>url</code> 地址中的一些内容了</li>
<li>比如我们的经常访问的 <code>www.baidu.com</code></li>
<li>这个里面就包含很多的内容，我们看到的这个只是一个省略后的内容</li>
<li>是浏览器帮我们省略掉了一些内容</li>
<li>全部的地址应该是 <code>https://www.baidu.com:443</code></li>
<li>发现多了两个东西 <code>https://</code> 和 <code>:443</code></li>
<li>其实一个简单的 <code>url</code> 地址是由三部分组成的<ul>
<li>传输协议</li>
<li>域名</li>
<li>端口号</li>
</ul>
</li>
</ul>
<h4 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h4><ul>
<li>我们常见的传输协议是 <code>http</code> 和 <code>https</code> </li>
<li>他们是限制用户和服务器之间交流传输数据的方式和规则</li>
<li>也是我们前端和后端人员交互的规则</li>
<li>规则<ul>
<li>建立连接通道</li>
<li>相互通信</li>
<li>关闭连接通道</li>
</ul>
</li>
<li>只不过 <code>http</code> 是一种常见协议，不是很安全</li>
<li><code>https</code> 是一种加密传输协议</li>
</ul>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><ul>
<li>之前我们说过，服务器就是一个在 <strong>网络那一头</strong> 的一个电脑</li>
<li>以前，没有域名的概念，大家都是使用 <code>IP</code> 地址来访问</li>
<li>也就是 <strong>网络那一头</strong> 的那个电脑的 <code>IP</code></li>
<li>都是一堆数字，不方便记忆</li>
<li>后来就有了一个 <strong>万维网</strong>，他把每一个 IP 地址配套了一个英文的名字</li>
<li>方便用户记忆</li>
<li>所以说，域名就代表着 <strong>网络那一头</strong> 那个电脑的 IP 地址</li>
<li>其实也就是我们要访问哪一个服务器</li>
</ul>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><ul>
<li>人家的服务器电脑也是有很多的文件夹的</li>
<li>不同的文件夹里面存储着不同的内容</li>
<li>可能有个 a 文件夹，里面存储的是首页</li>
<li>可能有个 b 文件夹，里面存储的是一些数据</li>
<li>所以说，你光找到服务器电脑还不行，还得找对文件夹才可以</li>
<li>大家都把文件夹编上号存储了 <code>0 ~ 255</code> 一共 256 个</li>
<li>每个文件夹里面还有对应的小文件夹 <code>0 ~ 255</code> 一个 256 个</li>
<li>那么一共就有 <code>256 * 256</code> 个文件夹，也就是从 <code>0 ~ 65535</code></li>
<li>所以我们的端口号就有 <code>65536</code> 个，分别对应着 <code>0 ~ 65535</code> </li>
<li>大家都把 <code>80</code> 端口号作为一个网站的默认端口号</li>
<li>http 协议默认是 80 端口号</li>
<li>https 协议默认是 443 端口号</li>
</ul>
<h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><ul>
<li>到现在，我们在看百度的完整 url 地址</li>
<li><code>https://www.baidu.com:443</code><ul>
<li>以一种加密传输协议来通讯</li>
<li>访问的是网络上 <code>IP</code> 的值为 <code>119.75.217.109</code> 的那个电脑</li>
<li>访问的是第 <code>443</code> 号文件夹</li>
</ul>
</li>
<li>这个文件夹里面存储着一个百度的页面</li>
<li>我们就能看到这个页面了</li>
</ul>
<h2 id="PHP-基础语法"><a href="#PHP-基础语法" class="headerlink" title="PHP 基础语法"></a>PHP 基础语法</h2><ul>
<li>我们一定要知道，php 是另一个语言了，不再是我们的 <code>html</code> / <code>javascript</code> 了</li>
<li>一个别的语言就有人家语言的规则</li>
</ul>
<h2 id="php文件"><a href="#php文件" class="headerlink" title="php文件"></a>php文件</h2><ul>
<li>我们在写 <code>javascript</code> 的时候，是一个 <code>.js</code> 文件</li>
<li>我们在写 <code>html</code> 的时候，是一个 <code>.html</code> 文件</li>
<li><strong>php 的代码写在一个 <code>.php</code> 后缀的文件中</strong></li>
</ul>
<h3 id="php文件的书写"><a href="#php文件的书写" class="headerlink" title="php文件的书写"></a>php文件的书写</h3><ul>
<li><p>所有的 php 代码都要写在一个 php 的范围内</p>
</li>
<li><p>要求以 <code>&lt;?php</code> 开头</p>
</li>
<li><p>要求以 <code>?&gt;</code> 结尾</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># php 的代码写在这里</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="简单了解-php-的语法"><a href="#简单了解-php-的语法" class="headerlink" title="简单了解 php 的语法"></a>简单了解 php 的语法</h3><ul>
<li>每个语言都会有自己的语法</li>
<li>接下来我们就简单了解一下 php 的语法规则</li>
<li><code>php</code> 里面有一个必须要注意的点 <strong>每一个语句后面都要有 <code>;</code></strong></li>
</ul>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><ul>
<li><p>在 php 中没有 <code>var</code> 关键字给我们定义变量</p>
</li>
<li><p>直接使用 <code>$</code> 来确定一个变量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment"># 下面就是一个定义了一个变量，并且赋值为 100</span></span><br><span class="line">  <span class="comment"># 变量名就是 $num</span></span><br><span class="line">  $num = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  $boo = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 下面是一个字符串</span></span><br><span class="line">  $str = <span class="string">"你好 php"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul>
<li><p>在 php 中使用条件语句和 js 基本一致</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  </span><br><span class="line">$boo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($boo) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'你好，欢迎观临！'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'您还没有登陆'</span>;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul>
<li><p>在 php 中循环语句和 js 基本一致</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$num = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $num; $i++) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'hello php'</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><ul>
<li><p>在 php 中，字符串拼接不再是使用 <code>+</code> 进行拼接了，而是使用 <code>.</code> 进行拼接</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$str = <span class="string">'hello '</span>;</span><br><span class="line">$str2 = <span class="string">'world'</span>;</span><br><span class="line">$str3 = $str . $str2;</span><br><span class="line"><span class="keyword">echo</span> $str3;</span><br><span class="line"><span class="comment"># 得到的就是 hello world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>在 php 中的数组和 js 中特别不一样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 创建一个数组</span></span><br><span class="line">  $arr = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  print_r($arr);</span><br><span class="line">  <span class="comment"># Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 )</span></span><br><span class="line">  <span class="comment"># 这个就类似于我们 js 中的数组，按照索引来的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 创建一个关联数组</span></span><br><span class="line">  $arr2 = <span class="keyword">array</span>(<span class="string">'name'</span> =&gt; <span class="string">'Jack'</span>, <span class="string">'age'</span> =&gt; <span class="number">18</span>, <span class="string">'gender'</span> =&gt; <span class="string">'男'</span>)</span><br><span class="line">  print_r($arr2)</span><br><span class="line">  <span class="comment"># Array ( [name] =&gt; Jack [age] =&gt; 18 [gender] =&gt; 男 )</span></span><br><span class="line">  <span class="comment"># 这个就类似于我们 js 中的 对象，键值对的形式</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><ul>
<li>mysql 是一个数据库的名字</li>
<li>和 php 合作的比较好的数据库</li>
<li>之前我们说过一个问题，前端向后端索要数据，后端就是去数据库中查询数据，返回给前端</li>
<li>接下来就聊聊使用 php 操作数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL 是最流行的关系型数据库管理系统（非关系型数据库简略介绍）</span><br><span class="line">关系数据库管理系统(Relational Database Management System)的特点</span><br><span class="line">数据以表格的形式出现</span><br><span class="line">每行为各种记录名称</span><br><span class="line">许多的行和列组成一张表单</span><br><span class="line">若干的表单组成database</span><br><span class="line">主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</span><br></pre></td></tr></table></figure>
<h3 id="数据库的数据类型"><a href="#数据库的数据类型" class="headerlink" title="数据库的数据类型"></a>数据库的数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 数值类型</span><br><span class="line"></span><br><span class="line">| 类型 | 大小 | 用途 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| TINYINT | 1 字节 | 小整数值 |</span><br><span class="line">| SMALLINT | 2 字节 | 大整数值 |</span><br><span class="line">| MEDIUMINT | 3 字节 | 大整数值 |</span><br><span class="line">| INT或INTEGER | 4 字节 | 大整数值 |</span><br><span class="line">| BIGINT | 8 字节 | 极大整数值 |</span><br><span class="line">| FLOAT | 4 字节 | 单精度 浮点数值 |</span><br><span class="line">| DOUBLE | 8 字节 | 双精度 浮点数值 |</span><br><span class="line">| DECIMAL |  | 小数值 |</span><br><span class="line"></span><br><span class="line">* 日期和时间类型</span><br><span class="line"></span><br><span class="line">| 类型 | 格式 | 用途 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| DATE | YYYY-MM-DD | 日期值 |</span><br><span class="line">| TIME | HH:MM:SS | 时间值或持续时间 |</span><br><span class="line">| YEAR | YYYY | 年份值 |</span><br><span class="line">| DATETIME | YYYY-MM-DD HH:MM:SS | 混合日期和时间值 |</span><br><span class="line">| TIMESTAMP | YYYYMMDD HHMMSS | 时间戳 |</span><br><span class="line"></span><br><span class="line">* 字符串类型</span><br><span class="line"></span><br><span class="line">| 类型 | 大小 | 用途 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| CHAR | 0-255字节 | 定长字符串 |</span><br><span class="line">| VARCHAR | 0-65535 字节 | 变长字符串 |</span><br><span class="line">| TINYBLOB | 0-255字节 | 不超过 255 个字符的二进制字符串 |</span><br><span class="line">| TINYTEXT | 0-255字节 | 短文本字符串 |</span><br><span class="line">| BLOB | 0-65 535字节 | 二进制形式的长文本数据 |</span><br><span class="line">| TEXT | 0-65 535字节 | 长文本数据 |</span><br><span class="line">| MEDIUMBLOB | 0-16 777 215字节 | 二进制形式的中等长度文本数据 |</span><br><span class="line">| MEDIUMTEXT | 0-16 777 215字节 | 中等长度文本数据 |</span><br><span class="line">| LONGBLOB | 0-4 294 967 295字节 | 二进制形式的极大文本数据 |</span><br><span class="line">| LONGTEXT | 0-4 294 967 295字节 | 极大文本数据 |</span><br></pre></td></tr></table></figure>
<h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><ul>
<li>之前都是对数据库的简单了解，不需要全都背下来</li>
<li>我们只要了解一下就可以了</li>
<li>接下来我们就是使用 php 链接 mysql 数据库进行数据的增删改查</li>
<li>想要操作数据库，除了需要 php 的语法以外，还需要一个 mysql 的 sql 语句</li>
<li>使用 php 操作数据库的步骤<ol>
<li>和数据库建立链接</li>
<li>使用 sql 语句对数据库进行操作</li>
<li>获取结果</li>
<li>和数据库的链接断开</li>
</ol>
</li>
</ul>
<h4 id="和数据库建立链接"><a href="#和数据库建立链接" class="headerlink" title="和数据库建立链接"></a>和数据库建立链接</h4><ul>
<li><p>在 php 中我们使用 <code>mysql_connect()</code> 方法来建立和数据库的链接</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 下面就是建立链接，$link 会得到一个链接信息</span></span><br><span class="line">  <span class="comment"># $link = mysql_connect('ip地址', '数据库用户名', '数据库密码'); </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们有了链接信息 <code>$link</code> 以后就可以继续去操作数据库了</li>
</ul>
</li>
</ul>
<h4 id="确定操作哪个哪个库"><a href="#确定操作哪个哪个库" class="headerlink" title="确定操作哪个哪个库"></a>确定操作哪个哪个库</h4><ul>
<li><p>刚才是和数据库建立了链接，我们还要确定操作哪个库</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 下面就是确定你要操作哪个库  </span></span><br><span class="line">  <span class="comment"># mysql_select_db('你要操作的库的名称', $link);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="执行-sql-语句操作数据库"><a href="#执行-sql-语句操作数据库" class="headerlink" title="执行 sql 语句操作数据库"></a>执行 sql 语句操作数据库</h4><ul>
<li><p>接下来就是使用 sql 语句去这个库里面进行增删改查的操作了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 下面就是使用 sql 语句对数据库进行操作</span></span><br><span class="line">  <span class="comment"># $res = mysql_query('你要执行的 sql 语句');      </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里有一个注意的点：<ul>
<li>我们拿到的结果是一个我们看不懂的处理信息</li>
<li>需要使用 mysql_fetch_row || mysql_fetch_assoc 解析一下结果才能看得懂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关闭链接"><a href="#关闭链接" class="headerlink" title="关闭链接"></a>关闭链接</h4><ul>
<li><p>全部用完以后我们最好是关闭一下数据库链接</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># mysql_close($conn);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="完整步骤"><a href="#完整步骤" class="headerlink" title="完整步骤"></a>完整步骤</h4><ul>
<li><p>我们完整的写一下操作的步骤</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $conn = mysql_connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">'root'</span>);</span><br><span class="line">  mysql_select_db(<span class="string">'test1913'</span>);</span><br><span class="line">  $res = mysql_query(<span class="string">'SELECT * FROM `student`'</span>);</span><br><span class="line">  $row = mysql_fetch_assoc($res);</span><br><span class="line">  mysql_close($conn);</span><br><span class="line"></span><br><span class="line">  print_r($row);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常用的-sql-语句"><a href="#常用的-sql-语句" class="headerlink" title="常用的 sql 语句"></a>常用的 sql 语句</h3><ul>
<li>刚才说了怎么操作数据库</li>
<li>现在我们学习一下，操作数据库时候常用的 sql 语句</li>
<li>我们就是依靠这些 sql 语句来进行数据库操作的</li>
</ul>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><ul>
<li><p>查询语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 查询 student 这个表里面的所有数据</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student`'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 查询 student 表中的数据里面 gender 为 男 的数据</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` WHERE `gender`="男"'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 查询 student 表中的数据里面 age 大于 18 的数据</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` WHERE `age`&gt;18'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 查询 student 表中的数据里面 age 大于 18 且 gender 为 男 的数据</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` WHERE `age`&gt;18 AND `gender`="男"'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 查询 student 表中的数据里面 age 小于 22 或者 age 大于 28 的数据</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` WHERE `age`&lt;22 OR `age`&gt;28'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 查询 student 表中的数据里面从 第几条开始 查询多少条</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` LIMIT 0, 10'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 先按照条件筛选出数据以后再进行分页查询</span></span><br><span class="line">  <span class="comment"># 下面是查询表中所有 age&gt;18 且 性别为男的所有数据，查出来以后从第 10 条开始查 10 条</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` WHERE `age`&gt;18 AND `gender`="男" LIMIT 10, 10'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 查询表的模糊查询</span></span><br><span class="line">  <span class="comment"># 下面表示查询表中所有数据里面 name 字段中包含 "三" 字的数据</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` WHERE `name` LIKE "%三%"'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 查询排序，查询的时候按照某一个字段升序或降序排序</span></span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` ORDER BY `age` ASC'</span>;</span><br><span class="line">  $sql = <span class="string">'SELECT * FROM `student` ORDER BY `age` DESC'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><ul>
<li><p>增加语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 向表中增加一条数据，再增加的时候主键不能由我们书写，而是 mysql 数据库自己递增</span></span><br><span class="line">  $sql = <span class="string">'INSERT INTO `student` VALUES(null, "张三", 18, "男", 1913, 100)'</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 插入固定几个键的数据，其他的用默认值</span></span><br><span class="line">  $sql = <span class="string">'INSERT INTO `student` (`name`, `age`) VALUES("李四", 22)'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><ul>
<li><p>删除语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 删除表中 id 为 100 的数据</span></span><br><span class="line">  $sql = <span class="string">'DELETE FROM `student` WHERE `id`=100'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 删除表中 name 为 张三 的数据</span></span><br><span class="line">  $sql = <span class="string">'DELETE FROM `student` WHERE `name`="张三"'</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><ul>
<li><p>修改语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment"># 更新一条 id 为 100 的数据中的 name 字段的值和 age 字段的值</span></span><br><span class="line">  $sql = <span class="string">'UPDATE `student` SET `name`="张三", `age`=10 WHERE `id`=100'</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 更新数据的时候让所有的数据增加一些内容</span></span><br><span class="line">  $sql = <span class="string">'UPDATE `student` SET `age`=age+1'</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY5-2_HTTP和COOKIE</title>
    <url>/2021/11/03/DAY5-2-HTTP%E5%92%8CCOOKIE/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ul>
<li><code>http</code> 是我们前后台交互的时候的传输协议（即超文本传输协议）</li>
</ul><h2 id="HTTP-的工作流程"><a href="#HTTP-的工作流程" class="headerlink" title="HTTP 的工作流程"></a>HTTP 的工作流程</h2><ol>
<li>和服务器建立链接</li>
<li>建立链接后，发送一个请求给服务器（请求）</li>
<li>服务器接受到请求以后进行相应的处理并给出一个回应（响应）</li>
<li>断开于服务器的链接</li>
</ol><h3 id="和服务器建立链接"><a href="#和服务器建立链接" class="headerlink" title="和服务器建立链接"></a>和服务器建立链接</h3><ul>
<li><p>怎么和服务器建立链接呢？</p>
</li>
<li><p>需要保证客户端的接受和发送正常，服务器端的接受和发送正常</p>
</li>
<li><p>这里就涉及到一个东西叫做 <code>TCP/IP</code> 协议</p>
</li>
<li><p>建立链接的主要步骤叫做 <code>三次握手</code></p>
<ol>
<li><p>客户端发送一个消息给到服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此时：</span><br><span class="line">	服务端知道了 客户端可以正常发送消息</span><br><span class="line">	服务端知道了 服务端可以正常接受消息</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端回给客户端一个消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此时：</span><br><span class="line">	服务端知道了 客户端可以正常发送消息</span><br><span class="line">	服务端知道了 服务端可以正常接受消息</span><br><span class="line">	客户端知道了 客户端可以正常发送消息</span><br><span class="line">	客户端知道了 客户端可以正常接受消息</span><br><span class="line">	客户端知道了 服务端可以正常接受消息</span><br><span class="line">	客户端知道了 服务端可以正常发送消息</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端再回给服务端一个消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此时：</span><br><span class="line">	服务端知道了 客户端可以正常发送消息</span><br><span class="line">	服务端知道了 服务端可以正常接受消息</span><br><span class="line">	客户端知道了 客户端可以正常发送消息</span><br><span class="line">	客户端知道了 客户端可以正常接受消息</span><br><span class="line">	客户端知道了 服务端可以正常接受消息</span><br><span class="line">	客户端知道了 服务端可以正常发送消息</span><br><span class="line">	服务端知道了 服务端可以正常发送消息</span><br><span class="line">	服务端知道了 客户端可以正常接受消息</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>至此，依照 <code>TCP/IP</code> 协议的建立链接就建立好了</p>
</li>
<li><p>双方都知道双方可以正常收发消息</p>
</li>
<li><p>就可以进入到第二步，通讯了</p>
</li>
</ul><a id="more"></a>


<h3 id="发送一个请求"><a href="#发送一个请求" class="headerlink" title="发送一个请求"></a>发送一个请求</h3><ul>
<li><p>建立完链接以后就是发送请求的过程</p>
</li>
<li><p>我们的每一个请求都要把我们的所有信息都包含请求</p>
</li>
<li><p>每一个请求都会有一个 <code>请求报文</code></p>
</li>
<li><p>在 <code>请求报文</code> 中会包含我们所有的请求信息（也就是我们要和服务端说的话都在里面）</p>
</li>
<li><p>我们的请求报文中会包含几个东西</p>
<ol>
<li><p>请求行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /user HTTP/1.1</span><br><span class="line"><span class="meta">#</span> POST 请求方式</span><br><span class="line"><span class="meta">#</span> /user 请求URL（不包含域名）</span><br><span class="line"><span class="meta">#</span> HTTP/1.1 请求协议版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求头（请求头都是键值对的形式出现的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user-agent: Mozilla/5.0 # 产生请求的浏览器信息</span><br><span class="line">accept: application/json # 表示客户端希望接受的数据类型</span><br><span class="line">Content-Type: application/x-www-form-urlencoded # 客户端发送的实体数据格式</span><br><span class="line">Host: 127.0.0.1 # 请求的主机名（IP）</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求空行（请求头和请求主体之间要留一个空白行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 就是一个空行</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求体（本次请求携带的数据）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> GET 请求是没有请求体数据的</span><br><span class="line"><span class="meta">#</span> POST 请求才有请求体数据</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>接下来看一个完整的请求报文</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /user HTTP/1.1      # 请求行</span><br><span class="line">Host: www.user.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">accept: application/json</span><br><span class="line">User-agent: Mozilla/5.0.     # 以上是首部</span><br><span class="line"><span class="meta">#</span>（此处必须有一空行）  # 空行分割header和请求内容 </span><br><span class="line">name=world   # 请求体</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="接受一个响应"><a href="#接受一个响应" class="headerlink" title="接受一个响应"></a>接受一个响应</h3><ul>
<li><p>客户端的请求发送到服务端以后</p>
</li>
<li><p>服务端进行对应的处理</p>
</li>
<li><p>会给我们返回一个响应</p>
</li>
<li><p>每一个响应都会有一个 <code>响应报文</code></p>
</li>
<li><p>在 <code>响应报文</code> 中会包含我们所有的响应信息（也就是服务端在接受到客户端请求以后，给我们的回信）</p>
</li>
<li><p>我们的 <code>响应报文</code> 中会包含几个信息</p>
<ol>
<li><p>状态行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"><span class="meta">#</span> HTTP/1.1 服务器使用的 HTTP 协议版本</span><br><span class="line"><span class="meta">#</span> 200 响应状态码</span><br><span class="line"><span class="meta">#</span> OK 对响应状态码的简单解释</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应头</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Date: Jan, 14 Aug 2019 12:42:30 GMT # 服务器时间</span><br><span class="line">Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45 # 服务器类型</span><br><span class="line">Content-Type: text/html # 服务端给客户端的数据类型</span><br><span class="line">Content-Length: 11 # 服务端给客户端的数据长度</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应体</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line"><span class="meta">#</span> 服务端给客户端的响应数据</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="断开于服务端的链接"><a href="#断开于服务端的链接" class="headerlink" title="断开于服务端的链接"></a>断开于服务端的链接</h3><ul>
<li>之前我们的建立链接是基于 <code>TCP/IP</code> 协议的 <code>三次握手</code></li>
<li>我们的断开链接是基于 <code>TCP/IP</code> 协议的 <code>四次挥手</code><ol>
<li>客户端发送一个我要断开的消息给服务端</li>
<li>服务端接受到以后发送一个消息告诉客户端我已经进入关闭等待状态</li>
<li>服务端再次发送一个消息告诉客户端，这个是我的最后一次消息给你，当我再接受到消息的时候就会关闭</li>
<li>客户端接受到服务端的消息以后，告诉服务器，我已经关闭，这个是给你的最后一个消息</li>
</ol>
</li>
</ul>
<h3 id="完成一个-HTTP-请求"><a href="#完成一个-HTTP-请求" class="headerlink" title="完成一个 HTTP 请求"></a>完成一个 HTTP 请求</h3><ul>
<li>至此，一个 HTTP 请求就完整的完成了</li>
<li>一个 HTTP 请求必须要包含的四个步骤就是<ol>
<li>建立链接</li>
<li>发送请求</li>
<li>接受响应</li>
<li>断开链接</li>
</ol>
</li>
<li>在一个 HTTP 请求中，请求的部分有请求报文，接受响应的部分有响应报文</li>
<li>请求报文包含<ol>
<li>请求行</li>
<li>请求头</li>
<li>请求空行</li>
<li>请求体</li>
</ol>
</li>
<li>响应报文<ol>
<li>状态行</li>
<li>响应头</li>
<li>响应体</li>
</ol>
</li>
</ul>
<h2 id="常见的-HTTP-响应状态码"><a href="#常见的-HTTP-响应状态码" class="headerlink" title="常见的 HTTP 响应状态码"></a>常见的 HTTP 响应状态码</h2><ul>
<li>在一个 HTTP 请求的响应报文中的状态行会有一个响应状态码</li>
<li>这个状态码是用来描述本次响应的状态的</li>
<li>通常会出现五种状态码<ol>
<li>100 ~ 199</li>
<li>200 ~ 299</li>
<li>300 ~ 399</li>
<li>400 ~ 499</li>
<li>500 ~ 599</li>
</ol>
</li>
</ul>
<h3 id="100-199"><a href="#100-199" class="headerlink" title="100 ~ 199"></a>100 ~ 199</h3><ul>
<li><p>一般我们看不到，因为表示请求继续</p>
</li>
<li><p>100：  继续请求，前面的一部分内容服务端已经接受到了，正在等待后续内容</p>
</li>
<li>101： 请求者已经准备切换协议，服务器页表示同意</li>
</ul>
<h3 id="200-299"><a href="#200-299" class="headerlink" title="200 ~ 299"></a>200 ~ 299</h3><ul>
<li>2 开头的都是表示成功，本次请求成功了，只不过不一样的状态码有不一样的含义（语义化）</li>
<li>200： 标准请求成功（一般表示服务端提供的是网页）</li>
<li>201： 创建成功（一般是注册的时候，表示新用户信息已经添加到数据库）</li>
<li>203： 表示服务器已经成功处理了请求，但是返回的信息可能来自另一源</li>
<li>204： 服务端已经成功处理了请求，但是没有任何数据返回</li>
</ul>
<h3 id="300-399"><a href="#300-399" class="headerlink" title="300 ~ 399"></a>300 ~ 399</h3><ul>
<li>3 开头也是成功的一种，但是一般表示重定向</li>
<li>301： 永久重定向</li>
<li>302： 临时重定向</li>
<li>304： 使用的是缓存的数据</li>
<li>305： 使用代理</li>
</ul>
<h3 id="400-499"><a href="#400-499" class="headerlink" title="400 ~ 499"></a>400 ~ 499</h3><ul>
<li>4 开头表示客户端出现错误了</li>
<li>400： 请求的语法服务端不认识</li>
<li>401： 未授权（你要登录的网站需要授权登录）</li>
<li>403： 服务器拒绝了你的请求</li>
<li>404： 服务器找不到你请求的 URL</li>
<li>407： 你的代理没有授权</li>
<li>408： 请求超时</li>
<li>410： 你请求的数据已经被服务端永久删除</li>
</ul>
<h3 id="500-599"><a href="#500-599" class="headerlink" title="500 ~ 599"></a>500 ~ 599</h3><ul>
<li>5 开头的表示服务端出现了错误</li>
<li>500： 服务器内部错误</li>
<li>503： 服务器当前不可用（过载或者维护）</li>
<li>505： 请求的协议服务器不支持 </li>
</ul>
<h2 id="常见的-HTTP-请求方式"><a href="#常见的-HTTP-请求方式" class="headerlink" title="常见的 HTTP 请求方式"></a>常见的 HTTP 请求方式</h2><ul>
<li>每一个 HTTP 请求在请求行里面会有一个东西叫做请求方式</li>
<li>不同的请求方式代表的含义不同<ol>
<li>GET： 一般用于获取一些信息使用（获取列表）</li>
<li>POST： 一般用于发送一些数据给服务端（登录）</li>
<li>PUT： 一般用于发送一些数据给服务当让其添加新数据（注册）</li>
<li>DELETE： 一般用域删除某些数据</li>
<li>HEAD： 类似于 GET 的请求，只不过一般没有响应的具体内容，用于获取报文头</li>
<li>CONNECT： HTTP/1.1 中预留的方式，一般用于管道链接改变为代理的时候使用</li>
<li>PATCH： 是和 PUT 方式类似的一个方式，一般用于更新局部数据</li>
<li>OPTIONS： 允许客户端查看服务端性能</li>
</ol>
</li>
<li>我们比较常用的就是 GET 和 POST</li>
</ul>
<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><ul>
<li>参数以 <code>querystring</code> 的形式发送，也就是直接拼接在 请求路径的后面</li>
<li>GET 请求会被浏览器主动缓存</li>
<li>GET 请求根据不同的浏览器对长度是有限制的<ul>
<li>IE： 2083 个字符</li>
<li>FireFox： 65536 个字符</li>
<li>Safari： 80000 个字符</li>
<li>Opera： 190000 个字符</li>
<li>Chrome： 8182 个字符</li>
<li>APACHE(server)： 理论上接受的最大长度是 8192 个字符（有待商榷）</li>
</ul>
</li>
<li>对参数的类型有限制，只接受 ASCII 码的格式</li>
<li>GET 请求是明文发送，相对不安全</li>
</ul>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><ul>
<li>参数以 <code>request body</code>的形式发送，也就是放在请求体中</li>
<li>POST 请求不会被浏览器主动缓存，除非手动设置</li>
<li>POST 请求理论上是没有限制的，除非服务端做了限制</li>
<li>对参数类型没有限制，理论上可以传递任意数据类型，只不过要和请求头对应</li>
<li>POST 请求是密文发送，相对安全</li>
</ul>
<h1 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h1><ul>
<li><code>cookie</code> 是一个以字符串的形式存储数据的位置</li>
<li>每一个 HTTP 请求都会在请求头中携带 cookie 到服务端</li>
<li>每一个 HTTP 响应都会在响应头中携带 cookie 到客户端</li>
<li>也就是说，cookie 是不需要我们手动设置，就会自动在 客户端 和 服务端之间游走的数据</li>
<li>我们只是需要设置一下 cookie 的内容就可以</li>
</ul>
<h2 id="COOKIE-的存储形式"><a href="#COOKIE-的存储形式" class="headerlink" title="COOKIE 的存储形式"></a>COOKIE 的存储形式</h2><ul>
<li><p>cookie 是以字符串的形式存储，在字符串中以 <code>key=value</code> 的形式出现</p>
</li>
<li><p>每一个 <code>key=value</code> 是一条数据</p>
</li>
<li><p>多个数据之间以 <code>;</code> 分割</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cookie 的形态</span></span><br><span class="line"><span class="string">'a=100; b=200; c=300;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="COOKIE-的特点"><a href="#COOKIE-的特点" class="headerlink" title="COOKIE 的特点"></a>COOKIE 的特点</h2><ol>
<li>存储大小有限制，一般是 4 KB 左右</li>
<li>数量有限制，一般是 50 条左右</li>
<li>有时效性，也就是有过期时间，一般是 <strong>会话级别</strong>（也就是浏览器关闭就过期了）</li>
<li>有域名限制，也就是说谁设置的谁才能读取</li>
</ol>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li><p>读取 cookie 的内容使用 <code>document.cookie</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cookie = <span class="built_in">document</span>.cookie</span><br><span class="line"><span class="built_in">console</span>.log(cookie) <span class="comment">// 就能得到当前 cookie 的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 cookie 的内容使用 <code>document.cookie</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个时效性为会话级别的 cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'a=100'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个有过期时间的 cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'b=200;expires=Thu, 18 Dec 2043 12:00:00 GMT";'</span></span><br><span class="line"><span class="comment">// 上面这个 cookie 数据会在 2043 年 12 月 18 日 12 点以后过期，过期后会自动消失</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 cookie 的内容使用 <code>document.cookie</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 cookie 不能直接删除</span></span><br><span class="line"><span class="comment">// 所以我们只能把某一条 cookie 的过期时间设置成当前时间之前</span></span><br><span class="line"><span class="comment">// 那么浏览器就会自动删除 cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'b=200;expires=Thu, 18 Dec 2018 12:00:00 GMT";'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="COOKIE-操作封装"><a href="#COOKIE-操作封装" class="headerlink" title="COOKIE 操作封装"></a>COOKIE 操作封装</h2><ul>
<li>因为 js 中没有专门操作 COOKIE 增删改查的方法</li>
<li>所以需要我们自己封装一个方法</li>
</ul>
<h3 id="设置-cookie"><a href="#设置-cookie" class="headerlink" title="设置 cookie"></a>设置 cookie</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * setCookie 用于设置 cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;STRING&#125;</span> </span>key  要设置的 cookie 名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;STRING&#125;</span> </span>value  要设置的 cookie 内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;NUMBER&#125;</span> </span>expires  过期时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">key, value, expires</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  time.setTime(time.getTime() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">8</span> + expires) <span class="comment">// 用于设置过期时间</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>;expires=<span class="subst">$&#123;time&#125;</span>;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取-cookie"><a href="#读取-cookie" class="headerlink" title="读取 cookie"></a>读取 cookie</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getCookie 获取 cookie 中的某一个属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;STRING&#125;</span> </span>key 你要查询的 cookie 属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;STRING&#125;</span> </span>你要查询的那个 cookie 属性的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cookieArr = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  cookieArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.split(<span class="string">'='</span>)[<span class="number">0</span>] === key) &#123;</span><br><span class="line">      value = item.split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delCookie 删除 cookie 中的某一个属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;STRING&#125;</span> </span>name 你要删除的某一个 cookie 属性的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  setCookie(name, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY5-3_AJAX</title>
    <url>/2021/11/03/DAY5-3-AJAX/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><ul>
<li><code>ajax</code> 全名 <code>async javascript and XML</code></li>
<li>是前后台交互的能力</li>
<li>也就是我们客户端给服务端发送消息的工具，以及接受响应的工具</li>
<li>是一个 <strong>默认异步</strong> 执行机制的功能</li>
</ul><h2 id="AJAX-的优势"><a href="#AJAX-的优势" class="headerlink" title="AJAX 的优势"></a>AJAX 的优势</h2><ol>
<li>不需要插件的支持，原生 js 就可以使用</li>
<li>用户体验好（不需要刷新页面就可以更新数据）</li>
<li>减轻服务端和带宽的负担</li>
<li>缺点： 搜索引擎的支持度不够，因为数据都不在页面上，搜索引擎搜索不到</li>
</ol><a id="more"></a>

<h2 id="AJAX-的使用"><a href="#AJAX-的使用" class="headerlink" title="AJAX 的使用"></a>AJAX 的使用</h2><ul>
<li>在 js 中有内置的构造函数来创建 ajax 对象</li>
<li>创建 ajax 对象以后，我们就使用 ajax 对象的方法去发送请求和接受响应</li>
</ul>
<h3 id="创建一个-ajax-对象"><a href="#创建一个-ajax-对象" class="headerlink" title="创建一个 ajax 对象"></a>创建一个 ajax 对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IE9及以上</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE9以下</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Mricosoft.XMLHTTP'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面就是有了一个 ajax 对象</li>
<li>我们就可以使用这个 <code>xhr</code> 对象来发送 ajax 请求了</li>
</ul>
<h3 id="配置链接信息"><a href="#配置链接信息" class="headerlink" title="配置链接信息"></a>配置链接信息</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// xhr 对象中的 open 方法是来配置请求信息的</span></span><br><span class="line"><span class="comment">// 第一个参数是本次请求的请求方式 get / post / put / ...</span></span><br><span class="line"><span class="comment">// 第二个参数是本次请求的 url </span></span><br><span class="line"><span class="comment">// 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步</span></span><br><span class="line"><span class="comment">// xhr.open('请求方式', '请求地址', 是否异步)</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'./data.php'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码执行完毕以后，本次请求的基本配置信息就写完了</li>
</ul>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'./data.php'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 xhr 对象中的 send 方法来发送请求</span></span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码是把配置好信息的 ajax 对象发送到服务端</li>
</ul>
<h3 id="一个基本的-ajax-请求"><a href="#一个基本的-ajax-请求" class="headerlink" title="一个基本的 ajax 请求"></a>一个基本的 ajax 请求</h3><ul>
<li>一个最基本的 ajax 请求就是上面三步</li>
<li>但是光有上面的三个步骤，我们确实能把请求发送的到服务端</li>
<li>如果服务端正常的话，响应也能回到客户端</li>
<li>但是我们拿不到响应</li>
<li>如果想拿到响应，我们有两个前提条件<ol>
<li>本次 HTTP 请求是成功的，也就是我们之前说的 http 状态码为 200 ~ 299</li>
<li>ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段</li>
</ol>
</li>
</ul>
<h3 id="ajax-状态码"><a href="#ajax-状态码" class="headerlink" title="ajax 状态码"></a>ajax 状态码</h3><ul>
<li>ajax 状态码 - <code>xhr.readyState</code></li>
<li>是用来表示一个 ajax 请求的全部过程中的某一个状态<ul>
<li><code>readyState === 0</code>：  表示未初始化完成，也就是 <code>open</code> 方法还没有执行</li>
<li><code>readyState === 1</code>：  表示配置信息已经完成，也就是执行完 <code>open</code> 之后</li>
<li><code>readyState === 2</code>：  表示 <code>send</code> 方法已经执行完成</li>
<li><code>readyState === 3</code>：  表示正在解析响应内容</li>
<li><code>readyState === 4</code>：  表示响应内容已经解析完毕，可以在客户端使用了</li>
</ul>
</li>
<li>这个时候我们就会发现，当一个 ajax 请求的全部过程中，只有当 <code>readyState === 4</code> 的时候，我们才可以正常使用服务端给我们的数据</li>
<li>所以，配合 http 状态码为 200 ~ 299 <ul>
<li>一个 ajax 对象中有一个成员叫做 <code>xhr.status</code> </li>
<li>这个成员就是记录本次请求的 http 状态码的</li>
</ul>
</li>
<li>两个条件都满足的时候，才是本次请求正常完成</li>
</ul>
<h3 id="readyStateChange"><a href="#readyStateChange" class="headerlink" title="readyStateChange"></a>readyStateChange</h3><ul>
<li><p>在 ajax 对象中有一个事件，叫做 <code>readyStateChange</code> 事件</p>
</li>
<li><p>这个事件是专门用来监听 ajax 对象的 <code>readyState</code> 值改变的的行为</p>
</li>
<li><p>也就是说只要 <code>readyState</code> 的值发生变化了，那么就会触发该事件</p>
</li>
<li><p>所以我们就在这个事件中来监听 ajax 的 <code>readyState</code> 是不是到 4 了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'./data.php'</span>)</span><br><span class="line"></span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line">xhr.onreadyStateChange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每次 readyState 改变的时候都会触发该事件</span></span><br><span class="line">  <span class="comment">// 我们就在这里判断 readyState 的值是不是到 4</span></span><br><span class="line">  <span class="comment">// 并且 http 的状态码是不是 200 ~ 299</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; <span class="regexp">/^2\d&#123;2|$/</span>.test(xhr.status)) &#123;</span><br><span class="line">    <span class="comment">// 这里表示验证通过</span></span><br><span class="line">    <span class="comment">// 我们就可以获取服务端给我们响应的内容了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h3><ul>
<li><p>ajax 对象中的 <code>responseText</code> 成员</p>
</li>
<li><p>就是用来记录服务端给我们的响应体内容的</p>
</li>
<li><p>所以我们就用这个成员来获取响应体内容就可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'./data.php'</span>)</span><br><span class="line"></span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line">xhr.onreadyStateChange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; <span class="regexp">/^2\d&#123;2|$/</span>.test(xhr.status)) &#123;</span><br><span class="line">    <span class="comment">// 我们在这里直接打印 xhr.responseText 来查看服务端给我们返回的内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用-ajax-发送请求时携带参数"><a href="#使用-ajax-发送请求时携带参数" class="headerlink" title="使用 ajax 发送请求时携带参数"></a>使用 ajax 发送请求时携带参数</h2><ul>
<li>我们使用 ajax 发送请求也是可以携带参数的</li>
<li>参数就是和后台交互的时候给他的一些信息</li>
<li>但是携带参数 get 和 post 两个方式还是有区别的</li>
</ul>
<h3 id="发送一个带有参数的-get-请求"><a href="#发送一个带有参数的-get-请求" class="headerlink" title="发送一个带有参数的 get 请求"></a>发送一个带有参数的 get 请求</h3><ul>
<li><p>get 请求的参数就直接在 url 后面进行拼接就可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 直接在地址后面加一个 ?，然后以 key=value 的形式传递</span></span><br><span class="line"><span class="comment">// 两个数据之间以 &amp; 分割</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'./data.php?a=100&amp;b=200'</span>)</span><br><span class="line"></span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<ul>
<li>这样服务端就能接受到两个参数</li>
<li>一个是 a，值是 100</li>
<li>一个是 b，值是 200</li>
</ul>
</li>
</ul>
<h3 id="发送一个带有参数的-post-请求"><a href="#发送一个带有参数的-post-请求" class="headerlink" title="发送一个带有参数的 post 请求"></a>发送一个带有参数的 post 请求</h3><ul>
<li><p>post 请求的参数是携带在请求体中的，所以不需要再 url 后面拼接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'./data.php'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是用 ajax 对象发送 post 请求，必须要先设置一下请求头中的 content-type</span></span><br><span class="line"><span class="comment">// 告诉一下服务端我给你的是一个什么样子的数据格式</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求体直接再 send 的时候写在 () 里面就行</span></span><br><span class="line"><span class="comment">// 不需要问号，直接就是 'key=value&amp;key=value' 的形式</span></span><br><span class="line">xhr.send(<span class="string">'a=100&amp;b=200'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>application/x-www-form-urlencoded</code> 表示的数据格式就是 <code>key=value&amp;key=value</code></li>
</ul>
</li>
</ul>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><ul>
<li><strong>同源策略是由浏览器给的</strong></li>
<li>浏览器不允许我们向别人发送请求，只能向自己的服务器发送请求</li>
<li>当我们想向别人的服务器发送请求的时候，就会被浏览器阻止了</li>
<li>什么是 “别人的服务器” 呢？<ul>
<li><strong>当 请求协议/域名/端口号 有任意一个不同的时候，那么就算是别人的服务器</strong></li>
<li>这个时候就会触发同源策略</li>
</ul>
</li>
<li>我们管触发了 <strong>同源策略</strong> 的请求叫做跨域请求</li>
</ul>
<h1 id="实现一个跨域请求"><a href="#实现一个跨域请求" class="headerlink" title="实现一个跨域请求"></a>实现一个跨域请求</h1><ul>
<li>有的时候我们是需要实现跨域请求的</li>
<li>我们需要多个服务器给一个页面提供数据</li>
<li>那么这个时候我们就要想办法解决跨域问题</li>
</ul>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><ul>
<li><code>jsonp</code> 是我们实现跨域请求的手段，是把我们之前的东西组合在一起使用的技术手段而已</li>
<li>利用的是 script 标签来实现</li>
</ul>
<h3 id="script-标签的本质"><a href="#script-标签的本质" class="headerlink" title="script 标签的本质"></a>script 标签的本质</h3><ul>
<li>浏览器给我们提供了一个 <code>script</code> 标签</li>
<li>它的本质就是请求一个外部资源，是不受到同源策略的影响的</li>
<li>同时 <code>script</code> 标签的 <code>src</code> 属性，也是一种请求，也能被服务器接收到</li>
<li>并且：<ul>
<li><strong>script标签的src属性请求回来的东西是一个字符串，浏览器会把这个字符串当作 js 代码来执行</strong></li>
</ul>
</li>
<li>所以我们就可以利用这个 <code>script</code> 标签的 <code>src</code> 属性来进行跨域请求了</li>
</ul>
<h2 id="配置代理（了解）"><a href="#配置代理（了解）" class="headerlink" title="配置代理（了解）"></a>配置代理（了解）</h2><ul>
<li>代理，分成两种，正向代理和反向代理</li>
</ul>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><ul>
<li>有一个客户端需要向一个非同源的服务器B发送请求</li>
<li>我们搭建一个和客户端同源的服务器A</li>
<li>当客户端发送请求的时候，由服务器A来接受</li>
<li>再由服务器A向服务器B发送请求，因为 <strong>同源策略是由浏览器给的</strong>，服务器之间没有</li>
<li>服务器B接受到请求以后，会处理请求，并把响应返回给服务器A</li>
<li>再由服务器A把响应给到客户端就可以了</li>
<li>我们就可以用这个方式来进行跨域请求了</li>
</ul>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul>
<li>反向代理一般是用来做负载均衡的</li>
<li>当我请求一个服务器的时候，其实请求的是服务器端设置的代理服务器</li>
<li>由代理服务器把若干大量的请求分发给不同的服务器进行处理</li>
<li>再由服务器把响应给到代理服务器</li>
<li>代理服务器返回给客户端</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY4-1_面向对象</title>
    <url>/2021/11/03/DAY4-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li>首先，我们要明确，面向对象不是语法，是一个思想，是一种 <strong>编程模式</strong></li>
<li>面向： 面（脸），向（朝着）</li>
<li>面向过程： 脸朝着过程 =》 关注着过程的编程模式</li>
<li>面向对象： 脸朝着对象 =》 关注着对象的编程模式</li>
<li>实现一个效果<ul>
<li>在面向过程的时候，我们要关注每一个元素，每一个元素之间的关系，顺序，。。。</li>
<li>在面向过程的时候，我们要关注的就是找到一个对象来帮我做这个事情，我等待结果</li>
</ul>
</li>
<li>例子 🌰： 我要吃面条<ul>
<li>面向过程<ul>
<li>用多少面粉</li>
<li>用多少水</li>
<li>怎么和面</li>
<li>怎么切面条</li>
<li>做开水</li>
<li>煮面</li>
<li>吃面</li>
</ul>
</li>
<li>面向对象<ul>
<li>找到一个面馆</li>
<li>叫一碗面</li>
<li>等着吃</li>
</ul>
</li>
<li>面向对象就是对面向过程的封装</li>
</ul>
</li>
<li>我们以前的编程思想是，每一个功能，都按照需求一步一步的逐步完成</li>
<li>我们以后的编程思想是，每一个功能，都先创造一个 <strong>面馆</strong>，这个 <strong>面馆</strong> 能帮我们作出一个 <strong>面（完成这个功能的对象）</strong>，然后用 <strong>面馆</strong> 创造出一个 <strong>面</strong>，我们只要等到结果就好了</li>
</ul><a id="more"></a>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ul>
<li>因为面向对象就是一个找到对象的过程</li>
<li>所以我们先要了解如何创建一个对象</li>
</ul>
<h3 id="调用系统内置的构造函数创建对象"><a href="#调用系统内置的构造函数创建对象" class="headerlink" title="调用系统内置的构造函数创建对象"></a>调用系统内置的构造函数创建对象</h3><ul>
<li><p>js 给我们内置了一个 Object 构造函数</p>
</li>
<li><p>这个构造函数就是用来创造对象的</p>
</li>
<li><p>当 构造函数 和 new 关键字连用的时候，就可以为我们创造出一个对象</p>
</li>
<li><p>因为 js 是一个动态的语言，那么我们就可以动态的向对象中添加成员了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就能得到一个空对象</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常操作对象</span></span><br><span class="line">o1.name = <span class="string">'Jack'</span></span><br><span class="line">o1.age = <span class="number">18</span></span><br><span class="line">o1.gender = <span class="string">'男'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字面量的方式创建一个对象"><a href="#字面量的方式创建一个对象" class="headerlink" title="字面量的方式创建一个对象"></a>字面量的方式创建一个对象</h3><ul>
<li><p>直接使用字面量的形式，也就是直接写 <code>{}</code></p>
</li>
<li><p>可以在写的时候就添加好成员，也可以动态的添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量方式创建对象</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再来一个</span></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;&#125;</span><br><span class="line">o2.name = <span class="string">'Rose'</span></span><br><span class="line">o2.age = <span class="number">20</span></span><br><span class="line">o2.gender = <span class="string">'女'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用工厂函数的方式创建对象"><a href="#使用工厂函数的方式创建对象" class="headerlink" title="使用工厂函数的方式创建对象"></a>使用工厂函数的方式创建对象</h3><ul>
<li><p>先书写一个工厂函数</p>
</li>
<li><p>这个工厂函数里面可以创造出一个对象，并且给对象添加一些属性，还能把对象返回</p>
</li>
<li><p>使用这个工厂函数创造对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 先创建一个工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 手动创建一个对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 手动的向对象中添加成员</span></span><br><span class="line">  obj.name = <span class="string">'Jack'</span></span><br><span class="line">  obj.age = <span class="number">18</span></span><br><span class="line">  obj.gender = <span class="string">'男'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 手动返回一个对象</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用这个工厂函数创建对象</span></span><br><span class="line"><span class="keyword">var</span> o1 = createObj()</span><br><span class="line"><span class="keyword">var</span> o2 = createObj()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用自定义构造函数创建对象"><a href="#使用自定义构造函数创建对象" class="headerlink" title="使用自定义构造函数创建对象"></a>使用自定义构造函数创建对象</h3><ul>
<li><p>工厂函数需要经历三个步骤</p>
<ul>
<li>手动创建对象</li>
<li>手动添加成员</li>
<li>手动返回对象</li>
</ul>
</li>
<li><p>构造函数会比工厂函数简单一下</p>
<ul>
<li>自动创建对象</li>
<li>手动添加成员</li>
<li>自动返回对象</li>
</ul>
</li>
<li><p>先书写一个构造函数</p>
</li>
<li><p>在构造函数内向对象添加一些成员</p>
</li>
<li><p>使用这个构造函数创造一个对象（和 new 连用）</p>
</li>
<li><p>构造函数可以创建对象，并且创建一个带有属性和方法的对象</p>
</li>
<li><p>面向对象就是要想办法找到一个有属性和方法的对象</p>
</li>
<li><p>面向对象就是我们自己制造 <strong>构造函数</strong> 的过程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 先创造一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用构造函数创建对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="string">'man'</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Rose'</span>, <span class="string">'woman'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="构造函数详解"><a href="#构造函数详解" class="headerlink" title="构造函数详解"></a>构造函数详解</h2><ul>
<li>我们了解了对象的创建方式</li>
<li>我们的面向对象就是要么能直接得到一个对象</li>
<li>要么就弄出一个能创造对象的东西，我们自己创造对象</li>
<li>我们的构造函数就能创造对象，所以接下来我们就详细聊聊 <strong>构造函数</strong></li>
</ul>
<h3 id="构造函数的基本使用"><a href="#构造函数的基本使用" class="headerlink" title="构造函数的基本使用"></a>构造函数的基本使用</h3><ul>
<li><p>和普通函数一样，只不过 <strong>调用的时候要和 new 连用</strong>，不然就是一个普通函数调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Person()  <span class="comment">// 能得到一个空对象</span></span><br><span class="line"><span class="keyword">var</span> o2 = Person()      <span class="comment">// 什么也得不到，这个就是普通函数调用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>不写 new 的时候就是普通函数调用，没有创造对象的能力</strong></li>
</ul>
</li>
<li><p>首字母大写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> person() <span class="comment">// 能得到一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> Person() <span class="comment">// 能得到一个对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>首字母不大写，只要和 new 连用，就有创造对象的能力</strong></li>
</ul>
</li>
<li><p>当调用的时候如果不需要传递参数可以不写 <code>()</code>，建议都写上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Person()  <span class="comment">// 能得到一个空对象</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> Person    <span class="comment">// 能得到一个空对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>如果不需要传递参数，那么可以不写 （），如果传递参数就必须写</strong></li>
</ul>
</li>
<li><p>构造函数内部的 this，由于和 new 连用的关系，是指向当前实例对象的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Person()  <span class="comment">// 本次调用的时候，this =&gt; o1</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> Person()  <span class="comment">// 本次调用的时候，this =&gt; o2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong>每次 new 的时候，函数内部的 this 都是指向当前这次的实例化对象</strong></li>
</ul>
</li>
<li><p>因为构造函数会自动返回一个对象，所以构造函数内部不要写 return</p>
<ul>
<li>你如果 return 一个基本数据类型，那么写了没有意义</li>
<li>如果你 return 一个引用数据类型，那么构造函数本身的意义就没有了</li>
</ul>
</li>
</ul>
<h3 id="使用构造函数创建一个对象"><a href="#使用构造函数创建一个对象" class="headerlink" title="使用构造函数创建一个对象"></a>使用构造函数创建一个对象</h3><ul>
<li><p>我们在使用构造函数的时候，可以通过一些代码和内容来向当前的对象中添加一些内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Jack'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
<ul>
<li>我们得到的两个对象里面都有自己的成员 <strong>name</strong> 和 <strong>age</strong></li>
</ul>
</li>
<li><p>我们在写构造函数的时候，是不是也可以添加一些方法进去呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Jack'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello constructor'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
<ul>
<li>显然是可以的，我们的到的两个对象中都有 <code>sayHi</code> 这个函数</li>
<li>也都可以正常调用</li>
</ul>
</li>
<li><p>但是这样好不好呢？缺点在哪里？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Jack'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello constructor'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次 new 的时候， Person 这个函数要执行一遍</span></span><br><span class="line"><span class="comment">// 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 new 的时候， Person 这个函数要执行一遍</span></span><br><span class="line"><span class="comment">// 执行一遍就会创造一个新的函数，并且把函数地址赋值给 this.sayHi</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
<ul>
<li>这样的话，那么我们两个对象内的 <code>sayHi</code> 函数就是一个代码一摸一样，功能一摸一样</li>
<li>但是是两个空间函数，占用两个内存空间</li>
<li>也就是说 <code>o1.sayHi</code> 是一个地址，<code>o2.sayHi</code> 是一个地址</li>
<li>所以我们执行 <code>console.log(o1 === o2.sayHi)</code> 的到的结果是 <code>false</code></li>
<li>缺点： <strong>一摸一样的函数出现了两次，占用了两个空间地址</strong></li>
</ul>
</li>
<li><p>怎么解决这个问题呢？</p>
<ul>
<li>就需要用到一个东西，叫做 <strong>原型</strong></li>
</ul>
</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul>
<li>原型的出现，就是为了解决 <strong>构造函数的缺点</strong></li>
<li>也就是给我们提供了一个给对象添加函数的方法</li>
<li>不然构造函数只能给对象添加属性，不能合理的添加函数就太 LOW 了</li>
</ul>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><ul>
<li><p><strong>每一个函数天生自带一个成员，叫做 prototype，是一个对象空间</strong></p>
</li>
<li><p>即然每一个函数都有，构造函数也是函数，构造函数也有这个对象空间</p>
</li>
<li><p>这个 <code>prototype</code> 对象空间可以由函数名来访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype) <span class="comment">// 是一个对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>即然是个对象，那么我们就可以向里面放入一些东西</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'prototype'</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们发现了一个叫做 <code>prototype</code> 的空间是和函数有关联的</p>
</li>
<li><p>并且可以向里面存储一些东西</p>
</li>
<li><p>重点： <strong>在函数的 prototype 里面存储的内容，不是给函数使用的，是给函数的每一个实例化对象使用的</strong></p>
</li>
<li><p>那实例化对象怎么使用能？</p>
</li>
</ul>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><ul>
<li><p><strong>每一个对象都天生自带一个成员，叫做 <code>__proto__</code>，是一个对象空间</strong></p>
</li>
<li><p>即然每一个对象都有，实例化对象也是对象，那么每一个实例化对象也有这个成员</p>
</li>
<li><p>这个 <code>__proto__</code> 对象空间是给每一个对象使用的</p>
</li>
<li><p>当你访问一个对象中的成员的时候</p>
<ul>
<li>如果这个对象自己本身有这个成员，那么就会直接给你结果</li>
<li>如果没有，就会去 <code>__proto__</code> 这个对象空间里面找，里面有的话就给你结果</li>
<li>未完待续。。。</li>
</ul>
</li>
<li><p>那么这个 <code>__proto__</code> 又指向哪里呢？</p>
<ul>
<li>这个对象是由哪个构造函数 new 出来的</li>
<li>那么这个对象的 <code>__proto__</code> 就指向这个构造函数的 <code>prototype</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们发现实例化对象的 <code>__proto__</code> 和所属的构造函数的 <code>prototype</code> 是一个对象空间</li>
<li>我们可以通过构造函数名称来向 <code>prototype</code> 中添加成员</li>
<li>对象在访问的时候自己没有，可以自动去自己的 <code>__proto__</code> 中查找</li>
<li>那么，我们之前构造函数的缺点就可以解决了<ul>
<li>我们可以把函数放在构造函数的 <code>prototype</code> 中</li>
<li>实例化对象访问的时候，自己没有，就会自动去 <code>__proto__</code> 中找</li>
<li>那么也可以使用了</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello Person'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.sayHi()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p1</code> 自己没有 <code>sayHi</code> 方法，就会去自己的 <code>__proto__</code> 中查找</li>
<li><code>p1.__proto__</code> 就是 <code>Person.prototype</code></li>
<li>我们又向 <code>Person.prototype</code> 中添加了 <code>sayHi</code> 方法</li>
<li>所以 <code>p1.sayHi</code> 就可以执行了</li>
</ul>
</li>
<li><p>到这里，当我们实例化多个对象的时候，每个对象里面都没有方法</p>
<ul>
<li>都是去所属的构造函数的 <code>protottype</code> 中查找</li>
<li>那么每一个对象使用的函数，其实都是同一个函数</li>
<li>那么就解决了我们构造函数的缺点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHi === p2.sayHi)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p1</code> 是 <code>Person</code> 的一个实例</li>
<li><code>p2</code> 是 <code>Person</code> 的一个实例</li>
<li>也就是说 <code>p1.__proto__</code> 和 <code>p2.__proto__</code> 指向的都是 <code>Person.prototype</code></li>
<li>当 <code>p1</code> 去调用 <code>sayHi</code> 方法的时候是去 <code>Person.prototype</code> 中找</li>
<li>当 <code>p2</code> 去调用 <code>sayHi</code> 方法的时候是去 <code>Person.prototype</code> 中找</li>
<li>那么两个实例化对象就是找到的一个方法，也是执行的一个方法</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>当我们写构造函数的时候</li>
<li><strong>属性我们直接写在构造函数体内</strong></li>
<li><strong>方法我们写在原型上</strong></li>
</ul>
</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul>
<li>我们刚才聊过构造函数了，也聊了原型</li>
<li>那么问题出现了，我们说构造函数的 <code>prototype</code> 是一个对象</li>
<li>又说了每一个对象都天生自带一个 <code>__proto__</code> 属性</li>
<li>那么 <strong>构造函数的 prototype</strong> 里面的 <code>__proto__</code> 属性又指向哪里呢？</li>
</ul>
<h3 id="一个对象所属的构造函数"><a href="#一个对象所属的构造函数" class="headerlink" title="一个对象所属的构造函数"></a>一个对象所属的构造函数</h3><ul>
<li><p>每一个对象都有一个自己所属的构造函数</p>
</li>
<li><p>比如： 数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组本身也是一个对象</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>以上两种方式都是创造一个数组</li>
<li>我们就说数组所属的构造函数就是 <code>Array</code></li>
</ul>
</li>
<li><p>比如： 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数本身也是一个对象</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>以上两种方式都是创造一个函数</li>
<li>我们就说函数所属的构造函数就是 <code>Function</code></li>
</ul>
</li>
</ul>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><ul>
<li>对象的 <code>__proto__</code> 里面也有一个成员叫做 <strong><code>constructor</code></strong></li>
<li>这个属性就是指向当前这个对象所属的构造函数</li>
</ul>
<h3 id="链状结构"><a href="#链状结构" class="headerlink" title="链状结构"></a>链状结构</h3><ul>
<li>当一个对象我们不知道准确的是谁构造的时候，我们呢就把它看成 <code>Object</code> 的实例化对象</li>
<li>也就是说，我们的 <strong>构造函数 的 prototype 的 <code>__proto__</code></strong> 指向的是 <code>Object.prototype</code></li>
<li>那么 <code>Object.prototype</code> 也是个对象，那么它的 <code>__proto__</code> 又指向谁呢？</li>
<li>因为 <code>Object</code> 的 js 中的顶级构造函数，我们有一句话叫 <strong>万物皆对象</strong></li>
<li>所以 <code>Object.prototype</code> 就到顶了，<code>Object.prototype</code> 的 <code>__proto__</code> 就是 null</li>
</ul>
<h3 id="原型链的访问原则"><a href="#原型链的访问原则" class="headerlink" title="原型链的访问原则"></a>原型链的访问原则</h3><ul>
<li>我们之前说过，访问一个对象的成员的时候，自己没有就会去 <code>__proto__</code> 中找</li>
<li>接下来就是，如果 <code>__proto__</code> 里面没有就再去 <code>__proto__</code> 里面找</li>
<li>一直找到 <code>Object.prototype</code> 里面都没有，那么就会返回 <code>undefiend</code></li>
</ul>
<h3 id="对象的赋值"><a href="#对象的赋值" class="headerlink" title="对象的赋值"></a>对象的赋值</h3><ul>
<li>到这里，我们就会觉得，如果是赋值的话，那么也会按照原型链的规则来</li>
<li>但是： <strong>并不是！并不是！并不是！</strong> 重要的事情说三遍</li>
<li>赋值的时候，就是直接给对象自己本身赋值<ul>
<li>如果原先有就是修改</li>
<li>原先没有就是添加</li>
<li>不会和 <code>__proto__</code> 有关系</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>到了这里，我们就发现了面向对象的思想模式了</p>
<ul>
<li>当我想完成一个功能的时候</li>
<li>先看看内置构造函数有没有能给我提供一个完成功能对象的能力</li>
<li>如果没有，我们就自己写一个构造函数，能创造出一个完成功能的对象</li>
<li>然后在用我们写的构造函数 new 一个对象出来，帮助我们完成功能就行了</li>
</ul>
</li>
<li><p>比如： tab选项卡</p>
<ul>
<li>我们要一个对象</li>
<li>对象包含一个属性：是每一个点击的按钮</li>
<li>对象包含一个属性：是每一个切换的盒子</li>
<li>对象包含一个方法：是点击按钮能切换盒子的能力</li>
<li>那么我们就需要自己写一个构造函数，要求 new 出来的对象有这些内容就好了</li>
<li>然后在用构造函数 new 一个对象就行了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY5-4_Promise</title>
    <url>/2021/11/03/DAY5-4-Promise/</url>
    <content><![CDATA[<h1 id="封装-AJAX"><a href="#封装-AJAX" class="headerlink" title="封装 AJAX"></a>封装 AJAX</h1><ul>
<li>ajax 使用起来太麻烦，因为每次都要写很多的代码</li>
<li>那么我们就封装一个 ajax 方法来让我们使用起来简单一些</li>
</ul><h2 id="确定一下使用的方式"><a href="#确定一下使用的方式" class="headerlink" title="确定一下使用的方式"></a>确定一下使用的方式</h2><ul>
<li><p>因为有一些内容可以不传递，我们可以使用默认值，所以选择对象传递参数的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用的时候直接调用，传递一个对象就可以</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">''</span>, <span class="comment">// 请求的地址</span></span><br><span class="line">  type: <span class="string">''</span>, <span class="comment">// 请求方式</span></span><br><span class="line">  <span class="keyword">async</span>: <span class="string">''</span>, <span class="comment">// 是否异步</span></span><br><span class="line">  data: <span class="string">''</span>, <span class="comment">// 携带的参数</span></span><br><span class="line">  dataType: <span class="string">''</span>, <span class="comment">// 要不要执行 json.parse</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 成功以后执行的函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>确定好使用方式以后，就开始书写封装函数</li>
</ul>
</li>
</ul><a id="more"></a>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先准备一个默认值</span></span><br><span class="line">  <span class="keyword">var</span> defInfo = &#123;</span><br><span class="line">    url: <span class="string">''</span>, <span class="comment">// 地址不需要默认值</span></span><br><span class="line">    type: <span class="string">'GET'</span>, <span class="comment">// 请求方式的默认值是 GET</span></span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span>, <span class="comment">// 默认值是异步</span></span><br><span class="line">    data: <span class="string">''</span>, <span class="comment">// 参数没有默认值</span></span><br><span class="line">    dataType: <span class="string">'string'</span>, <span class="comment">// 默认不需要执行 json.parse</span></span><br><span class="line">    success () &#123;&#125;, <span class="comment">// 默认是一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先来判断一下有没有传递 url，如果没有，直接抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!options.url) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'url 必须传递'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有了 url 以后就，我们就把用户传递的参数和我们的默认数据合并</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">    defInfo[key] = options[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来的一切我们都是使用我们的 defInfo 就可以了</span></span><br><span class="line">  <span class="comment">// 第一步就是判断参数 data</span></span><br><span class="line">  <span class="comment">// data 可以不传递，可以为空</span></span><br><span class="line">  <span class="comment">// data 也可以是一个 key=value&amp;key=value 格式的字符串</span></span><br><span class="line">  <span class="comment">// data 也可以是一个对象</span></span><br><span class="line">  <span class="comment">// 否则就抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">typeof</span> defInfo.data === <span class="string">'string'</span> &amp;&amp; <span class="regexp">/^(\w+=\w+&amp;?)*$/</span>.test(defInfo.data) || <span class="built_in">Object</span>.prototype.toString.call(defInfo.data) === <span class="string">'[object Object]'</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请按照要求传递参数'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理完毕以后，在判断 async 的数据类型</span></span><br><span class="line">  <span class="comment">// 只能传递 布尔数据类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> defInfo.async !== <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async 参数只接受布尔数据类型'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在接下来就判断 type</span></span><br><span class="line">  <span class="comment">// 请求方式我们只接受 GET 或着 POST</span></span><br><span class="line">  <span class="keyword">if</span> (!(defInfo.type.toUpperCase() === <span class="string">'GET'</span> || defInfo.type.toUpperCase() === <span class="string">'POST'</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'目前本插件只接受 GET 和 POST 方式，请期待更新'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来就是判断 success 的判断，必须是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(defInfo.success) !== <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'success 只接受函数数据类型'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数都没有问题了</span></span><br><span class="line">  <span class="comment">// 我们就要把 data 处理一下了</span></span><br><span class="line">  <span class="comment">// 因为 data 有可能是对象，当 data 是一个对象的时候，我们要把它转换成一个字符串</span></span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">''</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(defInfo.data) === <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> defInfo.data) &#123;</span><br><span class="line">      str += <span class="string">`<span class="subst">$&#123;attr&#125;</span>=<span class="subst">$&#123;defInfo.data[attr]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    str = str.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    defInfo.data = str</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数全部验证过了以后，我们就可以开始进行正常的 ajax 请求了</span></span><br><span class="line">  <span class="comment">// 1. 准备一个 ajax 对象</span></span><br><span class="line">  <span class="comment">//    因为要处理兼容问题，所以我们准备一个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (XMLHttpRequest) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建一个 ajax 对象</span></span><br><span class="line">  <span class="keyword">var</span> xhr = createXHR()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 进行 open</span></span><br><span class="line">  xhr.open(defInfo.type, defInfo.url + (defInfo.type.toUpperCase() === <span class="string">'GET'</span> ? <span class="string">`?<span class="subst">$&#123;defInfo.data&#125;</span>&amp;_=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>`</span> : <span class="string">''</span>), defInfo.async)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (defInfo.type.toUpperCase() === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 进行 send</span></span><br><span class="line">  xhr.send((defInfo.type.toUpperCase() === <span class="string">'POST'</span> ? <span class="string">`<span class="subst">$&#123;defInfo.data&#125;</span>`</span> : <span class="string">''</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 接受响应</span></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; <span class="regexp">/2\d&#123;2&#125;/</span>.test(xhr.status)) &#123;</span><br><span class="line">      <span class="comment">// 表示成功，我们就要执行 success</span></span><br><span class="line">      <span class="comment">// 但是要进行 dataType 的判断</span></span><br><span class="line">      <span class="keyword">if</span> (defInfo.dataType === <span class="string">'json'</span>) &#123;</span><br><span class="line">        defInfo.success(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        defInfo.success()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li><code>promise</code> 是一个 ES6 的语法</li>
<li>承诺的意思，是一个专门用来解决异步 <strong>回调地狱</strong> 的问题</li>
</ul>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul>
<li><p>什么是回调函数？</p>
</li>
<li><p>就是把函数 A 当作参数传递到 函数 B 中</p>
</li>
<li><p>在函数 B 中以行参的方式进行调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是函数 b'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么需要回调函数</p>
<ul>
<li>当我们执行一个异步的行为的时候，我们需要在一个异步行为执行完毕之后做一些事情</li>
<li>那么，我们是没有办法提前预知这个异步行为是什么时候完成的</li>
<li>我们就只能以回调函数的形式来进行</li>
<li>就比如我们刚刚封装过的那个 <code>ajax</code> 函数里面的 <code>success</code> </li>
<li>我们并不知道 ajax 请求什么时候完成，所以就要以回调函数的形式来进行</li>
</ul>
</li>
</ul>
<h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><ul>
<li><p>当一个回调函数嵌套一个回调函数的时候</p>
</li>
<li><p>就会出现一个嵌套结构</p>
</li>
<li><p>当嵌套的多了就会出现回调地狱的情况</p>
</li>
<li><p>比如我们发送三个 ajax 请求</p>
<ul>
<li>第一个正常发送</li>
<li>第二个请求需要第一个请求的结果中的某一个值作为参数</li>
<li>第三个请求需要第二个请求的结果中的某一个值作为参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'我是第一个请求'</span>,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="comment">// 现在发送第二个请求</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">'我是第二个请求'</span>，</span><br><span class="line">      data: &#123; <span class="attr">a</span>: res.a, <span class="attr">b</span>: res.b &#125;,</span><br><span class="line">      success (res2) &#123;</span><br><span class="line">        <span class="comment">// 进行第三个请求</span></span><br><span class="line">        ajax(&#123;</span><br><span class="line">          url: <span class="string">'我是第三个请求'</span>,</span><br><span class="line">          data: &#123; <span class="attr">a</span>: res2.a, <span class="attr">b</span>: res2.b &#125;,</span><br><span class="line">  				success (res3) &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(res3) </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>回调地狱，其实就是回调函数嵌套过多导致的</strong></p>
</li>
</ul>
<p><img src="J:/课程资料/week5/assets/回调地狱.jpeg" alt></p>
<ul>
<li>当代码成为这个结构以后，已经没有维护的可能了</li>
<li>所以我们要把代码写的更加的艺术一些</li>
</ul>
<h2 id="PROMISE"><a href="#PROMISE" class="headerlink" title="PROMISE"></a>PROMISE</h2><ul>
<li><p>为了解决回调地狱</p>
</li>
<li><p>我们就要使用 promise 语法</p>
</li>
<li><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve 表示成功的回调</span></span><br><span class="line">  <span class="comment">// reject 表示失败的回调</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 成功的函数</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 失败的函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>promise 就是一个语法</p>
<ul>
<li>我们的每一个异步事件，在执行的时候</li>
<li>都会有三个状态，执行中 / 成功 / 失败</li>
</ul>
</li>
<li><p>因为它包含了成功的回调函数</p>
</li>
<li><p>所以我们就可以使用 promise 来解决多个 ajax 发送的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  ajax(&#123;</span><br><span class="line">    url: <span class="string">'第一个请求'</span>,</span><br><span class="line">    success (res) &#123;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 准备发送第二个请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">'第二个请求'</span>,</span><br><span class="line">      data: &#123; <span class="attr">a</span>: res.a, <span class="attr">b</span>: res.b &#125;,</span><br><span class="line">      success (res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  ajax(&#123;</span><br><span class="line">    url: <span class="string">'第三个请求'</span>,</span><br><span class="line">    data: &#123; <span class="attr">a</span>: res.a, <span class="attr">b</span>: res.b &#125;,</span><br><span class="line">    success (res) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候，我们的代码已经改观了很多了</p>
</li>
<li><p>基本已经可以维护了</p>
</li>
<li><p>但是对于一个程序员来说，这个样子是不够的</p>
</li>
<li><p>我们还需要更加的简化代码</p>
</li>
<li><p>所以我们就需要用到一个 es7 的语法了</p>
</li>
<li><p>叫做 async/await </p>
</li>
</ul>
<h1 id="ASYNC-AWAIT"><a href="#ASYNC-AWAIT" class="headerlink" title="ASYNC/AWAIT"></a>ASYNC/AWAIT</h1><ul>
<li><p><code>async/await</code> 是一个 es7 的语法</p>
</li>
<li><p>这个语法是 <strong>回调地狱的终极解决方案</strong></p>
</li>
<li><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> promise对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个是一个特殊的函数方式</p>
</li>
<li><p>可以 await 一个 promise 对象</p>
</li>
<li><p><strong>可以把异步代码写的看起来像同步代码</strong></p>
</li>
<li><p>只要是一个 promiser 对象，那么我们就可以使用 <code>async/await</code> 来书写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">'第一个地址'</span>,</span><br><span class="line">      success (res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// res 就可以得到请求的结果</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">'第二个地址'</span>,</span><br><span class="line">      data: &#123; <span class="attr">a</span>: res.a, <span class="attr">b</span>: res.b &#125;,</span><br><span class="line">      success (res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">'第三个地址'</span>,</span><br><span class="line">      data: &#123; <span class="attr">a</span>: res2.a, <span class="attr">b</span>: res2.b &#125;,</span><br><span class="line">      success (res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// res3 就是我们要的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样的异步代码写的就看起来像一个同步代码了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY6-1_闭包和继承</title>
    <url>/2021/11/03/DAY6-1-%E9%97%AD%E5%8C%85%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul>
<li>闭包是我们函数的一种高级使用方式</li>
<li>在聊闭包之前我们要先回顾一下 <strong>函数</strong></li>
</ul><h2 id="函数的两个阶段"><a href="#函数的两个阶段" class="headerlink" title="函数的两个阶段"></a>函数的两个阶段</h2><ul>
<li>我们一直说函数有两个阶段<ol>
<li>定义阶段</li>
<li>调用阶段</li>
</ol>
</li>
</ul><h3 id="函数定义阶段"><a href="#函数定义阶段" class="headerlink" title="函数定义阶段"></a>函数定义阶段</h3><ol>
<li>开辟一个 <strong>存储空间</strong></li>
<li>把函数体内的代码一模一样的放在这个空间内（不解析变量）</li>
<li>把 <strong>存储空间</strong> 的地址给函数名</li>
</ol><h3 id="函数调用阶段"><a href="#函数调用阶段" class="headerlink" title="函数调用阶段"></a>函数调用阶段</h3><ol>
<li>按照函数名的地址找到函数的 <strong>存储空间</strong></li>
<li>形参赋值</li>
<li>预解析</li>
<li>将函数 <strong>存储空间</strong> 中的代码拿出来执行（才解析变量）</li>
</ol><a id="more"></a>



<h3 id="重新定义函数调用阶段"><a href="#重新定义函数调用阶段" class="headerlink" title="重新定义函数调用阶段"></a>重新定义函数调用阶段</h3><ol>
<li><p>按照函数名的地址找到函数的 <strong>存储空间</strong></p>
</li>
<li><p>形参赋值</p>
</li>
<li><p>预解析</p>
</li>
<li><p>在内存中开辟一个 <strong>执行空间</strong></p>
</li>
<li><p>将函数 <strong>存储空间</strong> 中的代码拿出来在刚刚开辟的 <strong>执行空间</strong> 中执行</p>
</li>
<li><p>执行完毕后，内存中开辟的 <strong>执行空间</strong> 销毁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是 fn 函数'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<ul>
<li>函数执行的时候会开辟一个 <strong>执行空间</strong> （我们暂且叫他 <code>xxff00</code>）</li>
<li><code>console.log(&#39;我是 fn 函数&#39;)</code> 这个代码就是在 <code>xxff00</code> 这个空间中执行</li>
<li>代码执行完毕以后，这个 <code>xxff00</code> 空间就销毁了</li>
</ul>
</li>
</ol>
<h2 id="函数执行空间"><a href="#函数执行空间" class="headerlink" title="函数执行空间"></a>函数执行空间</h2><ul>
<li>每一个函数会有一个 <strong>存储空间</strong></li>
<li>但是每一次调用都会生成一个完全不一样的 <strong>执行空间</strong></li>
<li>并且 <strong>执行空间</strong> 会在函数执行完毕后就销毁了，但是 <strong>存储空间</strong> 不会</li>
<li>那么这个函数空间执行完毕就销毁了，还有什么意义呢？<ul>
<li>我们可以有一些办法让这个空间 <strong>不销毁</strong></li>
<li><strong>闭包</strong>，就是要利用这个 <strong>不销毁的执行空间</strong></li>
</ul>
</li>
</ul>
<h3 id="函数执行空间不销毁"><a href="#函数执行空间不销毁" class="headerlink" title="函数执行空间不销毁"></a>函数执行空间不销毁</h3><ul>
<li><p>函数的 <strong>执行空间</strong> 会在函数执行完毕之后销毁</p>
</li>
<li><p>但是，一旦函数内部返回了一个 <strong>引用数据类型</strong>，并且 <strong>在函数外部有变量接受</strong> 的情况下</p>
</li>
<li><p>那么这个函数 <strong>执行空间</strong> 就不会销毁了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      name: <span class="string">'Jack'</span>,</span><br><span class="line">      age: <span class="number">18</span>,</span><br><span class="line">      gender: <span class="string">'男'</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = fn()</span><br></pre></td></tr></table></figure>
<ul>
<li>函数执行的时候，会生成一个函数 <strong>执行空间</strong> （我们暂且叫他 <code>xxff00</code>）</li>
<li>代码在 <code>xxff00</code> 空间中执行</li>
<li>在 <code>xxff00</code> 这个空间中声名了一个 对象空间（<code>xxff11</code>）</li>
<li>在 <code>xxff00</code> 这个执行空间把 <code>xxff11</code> 这个对象地址返回了</li>
<li>函数外部 <code>0</code> 接受的是一个对象的地址没错<ul>
<li>但是是一个在 <code>xxff00</code> 函数执行空间中的 <code>xxff11</code> 对象地址</li>
<li>因为 <code>o</code> 变量一直在和这个对象地址关联着，所以 <code>xxff00</code> 这个空间一直不会销毁</li>
</ul>
</li>
<li>等到什么时候，执行一句代码 <code>o = null</code><ul>
<li>此时， <code>o</code> 变量比在关联在 <code>xxff00</code> 函数执行空间中的 <code>xxff11</code> 对象地址</li>
<li>那么，这个时候函数执行空间 <code>xxff00</code> 就销毁了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>闭包就是利用了这个函数执行空间不销毁的逻辑</li>
<li>有几个条件组成闭包</li>
</ul>
<h3 id="不销毁的空间"><a href="#不销毁的空间" class="headerlink" title="不销毁的空间"></a>不销毁的空间</h3><ul>
<li><p>闭包的第一个条件就是利用了不销毁空间的逻辑</p>
</li>
<li><p>只不过不是返回一个 <strong>对象数据类型</strong></p>
</li>
<li><p>而是返回一个 <strong>函数数据类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = fn()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>f</code> 变量接受的就是一个 <strong>fn的执行空间</strong> 中的 函数</li>
</ul>
</li>
</ul>
<h3 id="内部函数引用外部函数中的变量"><a href="#内部函数引用外部函数中的变量" class="headerlink" title="内部函数引用外部函数中的变量"></a>内部函数引用外部函数中的变量</h3><ul>
<li><p>涉及到两个函数</p>
</li>
<li><p>内部函数要查看或者使用着外部函数的变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这个函数给一个名字，方便写笔记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = fn()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fn()</code> 的时候会生成一个 <code>xxff00</code> 的执行空间</li>
<li>再 <code>xxff00</code> 这个执行空间内部，定义了一个 <code>a</code> 函数的 <strong>存储空间</strong> <code>xxff11</code></li>
<li>全局 f 变量接受的就是 <code>xxff00</code> 里面的 <code>xxff11</code> </li>
<li>所以 <code>xxff00</code> 就是不会销毁的空间</li>
<li>因为 <code>xxff00</code> 不会销毁，所以，定义再里面的变量 num 也不会销毁</li>
<li>将来 <code>f()</code> 的时候，就能访问到 num 变量</li>
</ul>
</li>
</ul>
<h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul>
<li>为什么要叫做特点，就是因为他的每一个点都是优点同时也是缺点<ol>
<li>作用域空间不销毁<ul>
<li>优点： 因为不销毁，变量页不会销毁，增加了变量的生命周期</li>
<li>缺点： 因为不销毁，会一直占用内存，多了以后就会导致内存溢出</li>
</ul>
</li>
<li>可以利用闭包访问再一个函数外部访问函数内部的变量<ul>
<li>优点： 可以再函数外部访问内部数据</li>
<li>缺点： 必须要时刻保持引用，导致函数执行栈不被销毁</li>
</ul>
</li>
<li>保护私有变量<ul>
<li>优点： 可以把一些变量放在函数里面，不会污染全局</li>
<li>缺点： 要利用闭包函数才能访问，不是很方便</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="闭包概念（熟读并背诵全文）"><a href="#闭包概念（熟读并背诵全文）" class="headerlink" title="闭包概念（熟读并背诵全文）"></a>闭包概念（熟读并背诵全文）</h3><ul>
<li>有一个 A 函数，再 A 函数内部返回一个 B 函数</li>
<li>再 A 函数外部有变量引用这个 B 函数</li>
<li>B 函数内部访问着 A 函数内部的私有变量</li>
<li>以上三个条件缺一不可</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>继承是和构造函数相关的一个应用</li>
<li>是指，<strong>让一个构造函数去继承另一个构造函数的属性和方法</strong></li>
<li>所以继承一定出现在 <strong>两个构造函数之间</strong></li>
</ul>
<h3 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h3><ul>
<li>我们之前说，构造函数（类）是对一类行为的描述</li>
<li>那么我们类这个概念其实也很抽象</li>
<li>比如：<ul>
<li>我们说 <code>国光</code> / <code>富士</code> 都是 苹果的品种，那么我们就可以写一个 <code>苹果类</code> 来实例化很多品种出来</li>
<li>而 <code>苹果</code> / <code>梨</code> 这些东西都是水果的一种，那么我们就可以写一个 <code>水果类</code></li>
<li>说过的统一特点就是 <code>甜</code> / <code>水分大</code> ，而不同的水果有不同的特征</li>
<li>那么我们就可以让 <code>苹果类</code> 来继承 <code>水果类</code> 的内容，然后再用 <code>水果类</code> 去实例化对象</li>
<li>那么实例化出来的就不光有 <code>苹果类</code> 的属性和方法，还有 <code>水果类</code> 的属性和方法</li>
</ul>
</li>
</ul>
<h3 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h3><ul>
<li><p>其实说到底，到底什么是继承</p>
</li>
<li><p>我们之前说，在我们书写构造函数的时候，为了解决一个函数重复出现的问题</p>
</li>
<li><p>我们把构造函数的 <strong>方法</strong> 写在了 <code>prototype</code> 上</p>
<p><img src="J:/课程资料/week6/assets/构造函数.png" alt></p>
</li>
<li><p>这样，每一个实例使用的方法就都是来自构造函数的 <code>prototype</code> 上</p>
</li>
<li><p>就避免了函数重复出现占用内存得到情况</p>
</li>
<li><p>那么，如果两个构造函数的 prototype 中有一样的方法呢，是不是也是一种浪费</p>
</li>
<li><p>所以我们把构造函数䣌 prototype 中的公共的方法再次尽心提取</p>
<p><img src="J:/课程资料/week6/assets/继承.png" alt></p>
</li>
<li><p>我们准备一个更公共的构造函数，让构造函数的 <code>__proto__</code> 指向这个公共的构造函数的 <code>prototype</code> </p>
</li>
</ul>
<h3 id="常见的继承方式"><a href="#常见的继承方式" class="headerlink" title="常见的继承方式"></a>常见的继承方式</h3><ul>
<li><p>我们有一些常见的继承方式来实现和达到继承的效果</p>
</li>
<li><p>我们先准备一个父类（也就是要让别的构造函数使用我这个构造函数的属性和方法）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cosnole.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个 <code>Person</code> 构造函数为父类</p>
</li>
<li><p>让其他的构造函数来继承他</p>
</li>
<li><p>当别的构造函数能够使用他的属性和方法的时候，就达到了继承的效果</p>
</li>
</ul>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><ul>
<li><p>原型继承，就是在本身的原型链上加一层结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><ul>
<li><p>把父类构造函数体借用过来使用一下而已</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><ul>
<li><p>就是把 <code>原型继承</code> 和 <code>借用构造函数继承</code> 两个方式组合在一起</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ES6-的继承"><a href="#ES6-的继承" class="headerlink" title="ES6 的继承"></a>ES6 的继承</h3><ul>
<li><p>es6 的继承很容易，而且是固定语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面表示创造一个 Student 类，继承自 Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">// 必须在 constructor 里面执行一下 super() 完成继承 </span></span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样就继承成功了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY6-2_设计模式</title>
    <url>/2021/11/03/DAY6-2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>设计模式是我们在 <strong>解决问题的时候针对特定问题给出的简洁而优化的处理方案</strong></li>
<li>我们有很多的设计模式<ul>
<li>单例模式</li>
<li>组合模式</li>
<li>观察者模式</li>
<li>…</li>
</ul>
</li>
<li>今天我们就聊一下这三个设计模式<ul>
<li>单例模式 / 组合模式 / 观察者模式</li>
</ul>
</li>
</ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>什么是单例模式呢？</li>
<li>我们都知道，构造函数可以创造一个对象</li>
<li>我们 new 很多次构造函数就能得到很多的对象</li>
<li>单例模式： 就是使用构造函数实例化的时候，不管实例化多少回，都是同一个对象<ul>
<li>也就是一个构造函数一生只能 new 出一个对象</li>
</ul>
</li>
<li>也就是说，当我们使用构造函数，每一次 new 出来的对象 属性/功能/方法 <strong>完全一样</strong> 的时候，我们把他设计成单例模式</li>
</ul><a id="more"></a>

<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><ul>
<li><p>单例模式的核心代码很简单</p>
</li>
<li><p>其实就是判断一下，他曾经有没有 new 出来过对象</p>
</li>
<li><p>如果有，就还继续使用之前的那个对象，如果没有，那么就给你 new 一个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备一个构造函数</span></span><br><span class="line"><span class="comment">// 将来要 new 的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备一个单例模式函数</span></span><br><span class="line"><span class="comment">// 这个单例模式函数要把 Person 做成一个单例模式</span></span><br><span class="line"><span class="comment">// 将来再想要 new Person 的时候只要执行这个 singleton 函数就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleton</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!instance) &#123; <span class="comment">// 如果 instance 没有内容</span></span><br><span class="line">    <span class="comment">// 来到这里，证明 instance 没有内容</span></span><br><span class="line">    <span class="comment">// 给他赋值为 new Person</span></span><br><span class="line">      instance = <span class="keyword">new</span> Person()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回的永远都是第一次 new Person 的实例</span></span><br><span class="line">  <span class="comment">// 也就是永远都是一个实例</span></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = singleton()</span><br><span class="line"><span class="keyword">const</span> p2 = singleton()</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p>我们就用这个核心代码简单书写一个 demo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个构造函数的功能就是创建一个 div，添加到页面中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateDiv</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.div.innerHTML = text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备把这个 CreateDiv 做成单例模式</span></span><br><span class="line"><span class="comment">// 让 singleton 成为一个闭包函数</span></span><br><span class="line"><span class="keyword">const</span> singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateDiv()</span><br><span class="line">        &#125;</span><br><span class="line">        instance.init(text)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">singleton(<span class="string">'hello'</span>) <span class="comment">// 第一次的时候，页面中会出现一个新的 div ，内容是 hello</span></span><br><span class="line">singleton(<span class="string">'world'</span>) <span class="comment">// 第二次的时候，不会出现新的 div，而是原先的 div 内容变成了 world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ul>
<li><p>组合模式，就是把几个构造函数的器动方式组合再一起</p>
</li>
<li><p>然后用一个 ”遥控器“ 进行统一调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetHome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    init () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'到家了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    init () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'打开电脑'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    init () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'玩游戏'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面几个构造函数的创造的实例化对象的 <strong>启动方式</strong> 都一致</li>
<li>那么我们就可以把这几个函数以组合模式的情况书写</li>
<li>然后统一启动</li>
</ul>
</li>
<li><p>准备一个 <strong>组合模式</strong> 的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.compose = []</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">// 添加任务的方法</span></span><br><span class="line">    add (task) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compose.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个执行任务的方法</span></span><br><span class="line">    execute () &#123;</span><br><span class="line">        <span class="keyword">this</span>.compose.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            item.init()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们就用我们的组合模式构造函数来吧前面的几个功能组合起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Compose()</span><br><span class="line"><span class="comment">// 把所有要完成的任务都放在队列里面</span></span><br><span class="line">c.add(<span class="keyword">new</span> GetHome())</span><br><span class="line">c.add(<span class="keyword">new</span> OpenComputer)</span><br><span class="line">c.add(<span class="keyword">new</span> PlayGame)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接器动任务队列</span></span><br><span class="line">c.execute()</span><br><span class="line"><span class="comment">// 就会按照顺序执行三个对象中的 init 函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul>
<li>观察者模式，通常也被叫做 <strong>发布-订阅模式</strong>  或者 <strong>消息模式</strong></li>
<li>英文名称叫做 <strong><code>Observer</code></strong></li>
<li>官方解释： 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题</li>
<li>听起来很迷糊，但是其实没有很难</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><ul>
<li>当你想去书店买书，但是恰巧今天你要买的书没有了</li>
<li>我们又不能总在书店等着，就把我们的手机留给店员</li>
<li>当你需要的书到了的时候，他会打电话通知你，你去买了就好了</li>
<li>你买到数了以后，就告诉他，我买到了，那么以后再来了书就不会通知你了</li>
</ul>
<h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><ul>
<li><p>上面的例子可能还不是很明确</p>
</li>
<li><p>但是 <code>addEventListener</code> 是一个我们都用过的东西</p>
</li>
<li><p>这个东西其实就是一个标准的 <strong>观察者模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'btn 被点击了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面这个就是有一个 <strong>无形的观察者</strong> 再观察着 <code>btn</code> 的一举一动</li>
<li>当这个 <code>btn</code> 被点击的时候，就会执行 对应的函数</li>
<li>我们也可以多绑定几个函数</li>
</ul>
</li>
<li><p>说白了： 观察者模式就是我们自己实现一个 <code>addEventListener</code> 的功能</p>
<ul>
<li>只不过 <code>addEventListaner</code> 只有固定的一些事件，而且只能给 dom 元素绑定</li>
<li>而我们自己写的可以随便绑定一个事件名称，自己选择触发时机而已</li>
</ul>
</li>
</ul>
<h3 id="书写代码"><a href="#书写代码" class="headerlink" title="书写代码"></a>书写代码</h3><ul>
<li><p>首先我们分析功能</p>
<ul>
<li><p>我们要有一个观察者（这里抽象为一个对象 <code>{}</code>）</p>
</li>
<li><p>需要有一个属性，存放消息的盒子（把你绑定的所有事件放在里面）</p>
</li>
<li><p>需要一个 on 方法，用于添加事件</p>
</li>
<li><p>需要一个 emit 方法，用于发布事件（触发）</p>
</li>
<li><p>需要一个 off 方法，把已经添加的方法取消</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = &#123;</span><br><span class="line">    message: &#123;&#125;,</span><br><span class="line">    on: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    emit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    off: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们把它写成一个构造函数的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    on () &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    emit () &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    off () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，一个观察者的雏形就出来了</p>
</li>
<li><p>接下来完善方法就可以了</p>
</li>
</ul>
</li>
</ul>
<h4 id="ON"><a href="#ON" class="headerlink" title="ON"></a>ON</h4><ul>
<li><p>先来写 ON 方法</p>
</li>
<li><p>添加一个事件</p>
</li>
<li><p>我们的 on 方法需要接受 两个参数</p>
<ul>
<li>事件类型</li>
<li>事件处理函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="comment">// 判断消息盒子里面有没有设置事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.message[type]) &#123;</span><br><span class="line">            <span class="comment">// 证明消息盒子里面没有这个事件类型</span></span><br><span class="line">            <span class="comment">// 那么我们直接添加进去</span></span><br><span class="line">            <span class="comment">// 并且让他的值是一个数组，再数组里面放上事件处理函数</span></span><br><span class="line">            <span class="keyword">this</span>.message[type] = [fn]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 证明消息盒子里面有这个事件类型</span></span><br><span class="line">            <span class="comment">// 那么我们直接向数组里面追加事件处理函数就行了</span></span><br><span class="line">            <span class="keyword">this</span>.message[type].push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    emit () &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    off () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="EMIT"><a href="#EMIT" class="headerlink" title="EMIT"></a>EMIT</h4><ul>
<li><p>接下来就是发布事件</p>
</li>
<li><p>也就是让我们已经订阅好的事件执行一下</p>
</li>
<li><p>同样需要接受两个参数</p>
<ul>
<li>要触发的事件类型</li>
<li>给事件处理函数传递的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="comment">// 判断消息盒子里面有没有设置事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.message[type]) &#123;</span><br><span class="line">            <span class="comment">// 证明消息盒子里面没有这个事件类型</span></span><br><span class="line">            <span class="comment">// 那么我们直接添加进去</span></span><br><span class="line">            <span class="comment">// 并且让他的值是一个数组，再数组里面放上事件处理函数</span></span><br><span class="line">            <span class="keyword">this</span>.message[type] = [fn]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 证明消息盒子里面有这个事件类型</span></span><br><span class="line">            <span class="comment">// 那么我们直接向数组里面追加事件处理函数就行了</span></span><br><span class="line">            <span class="keyword">this</span>.message[type].push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    emit (type, ...arg) &#123;</span><br><span class="line">        <span class="comment">// 判断你之前有没有订阅过这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.message[type]) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有，那么我们就处理一下参数</span></span><br><span class="line">        <span class="keyword">const</span> event = &#123;</span><br><span class="line">            type: type,</span><br><span class="line">            arg: arg || &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环执行为当前事件类型订阅的所有事件处理函数</span></span><br><span class="line">        <span class="keyword">this</span>.message[type].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            item.call(<span class="keyword">this</span>, event)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    off () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="OFF"><a href="#OFF" class="headerlink" title="OFF"></a>OFF</h4><ul>
<li><p>最后就是移除事件</p>
</li>
<li><p>就是把已经订阅的事件处理函数移除掉</p>
</li>
<li><p>同样需要接受两个参数</p>
<ul>
<li>要移除的事件类型</li>
<li>要移除的事件处理函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="comment">// 判断消息盒子里面有没有设置事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.message[type]) &#123;</span><br><span class="line">            <span class="comment">// 证明消息盒子里面没有这个事件类型</span></span><br><span class="line">            <span class="comment">// 那么我们直接添加进去</span></span><br><span class="line">            <span class="comment">// 并且让他的值是一个数组，再数组里面放上事件处理函数</span></span><br><span class="line">            <span class="keyword">this</span>.message[type] = [fn]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 证明消息盒子里面有这个事件类型</span></span><br><span class="line">            <span class="comment">// 那么我们直接向数组里面追加事件处理函数就行了</span></span><br><span class="line">            <span class="keyword">this</span>.message[type].push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    emit (type, ...arg) &#123;</span><br><span class="line">        <span class="comment">// 判断你之前有没有订阅过这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.message[type]) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有，那么我们就处理一下参数</span></span><br><span class="line">        <span class="keyword">const</span> event = &#123;</span><br><span class="line">            type: type,</span><br><span class="line">            arg: arg || &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环执行为当前事件类型订阅的所有事件处理函数</span></span><br><span class="line">        <span class="keyword">this</span>.message[type].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            item.call(<span class="keyword">this</span>, event)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    off (type, fn) &#123;</span><br><span class="line">        <span class="comment">// 判断你之前有没有订阅过这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.message[type]) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有我们再进行移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.message[type].length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item =  <span class="keyword">this</span>.message[type][i]</span><br><span class="line">            <span class="keyword">if</span> (item === fn) &#123;</span><br><span class="line">                <span class="keyword">this</span>.message[type].splice(i, <span class="number">1</span>)</span><br><span class="line">                i--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>以上就是最基本的 <strong>观察者模式</strong></p>
</li>
<li><p>接下来我们就使用一下试试看</p>
</li>
</ul>
<h4 id="使用一下"><a href="#使用一下" class="headerlink" title="使用一下"></a>使用一下</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> Observer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备两个事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">o.on(<span class="string">'abc'</span>, a)</span><br><span class="line">o.on(<span class="string">'abc'</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件（触发）</span></span><br><span class="line">o.emit(<span class="string">'abc'</span>, <span class="string">'100'</span>, <span class="string">'200'</span>, <span class="string">'300'</span>) <span class="comment">// 两个函数都回执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">o.off(<span class="string">'abc'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次发布事件（触发）</span></span><br><span class="line">o.emit(<span class="string">'abc'</span>, <span class="string">'100'</span>, <span class="string">'200'</span>, <span class="string">'300'</span>) <span class="comment">// 只执行一个 a 函数了</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY7-2_SASS</title>
    <url>/2021/11/03/DAY7-2-SASS/</url>
    <content><![CDATA[<h1 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h1><ul>
<li><p><a href="https://www.sass.hk/" target="_blank" rel="noopener">SASS官网</a></p>
</li>
<li><h3 id="世界上最成熟、最稳定、最强大的专业级CSS扩展语言！"><a href="#世界上最成熟、最稳定、最强大的专业级CSS扩展语言！" class="headerlink" title="世界上最成熟、最稳定、最强大的专业级CSS扩展语言！"></a>世界上最成熟、最稳定、最强大的专业级CSS扩展语言！</h3></li>
<li><p><code>sass</code> 是一个 css 的预编译工具</p>
</li>
<li><p>也就是能够 <strong>更优雅</strong> 的书写 css</p>
</li>
<li><p><code>sass</code> 写出来的东西 <strong>浏览器不认识</strong></p>
</li>
<li><p>依旧是要转换成 css 在浏览器中运行</p>
</li>
<li><p>这个时候就需要一个工具来帮我们做</p>
</li>
</ul><h2 id="安装-sass-环境"><a href="#安装-sass-环境" class="headerlink" title="安装 sass 环境"></a>安装 sass 环境</h2><ul>
<li><p>以前的 <code>sass</code> 需要依赖一个 <code>ruby</code> 的环境</p>
</li>
<li><p>现在的 <code>sass</code> 需要依赖一个 <code>python</code> 的环境</p>
</li>
<li><p>但是我们的 node 强大了以后，我们只需要依赖 <code>node</code> 环境也可以</p>
</li>
<li><p>需要我们使用 npm 安装一个全局的 <code>sass</code> 环境就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 安装全局 sass 环境</span><br><span class="line"><span class="meta">$</span> npm install sass -g</span><br></pre></td></tr></table></figure>
</li>
</ul><a id="more"></a>

<h2 id="编译-sass"><a href="#编译-sass" class="headerlink" title="编译 sass"></a>编译 sass</h2><ul>
<li><p>有了全局的 <code>sass</code> 环境以后</p>
</li>
<li><p>我们就可以对 <code>sass</code> 的文件进行编译了</p>
</li>
<li><p><code>sass</code> 的文件后缀有两种，一种是 <code>.sass</code> 一种是 <code>.scss</code></p>
</li>
<li><p>他们两个的区别就是有没有 <code>{}</code> 和 <code>;</code></p>
</li>
<li><p><code>.scss</code> 文件</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.sass</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1 </span><br><span class="line">	width: 100px</span><br><span class="line">	height: 200px</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们比较常用的还是 <code>.scss</code> 文件</p>
</li>
<li><p>因为 <code>.sass</code> 我们写不习惯，当然，如果你能写习惯也比较好用</p>
</li>
<li><p>我们先不管里面的的什么内容，至少这个 <code>.scss</code> 或者 <code>.sass</code> 文件浏览器就不认识</p>
</li>
<li><p>我们就要用指令把 这两种 文件变成 css 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 把 index.scss 编译，输出成 index.css</span><br><span class="line"><span class="meta">$</span> sass index.scss index.css</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样我们就能得到一个 css 文件，在页面里面也是引入一个 css 文件就可以了</p>
</li>
</ul>
<h3 id="实时编译"><a href="#实时编译" class="headerlink" title="实时编译"></a>实时编译</h3><ul>
<li><p>我们刚才的编译方式只能编译一次</p>
</li>
<li><p>当你修改了文件以后要从新执行一遍指令才可以</p>
</li>
<li><p>实时编译就是随着你文件的修改，自动从新编译成 css 文件</p>
</li>
<li><p>也是使用指令来完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 实时监控 index.scss 文件，只要发生修改就自动编译，并放在 index.css 文件里面</span><br><span class="line"><span class="meta">$</span> sass --watch index.scss:index.css</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后你只要修改 <code>index.scss</code> 文件的内容，<code>index.css</code> 文件中的内容会自动更新</p>
</li>
</ul>
<h3 id="实时监控目录"><a href="#实时监控目录" class="headerlink" title="实时监控目录"></a>实时监控目录</h3><ul>
<li><p>之前的实时监控只能监控一个文件</p>
</li>
<li><p>但是我们有可能要写很多的文件</p>
</li>
<li><p>所以我们要准备一个文件夹，里面放的全部都是 sass 文件</p>
</li>
<li><p>实时的把里面的每一个文件都编译到 css 文件夹里面</p>
</li>
<li><p>依旧是使用指令的形式来完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 实时监控 sass 这个目录，只要有变化，就会实时响应在 css 文件夹下</span><br><span class="line"><span class="meta">$</span> sass --watch sass:css</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，只要你修改 sass 文件夹下的内容，就会实时的相应在 css 文件夹中</p>
</li>
<li><p>你新添加一个文件也会实时响应</p>
</li>
<li><p>但是你删除一个文件，css 文件夹中不会自动删除，需要我们自己手动删除</p>
</li>
</ul>
<h2 id="sass-语法"><a href="#sass-语法" class="headerlink" title="sass 语法"></a>sass 语法</h2><ul>
<li>我们能编译 <code>sass</code> 文件了，接下来我们就该学习一下 <code>sass</code> 的语法了</li>
<li>为什么他这么强大，这么好用，都是靠强大的语法</li>
<li><code>.sass</code> 和 <code>.scss</code> 文件的语法是一样的，只不过区别就是 <code>{}</code> 和 <code>;</code></li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>定义一个变量，在后面的代码中使用</p>
</li>
<li><p>使用 <code>$</code> 来定义变量</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 $c 作为变量，值是 红色</span></span><br><span class="line"><span class="variable">$c</span>: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="comment">// 在使用 $c 这个变量</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面定义的变量全局都可以使用</p>
</li>
<li><p>我们也可以在规则块内定义私有变量</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个 $w 变量只能在 h1 这个规则块中使用</span></span><br><span class="line">    <span class="variable">$w</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$w</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><ul>
<li><p><code>sass</code> 里面我们最长用到的就是嵌套了</p>
</li>
<li><p>而且相当的好用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个就是嵌套，理论上可以无限嵌套下去</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-tag">div</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">p</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="selector-tag">span</span>: &#123;</span><br><span class="line">                    color: red;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="嵌套中的-amp"><a href="#嵌套中的-amp" class="headerlink" title="嵌套中的 &amp;"></a>嵌套中的 &amp;</h4><ul>
<li><p>在嵌套中还有一个标识符是 <code>&amp;</code> 我们可以使用</p>
</li>
<li><p>先来看一个例子</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我想的是 div 被鼠标悬停的时候 width 变成 200</span></span><br><span class="line"><span class="comment">// 但是编译结果却是</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和预想的结果不一样了</p>
</li>
<li><p>这个时候就要用到 <code>&amp;</code> 来连接了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候就和我需要的一样了</p>
</li>
</ul>
<h4 id="群组嵌套"><a href="#群组嵌套" class="headerlink" title="群组嵌套"></a>群组嵌套</h4><ul>
<li><p>群组嵌套就是多个标签同时嵌套</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-class">.box1</span>, <span class="selector-class">.box2</span>, <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-class">.box1</span>, <span class="selector-tag">div</span> <span class="selector-class">.box2</span>, <span class="selector-tag">div</span> <span class="selector-class">.box3</span> &#123;</span><br><span class="line"> 	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种就是多个标签同时嵌套一个标签</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123;</span><br><span class="line"> 	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> <span class="selector-class">.box</span>, <span class="selector-tag">h2</span> <span class="selector-class">.box</span>, <span class="selector-tag">h3</span> <span class="selector-class">.box</span> &#123;</span><br><span class="line">  	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h4><ul>
<li><p>在 <code>scss</code> 里面还有一种特殊的嵌套</p>
</li>
<li><p>叫做 <strong>属性嵌套</strong></p>
</li>
<li><p>和选择器嵌套不一样，是写属性的时候使用的</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: &#123;</span><br><span class="line">        style: solid;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">        <span class="attribute">color</span>: pink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个属性嵌套还可以有一些特殊使用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span> &#123;</span><br><span class="line">        bottom: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><ul>
<li><p>也叫 <strong>混合器</strong></p>
</li>
<li><p>其实就是定义一个 “函数” 在 <code>scss</code> 文件中使用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个混合器使用  @mixin 关键字</span></span><br><span class="line"><span class="keyword">@mixin</span> radius &#123;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面是定义好的一个混合器</p>
</li>
<li><p>他是不会被编译的，只有当你使用了他以后，才会被编译</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用混合器使用 @include 关键字</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@include</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个就是吧刚才定义的混合器拿过来使用</p>
</li>
<li><p>编译结果</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="混合器传参"><a href="#混合器传参" class="headerlink" title="混合器传参"></a>混合器传参</h4><ul>
<li><p>我们既然说了，混合器就像一个 “函数” 一样，那么就一定可以像 “函数” 一样传递参数</p>
</li>
<li><p>和 “函数” 的使用方式一样，在定时的时候是 “形参”，在调用的时候是 “实参”</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义混合器</span></span><br><span class="line"><span class="keyword">@mixin</span> my_transition(<span class="variable">$pro</span>, <span class="variable">$dur</span>, <span class="variable">$delay</span>, <span class="variable">$tim</span>) &#123;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: <span class="variable">$pro</span> <span class="variable">$dur</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: <span class="variable">$pro</span> <span class="variable">$dur</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: <span class="variable">$pro</span> <span class="variable">$dur</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: <span class="variable">$pro</span> <span class="variable">$dur</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="variable">$pro</span> <span class="variable">$dur</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用这个混合器的时候传递 “实参”</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@include</span> my_transition(all, <span class="number">1s</span>, <span class="number">0s</span>, linear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译结果</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: all <span class="number">1s</span> <span class="number">0s</span> linear;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: all <span class="number">1s</span> <span class="number">0s</span> linear;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: all <span class="number">1s</span> <span class="number">0s</span> linear;</span><br><span class="line">    -o-<span class="attribute">transition</span>: all <span class="number">1s</span> <span class="number">0s</span> linear;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">1s</span> <span class="number">0s</span> linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写了多少个 “形参”，那么调用的时候就要传递多少个 “实参”</p>
</li>
<li><p>不然会报错的</p>
</li>
</ul>
<h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><ul>
<li><p>我们在定义混合器的时候，也可以给一些参数写一些默认值</p>
</li>
<li><p>这样一来，就可以不传递 “实参” 了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一些带有默认值的参数</span></span><br><span class="line"><span class="keyword">@mixin</span> my_transition(<span class="variable">$dur</span>: <span class="number">1s</span>, <span class="variable">$pro</span>: all, <span class="variable">$delay</span>: <span class="number">0s</span>, <span class="variable">$tim</span>: linear) &#123;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用的时候，如果你不传递，那么就是使用默认值</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 使用的时候，只传递一个，剩下的使用默认值</span></span><br><span class="line">  <span class="keyword">@include</span> my_transition(<span class="number">2s</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译结果</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: <span class="number">2s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: <span class="number">2s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: <span class="number">2s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    -o-<span class="attribute">transition</span>: <span class="number">2s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">2s</span> all <span class="number">0s</span> linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>在 <code>sass</code> 里面使用继承可以大大的提高开发效率</p>
</li>
<li><p>其实继承很简单，就是把之前写过的选择器里面的内容直接拿过来一份</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个是之前写过的一个规则样式表</p>
</li>
<li><p>接下来我要写另外一个样式了，发现我要写的一些内容和之前这个 div 一样，并且还有一些我自己的内容</p>
</li>
<li><p>那么我就可以把这个样式表先继承下来，再写我自己的内容就好了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">      <span class="keyword">@extend</span> div;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译结果</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>, <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p>在 <code>scss</code> 文件中的注释分为几种</p>
<ol>
<li><p>编译的时候不会被编译的注释</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是一个普通注释，在编译的时候，我就被过滤了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译的时候会被编译的注释</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 我在编译的时候，会被一起编译过去 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>强力注释</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*! 我是一个强力注释，不光编译的时候会被编译过去，将来压缩文件的时候也会存在 */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h3><ul>
<li><p>我们刚才学过了定义变量，定义混合器</p>
</li>
<li><p>而这两个内容在定义过以后，如果没有使用，是不会被编译出内容的</p>
</li>
<li><p>所以我们可以把变量单独写一个文件，混合器单独写一个文件，然后直接导入后使用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 variable.scss</span></span><br><span class="line"><span class="variable">$w</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="variable">$h</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="variable">$c</span>: pink;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 mixin.scss</span></span><br><span class="line"><span class="keyword">@mixin</span> my_transition(<span class="variable">$dur</span>: <span class="number">1s</span>, <span class="variable">$pro</span>: all, <span class="variable">$delay</span>: <span class="number">0s</span>, <span class="variable">$tim</span>: linear) &#123;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="variable">$dur</span> <span class="variable">$pro</span> <span class="variable">$delay</span> <span class="variable">$tim</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> radius &#123;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在我们的主要文件中把这个两个文件导入进来就行了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 index.scss</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'./variable.scss'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'./mixin.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$w</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$h</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@include</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> my_transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译结果</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: <span class="number">1s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: <span class="number">1s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: <span class="number">1s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    -o-<span class="attribute">transition</span>: <span class="number">1s</span> all <span class="number">0s</span> linear;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> all <span class="number">0s</span> linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>DAY7-1_NODE</title>
    <url>/2021/11/03/DAY7-1-NODE/</url>
    <content><![CDATA[<h1 id="NODE"><a href="#NODE" class="headerlink" title="NODE"></a>NODE</h1><ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node官网</a></li>
<li><a href="http://nodejs.cn/" target="_blank" rel="noopener">node中文网</a></li>
<li><p>什么是 node</p>
<ul>
<li>Node.js® is a JavaScript runtime built on <a href="https://v8.dev/" target="_blank" rel="noopener">Chrome’s V8 JavaScript engine</a>.</li>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </li>
</ul>
</li>
<li><p>这个是 node 官网的解释</p>
<ul>
<li>其实 node 就是用 javascript 语言写 <strong>后端</strong></li>
<li>也就是说，我们的 javascript 有了 node 以后，不光是一个前端语言，也是一个后端语言</li>
</ul>
</li>
<li>前端 javascript<ul>
<li>三大核心<ul>
<li>ECMAScript</li>
<li>DOM</li>
<li>BOM</li>
</ul>
</li>
<li>操作内容<ul>
<li>浏览器</li>
<li>解决兼容问题</li>
</ul>
</li>
</ul>
</li>
<li>后端 javascript （node）<ul>
<li>核心<ul>
<li>ECMAScript</li>
</ul>
</li>
<li>操作内容<ul>
<li>后端代码</li>
<li>数据库</li>
</ul>
</li>
</ul>
</li>
<li>也就是说，node 我们不需要解决兼容问题，不需要 DOM 和 BOM，只关注业务逻辑就可以了</li>
</ul><a id="more"></a>
<h2 id="下载-node-安装包"><a href="#下载-node-安装包" class="headerlink" title="下载 node 安装包"></a>下载 node 安装包</h2><ul>
<li><p>我们的电脑是没有自带 node 环境的</p>
</li>
<li><p>需要我们手动下载一个 node 安装包，安装 node 环境</p>
</li>
<li><p>有了 node 环境以后，我们就可以运行 node 了</p>
</li>
<li><p>下载方式</p>
<ul>
<li><p>直接到 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node官网</a> 或者 <a href="http://nodejs.cn/" target="_blank" rel="noopener">node中文网</a></p>
</li>
<li><p>点击下载就可以</p>
<p><img src="J:/课程资料/week7/assets/node下载.png" alt></p>
</li>
</ul>
<p><img src="J:/课程资料/week7/assets/node中文网下载.png" alt></p>
</li>
<li><p>注意： <strong>在 node 中文网下载的时候，选择安装包，不要选择 二进制文件</strong></p>
<ul>
<li>因为 二进制文件 是一个简单版，我们需要自己配置 <strong>环境变量</strong> 才可以使用</li>
</ul>
</li>
</ul>
<h2 id="安装-node-环境"><a href="#安装-node-环境" class="headerlink" title="安装 node 环境"></a>安装 node 环境</h2><ul>
<li><p>下载好以后，我们直接把下载好的文件双击运行就行</p>
</li>
<li><p>找到 <code>node-v10.16.2-x64.msi</code>  对应的文件</p>
<p><img src="J:/课程资料/week7/assets/node安装01.png" alt></p>
<p><img src="J:/课程资料/week7/assets/node安装02.png" alt></p>
<p><img src="J:/课程资料/week7/assets/node安装03.png" alt></p>
<p><img src="J:/课程资料/week7/assets/node安装04.png" alt></p>
<p><img src="J:/课程资料/week7/assets/node安装05.png" alt></p>
<p><img src="J:/课程资料/week7/assets/node安装06.png" alt></p>
</li>
<li><p>这个时候 node 就安装完毕了</p>
</li>
</ul>
<h2 id="检测安装环境"><a href="#检测安装环境" class="headerlink" title="检测安装环境"></a>检测安装环境</h2><ul>
<li><p>检测安装是否成功</p>
</li>
<li><p>我们打开运行窗口 （win + r）</p>
<ul>
<li><p>就是我们键盘下面那个 windows 的窗口键 + r 键</p>
<p><img src="J:/课程资料/week7/assets/运行窗口.png" alt></p>
</li>
</ul>
</li>
<li><p>写入 cmd 然后按下回车，来到我们的命令行</p>
<p><img src="J:/课程资料/week7/assets/命令行.png" alt></p>
</li>
<li><p>然后再命令行写入一个指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> node -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后按下回车，会得到一个 node 的版本号</p>
</li>
<li><p>能看到版本号表示 node 环境安装成功</p>
<p><img src="J:/课程资料/week7/assets/node版本检测.png" alt></p>
</li>
<li><p>至此，我们的 node 环境就有了</p>
</li>
<li><p>我们就可以再电脑里面运行我们的 node 了</p>
</li>
</ul>
<h2 id="node-初体验"><a href="#node-初体验" class="headerlink" title="node 初体验"></a>node 初体验</h2><ul>
<li>到现在，我们的 node 环境已经安装完毕了</li>
<li>接下来我们就体验一下 node</li>
<li>我们的 node 到底是一个什么东西<ul>
<li>就是直接在 终端（命令行） 中运行 <code>js</code> 代码</li>
<li>也可以用 <code>.js</code> 文件写一堆 <code>js</code> 代码</li>
<li>然后不需要浏览器，直接让我们写的 <code>js</code> 代码运行在我们自己电脑的终端上</li>
</ul>
</li>
</ul>
<h3 id="直接在终端中书写-js-代码"><a href="#直接在终端中书写-js-代码" class="headerlink" title="直接在终端中书写 js 代码"></a>直接在终端中书写 js 代码</h3><ul>
<li><p>打开命令行</p>
</li>
<li><p>书写指令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> node</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接按下回车，会看到 光标在闪烁，我们就进入了 node 代码编写环境</p>
</li>
<li><p>直接书写代码就可以了</p>
<p><img src="J:/课程资料/week7/assets/命令行直接编写js代码.png" alt></p>
</li>
</ul>
<h3 id="在命令行运行一个-js-文件"><a href="#在命令行运行一个-js-文件" class="headerlink" title="在命令行运行一个 js 文件"></a>在命令行运行一个 js 文件</h3><ul>
<li><p>先新建一个文件夹</p>
</li>
<li><p>在里面写一个 js 文件</p>
<ul>
<li>我这里默认在 <code>桌面/demo文件夹/idnex.js</code></li>
</ul>
</li>
<li><p>在文件里面写一些 js 代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello node'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开命令行，<strong>要让命令行的路径和你存放这个要执行的 js 文件的目录一致</strong></p>
<p><img src="J:/课程资料/week7/assets/命令行运行js文件.png" alt></p>
</li>
<li><p>切换好以后，我们直接使用指令来运行我们准备好的 js 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> node index.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就会在命令行把我们刚才写的 js 文件运行了</p>
</li>
<li><p>就会在控制台输出 <code>hello node</code></p>
<p><img src="J:/课程资料/week7/assets/命令行运行js文件02.png" alt></p>
</li>
<li><p>现在我们就已经运行了一段 js 代码在命令行了</p>
</li>
<li><p>这也就解释了一下最开始官网说的那句话</p>
<ul>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 <ul>
<li>我们的 node 安装完毕以后，就在命令行提供了一个基于 Chrome V8 引擎的运行环境</li>
<li>在这个环境中运行 javascript 代码</li>
<li>这个就是 node.js</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="常用的-LINUX-操作"><a href="#常用的-LINUX-操作" class="headerlink" title="常用的 LINUX 操作"></a>常用的 LINUX 操作</h1><ul>
<li>什么是 LINUX 操作</li>
<li>其实就是在命令行使用指令来操作我们的电脑</li>
<li>因为我们的 node 就是在命令行运行 js</li>
<li>所以我们要了解一些常用的命令行指令</li>
</ul>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul>
<li><p>目录操作就是操作我们的命令行路径</p>
<ol>
<li><p>查看当前目录下所有文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>以树状结构展示当前目录下的所有文件及子目录下的所有文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> tree</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入当前目录下的某一个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd 文件夹名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回上一级目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd ..</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换盘符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> 盘符:</span><br><span class="line"><span class="meta">$</span> d:</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li><p>文件操作就是通过指令创建文件或者文件夹</p>
<ol>
<li><p>创建文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示在当前目录下创建一个叫做 test 的文件夹</span><br><span class="line"><span class="meta">$</span> md test</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示移除当前文件夹下的 test 文件夹</span><br><span class="line"><span class="meta">$</span> rd test</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示复制一份 test 文件夹起名为 test2</span><br><span class="line"><span class="meta">$</span> xcopy test test2</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示在当前目录下创建一个叫做 index.js 的文件</span><br><span class="line"><span class="meta">$</span> type nul&gt; index.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝一份文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示复制一份 index.js 文件起名为 ceshi.js</span><br><span class="line"><span class="meta">$</span> copy index.js ceshi.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>向文本中写入内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示向 index.js 中写入一段文本 console.log('hello world')</span><br><span class="line"><span class="meta">$</span> echo console.log("hello world") &gt; index.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件内的文本内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示查看 index.js 文件中的文本内容是什么</span><br><span class="line"><span class="meta">$</span> type index.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>给文件或者目录重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示把 index.js 更名为 abc.js</span><br><span class="line"><span class="meta">$</span> ren index.js abc.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示把当前目录下的 index.js 删除</span><br><span class="line"><span class="meta">$</span> del index.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动文件或文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示把当前目录下的 index.js 文件移动到当前目录下的 a 文件夹下</span><br><span class="line"><span class="meta">$</span> move index.js a</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><ul>
<li><p>做一些其他事情的时候使用的</p>
<ol>
<li><p>清屏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示把当前屏幕的所有内容都清除</span><br><span class="line"><span class="meta">$</span> cls</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前电脑 IP 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示查看当前电脑的 IP 信息</span><br><span class="line"><span class="meta">$</span> ipconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试某一个链接地址的网速</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示查看访问 百度 网站的速度</span><br><span class="line"><span class="meta">$</span> ping www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看电脑信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示查看当前电脑的信息</span><br><span class="line"><span class="meta">$</span> systeminfo</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="NODE-的导入导出"><a href="#NODE-的导入导出" class="headerlink" title="NODE 的导入导出"></a>NODE 的导入导出</h1><ul>
<li><code>node</code> 的开发是模块化开发</li>
<li>每一个 js 文件都是一个独立的模块</li>
<li>都有自己独立的作用域</li>
<li>我们可以通过 导入导出 的方式把多个 js 文件合并在一起</li>
</ul>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><ul>
<li><p>在 node 里面，我们使用 <code>require</code> 来导入一个文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 index.js 文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是 index.js 文件'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我在命令行运行 <code>index.js</code> 文件的时候</p>
<ul>
<li>首先会把 <code>a.js</code> 文件运行一遍</li>
<li>然后再继续执行我自己文件内部的代码</li>
</ul>
</li>
<li><p>也可以再导入的时候接受另一个文件导出的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a 接受到的内容就是 a.js 这个文件导出的内容</span></span><br><span class="line"><span class="comment">// 如果 a.js 文件中什么都没有导出，那么接受到的就是一个 空对象</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ul>
<li><p>我们在写一个 js 文件的时候，可以向外导出一些内容</p>
</li>
<li><p>将来在这个文件被导入的时候，就可以接受到一些内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 a.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个 js 文件都会有一个对象叫做 module</span></span><br><span class="line"><span class="comment">// 在 module 里面有一个成员，叫做 exports</span></span><br><span class="line"><span class="comment">// 每一个 js 文件会默认把 module.exports 导出</span></span><br><span class="line"><span class="comment">// 也就是说，我们向 module.exports 中添加什么内容</span></span><br><span class="line"><span class="comment">// 那么就会导出什么内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.name = <span class="string">'Jack'</span></span><br><span class="line"><span class="built_in">module</span>.exports.age = <span class="number">18</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将来这个文件被导入的时候，接受到的内容就是一个对象，里面有两个成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123; name: 'Jack', age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>在 node 的开发过程中</li>
<li>我们是把每一个功能独立做成一个模块</li>
<li>然后在使用 导入导出 的方式把他们关联在一起<ul>
<li>利于维护</li>
<li>准确定位</li>
</ul>
</li>
<li>我们一般把模块分为三种<ol>
<li>内置模块 （node 天生就带有的模块）</li>
<li>自定义模块 （我们自己写的文件）</li>
<li>第三方模块 （从网上下载的别人写好的模块）</li>
</ol>
</li>
</ul>
<h1 id="NODE-常用的内置模块"><a href="#NODE-常用的内置模块" class="headerlink" title="NODE 常用的内置模块"></a>NODE 常用的内置模块</h1><ul>
<li>刚才是我们自己写的模块</li>
<li>现在我们来聊聊常见的内置模块</li>
</ul>
<h2 id="FS-模块"><a href="#FS-模块" class="headerlink" title="FS 模块"></a>FS 模块</h2><ul>
<li><p><code>fs</code> 是 node 的一个内置模块</p>
</li>
<li><p>专门用来操作文件的</p>
</li>
<li><p>使用的时候直接导入就可以使用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就可以使用 fs 这个变量去操作文件了</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步读取文件内容"><a href="#异步读取文件内容" class="headerlink" title="异步读取文件内容"></a>异步读取文件内容</h3><ul>
<li><p>异步的读取某一个文件内的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是异步读取，所以要在回调函数里面获取结果</span></span><br><span class="line">fs.readFile(<span class="string">'./text.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// err 表示读取的时候出现的错误</span></span><br><span class="line">    <span class="comment">// data 表示读取到的内容，如果出现错误，那么是 data 是没有内容的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="同步读取文件内容"><a href="#同步读取文件内容" class="headerlink" title="同步读取文件内容"></a>同步读取文件内容</h3><ul>
<li><p>同步读取某一个文件的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是同步读取，所以直接以返回值的形式接收读取的内容就可以</span></span><br><span class="line"><span class="keyword">const</span> res = fs.readFileSync(<span class="string">'./text.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="comment">// 同步读取的时候，如果出错会直接在控制台报错，并中断程序继续执行</span></span><br><span class="line"><span class="comment">// 如果没有错误，res 就会得到文件中的内容</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步写入文件"><a href="#异步写入文件" class="headerlink" title="异步写入文件"></a>异步写入文件</h3><ul>
<li><p>异步的向某一个文件中写入内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入内容的时候，一般不会出现错误</span></span><br><span class="line"><span class="comment">// 因为如果没有这个文件的话，会创建一个这个文件在向里面写入内容</span></span><br><span class="line"><span class="comment">// 所以回调函数一般没什么用处，只不过是在写入文件结束后做些事情而已</span></span><br><span class="line"><span class="comment">// 虽然没有用处，但是必须要写</span></span><br><span class="line">fs.writeFile(<span class="string">'./text.txt'</span>, <span class="string">'我是要写入的内容'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'写入完成'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="同步写入文件"><a href="#同步写入文件" class="headerlink" title="同步写入文件"></a>同步写入文件</h3><ul>
<li><p>同步的向某一个文件内写入内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是写入文件</span></span><br><span class="line"><span class="comment">// 没有返回值，因为一般都会写入成功</span></span><br><span class="line">fs.writeFileSync(<span class="string">'./text.txt'</span>, <span class="string">'我是要写入的内容'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP-模块"><a href="#HTTP-模块" class="headerlink" title="HTTP 模块"></a>HTTP 模块</h2><ul>
<li><p>因为 node 是一个服务端语言</p>
</li>
<li><p>所以 node 一定也可以开启一个服务器，开启一个服务</p>
</li>
<li><p><code>http</code> 这个模块就是专门用来开启服务，并且接受请求，返回响应的</p>
</li>
<li><p><code>http</code> 也是一个内置模块，直接导入使用就行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就可以使用 http 这个模块去开启服务了</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="创建一个服务"><a href="#创建一个服务" class="headerlink" title="创建一个服务"></a>创建一个服务</h3><ul>
<li><p>要开启先要创建一个服务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line"><span class="comment">// 这个服务默认监听 http 协议</span></span><br><span class="line"><span class="comment">// 这个服务默认监听 localhost 域名</span></span><br><span class="line"><span class="comment">// 返回值就是这个服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 前端发来的每一个请求都会触发这个函数</span></span><br><span class="line">    <span class="comment">// request 包含着所有的请求信息</span></span><br><span class="line">    <span class="comment">// response 是所有的响应信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="监听一个端口"><a href="#监听一个端口" class="headerlink" title="监听一个端口"></a>监听一个端口</h3><ul>
<li><p>确定这个服务监听哪一个端口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 前端发来的每一个请求都会触发这个函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数会在服务开启成功以后执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lintening on port 8080'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="给出一个响应"><a href="#给出一个响应" class="headerlink" title="给出一个响应"></a>给出一个响应</h3><ul>
<li><p>简单给出一个响应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 前端发来的每一个请求都会触发这个函数</span></span><br><span class="line">    <span class="comment">// 接受到请求以后给出一个响应</span></span><br><span class="line">    response.end(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数会在服务开启成功以后执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lintening on port 8080'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时，打开浏览器</p>
</li>
<li><p>地址栏输入 <code>localhost:8080</code></p>
</li>
<li><p>浏览器就会响应文字 <code>hello world</code></p>
</li>
</ul>
<h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><ul>
<li><p>在我们安装 <code>node</code> 的环境的时候，会自动帮我们一起安装一个 <code>npm</code> 环境</p>
</li>
<li><p>就好像我们安装一些软件的时候，会自动在帮我们安装一些什么 <code>xxx软件管家</code>/<code>xxx游戏</code> 之类的东西</p>
</li>
<li><p>但是 <code>npm</code> 不是垃圾软件，而是一个我们超级实用的工具</p>
</li>
</ul>
<h2 id="检测是否安装"><a href="#检测是否安装" class="headerlink" title="检测是否安装"></a>检测是否安装</h2><ul>
<li><p>和检测 node 一样</p>
</li>
<li><p>在命令行输入指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>能够得到一个版本号就可以了</p>
</li>
</ul>
<h2 id="了解-npm"><a href="#了解-npm" class="headerlink" title="了解 npm"></a>了解 npm</h2><ul>
<li>什么是 npm 呢</li>
<li>我们可以把他想象成一个大超市，一个装着所有我们需要用到的 <code>插件</code>/<code>库</code>/<code>框架</code> 的超市</li>
<li>我们要下载一个 <code>jQuery-validation</code> 插件<ul>
<li>我们可以选择去官网进行下载</li>
<li>可以选择去 GitHub 上查找并下载</li>
<li>也可以选择直接在命令行用 npm 下载</li>
</ul>
</li>
<li>我们要下载一个 <code>bootstrap</code><ul>
<li>我们可以选择去官网进行下载</li>
<li>可以选择去 GitHub 上查找并下载</li>
<li>也可以选择直接在命令行用 npm 下载</li>
</ul>
</li>
<li>也就是说，npm 包含着我们所有的第三方的东西</li>
<li>我们需要的时候，只要打开终端，就可以使用指令来帮我们下载<ul>
<li>再也不需要去官网找了</li>
</ul>
</li>
<li>而且，npm 不光可以在后端使用，也可以在前端使用</li>
<li><strong>npm 只不过是一个依赖于 node 环境的大型的包管理器</strong></li>
</ul>
<h2 id="使用-npm"><a href="#使用-npm" class="headerlink" title="使用 npm"></a>使用 npm</h2><ul>
<li>我们想使用 npm 只要打开命令行就可以了</li>
<li>作为一个 <strong>包管理器</strong></li>
<li>可以帮我们下载一些 插件 库 框架 之类的东西供我们使用</li>
</ul>
<h3 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h3><ul>
<li><p>打开命令行</p>
</li>
<li><p>输入下载的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示使用 npm 这个工具下载一个 jquery</span><br><span class="line"><span class="meta">$</span> npm install jquery</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载完毕以后，就会在当前目录下多出一个文件夹</p>
<ul>
<li>叫做 <code>node_modules</code></li>
<li>在这个目录下就会有一个文件夹叫做 <code>jquery</code></li>
<li>就是我们需要的东西了</li>
</ul>
</li>
<li><p>npm 的下载默认是下载最新版本的包</p>
</li>
<li><p>我们也可以在下载的时候指定一下我要下载哪一个版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示使用 npm 这个工具下载一个 3.3.7 版本的 jquery</span><br><span class="line"><span class="meta">$</span> npm install bootstrap@3.3.7</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h3><ul>
<li><p>在删除包的时候，我们可以直接去 <code>node_modules</code> 文件夹中找到对应的包的文件夹删除掉</p>
</li>
<li><p>但是这样做并不好，我们还是应该使用命令行的指令来删除包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示我要删除 jquery 这个包</span><br><span class="line"><span class="meta">$</span> npm uninstall jquery</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，这个包就会被卸载了</p>
</li>
</ul>
<h3 id="管理项目"><a href="#管理项目" class="headerlink" title="管理项目"></a>管理项目</h3><ul>
<li><p>我们的每一个项目都有可能需要依赖很多的包（有插件/库/框架）</p>
</li>
<li><p>npm 会帮助我们记录，我们当前这个项目所使用的包</p>
</li>
<li><p>但是前提是，你要告诉 npm 说： “你来帮我管理整个文件夹”</p>
</li>
<li><p>我们依旧是使用指令在命令行来告诉 npm </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示告诉 npm 你来帮我们管理整个文件夹（也就是我的整个项目）</span><br><span class="line"><span class="meta">$</span> npm init</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="npm-清除缓存"><a href="#npm-清除缓存" class="headerlink" title="npm 清除缓存"></a>npm 清除缓存</h3><ul>
<li><p>有的时候，有些包下载到一半，因为各种原因失败了（比如突然没有网了）</p>
</li>
<li><p>那么这个下载了一半的包 <strong>有可能</strong> 会被缓存下来</p>
</li>
<li><p>那么以后你再次下载的时候，就都是失败的状态</p>
</li>
<li><p>那么我们就要清除掉缓存以后，在重新下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示清除 npm 的缓存</span><br><span class="line"><span class="meta">$</span> npm cache clear -f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="NRM"><a href="#NRM" class="headerlink" title="NRM"></a>NRM</h1><ul>
<li>我们的 <code>npm</code> 虽然好用</li>
<li>但是有一个缺点<ul>
<li>就是，他虽然在帮我们下载东西</li>
<li>但是他的下载地址是在国外</li>
<li>也就是说，每次使用 npm 下载的时候，都是去国外的服务器上进行下载</li>
<li>那么就会有很多不稳定的因素</li>
<li>而且相对时间比较长</li>
</ul>
</li>
<li><code>nrm</code> 就是一个用来切换 <code>npm</code> 下载地址的工具（切换镜像源工具）</li>
</ul>
<h2 id="安装-NRM"><a href="#安装-NRM" class="headerlink" title="安装 NRM"></a>安装 NRM</h2><ul>
<li><p><code>nrm</code> 如果想使用，那么需要我们自己安装一下</p>
</li>
<li><p>因为是我们的工具，所以使用 <code>npm</code> 就可以安装</p>
</li>
<li><p>依旧是使用指令的方式来进行安装</p>
</li>
<li><p>只不过这里要把这个 <code>nrm</code> 安装成一个全局的依赖，而不再是项目内部的依赖了</p>
<ul>
<li>全局依赖，一个电脑安装一次，就一直可以使用</li>
</ul>
</li>
<li><p>我们使用指令安装一个全局 <code>nrm</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示安装一个全局 nrm</span><br><span class="line"><span class="meta">$</span> npm install --global nrm</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="检测安装"><a href="#检测安装" class="headerlink" title="检测安装"></a>检测安装</h3><ul>
<li><p>安装完毕之后，我们检测一下是否安装成功</p>
</li>
<li><p>和检测 node npm 的时候一样</p>
</li>
<li><p>在命令行使用指令查看一下版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> nrm --version</span><br></pre></td></tr></table></figure>
</li>
<li><p>能出现版本号，表示安装成功</p>
</li>
</ul>
<h2 id="使用-nrm"><a href="#使用-nrm" class="headerlink" title="使用 nrm"></a>使用 nrm</h2><ul>
<li>nrm 里面存着好几个镜像源地址</li>
<li>我们要挑一个比较快的使用</li>
</ul>
<h3 id="检测镜像源地址"><a href="#检测镜像源地址" class="headerlink" title="检测镜像源地址"></a>检测镜像源地址</h3><ul>
<li><p>我们直接在命令行使用指令来查看所有镜像源地址的网速</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示查看 nrm 镜像源地址网速</span><br><span class="line"><span class="meta">$</span> nrm test</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="切换镜像源"><a href="#切换镜像源" class="headerlink" title="切换镜像源"></a>切换镜像源</h3><ul>
<li><p>我们检测完毕以后，就直到哪个比较快了</p>
</li>
<li><p>我们就使用指令切换一下镜像源地址就好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示切换到 taobao 镜像源地址</span><br><span class="line"><span class="meta">$</span> nrm use taobao</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-Devtools调试工具</title>
    <url>/2018/07/24/Vue-Devtools%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="Vue在chrome浏览器的调试工具Vue-Devtools"><a href="#Vue在chrome浏览器的调试工具Vue-Devtools" class="headerlink" title="Vue在chrome浏览器的调试工具Vue-Devtools"></a>Vue在chrome浏览器的调试工具Vue-Devtools</h3><p> vue-devtools是一款基于chrome游览器的插件，用于调试vue应用，这可以极大地提高我们的调试效率。接下来我们就介绍一下vue-devtools的安装。 </p><p> <strong>安装地址：</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/vuejs/vue-devtools</span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd</span><br></pre></td></tr></table></figure>
<p>vue项目, 打开f12, 选择vue就可以使用了</p>
<p>vue是数据驱动的, 这样就能看到对应数据了, 方便我们进行调试</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>DAY7-3_GULP</title>
    <url>/2021/11/03/DAY7-3-GULP/</url>
    <content><![CDATA[<h1 id="GULP"><a href="#GULP" class="headerlink" title="GULP"></a>GULP</h1><ul>
<li><code>gulp</code> 是一个项目开发的 <strong>自动化打包构建工具</strong></li>
<li>基于 <code>node</code> 环境来运行的</li>
</ul><h2 id="什么是自动化打包构建工具"><a href="#什么是自动化打包构建工具" class="headerlink" title="什么是自动化打包构建工具"></a>什么是自动化打包构建工具</h2><ul>
<li>比如<ul>
<li>我们在开发的过程中，会写到 <code>js</code> 文件，<code>css</code> 文件，等等</li>
<li>我们的项目如果想上线，那么一定要体积小一点，文件大小越小越好</li>
<li>而我们在写 <code>js</code> 文件的时候，会有很多 <strong>换行/空格</strong> 之类的东西</li>
<li>这些 <strong>换行/空格</strong> 都是占文件体积的一部分</li>
<li>那么我们在上线之前就要吧这些 <strong>换行/空格</strong> 尽可能的删除掉</li>
<li>我们又不能一个文件一个文件的去删除</li>
<li>就要用到一个自动化工具来帮助我们把这些多余的东西干掉</li>
</ul>
</li>
<li>这个就是自动化工具的意义</li>
<li>常见的自动化打包构建工具<ul>
<li><code>gulp</code></li>
<li><code>webpack</code></li>
</ul>
</li>
</ul><a id="more"></a>

<h2 id="安装-GULP"><a href="#安装-GULP" class="headerlink" title="安装 GULP"></a>安装 GULP</h2><ul>
<li><p><code>gulp</code> 是一个依赖于 <code>node</code> 的环境工具</p>
</li>
<li><p>所以我们需要先安装一个 <strong>全局 <code>gulp</code> 依赖</strong></p>
</li>
<li><p>直接使用 <code>npm</code> 去安装就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 使用 npm 安装全局依赖 gulp</span><br><span class="line"><span class="meta">#</span> 我们这里安装一个 3.9.1 版本的就好了</span><br><span class="line"><span class="meta">$</span> npm install --global gulp@3.9.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待安装完毕就好了</p>
</li>
<li><p>这个全局环境一个电脑安装一次就好了</p>
</li>
<li><p>还是照例检查一下是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gulp --version</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用-GULP"><a href="#使用-GULP" class="headerlink" title="使用 GULP"></a>使用 GULP</h2><ul>
<li><p>安装完毕以后，我们就可以使用 GULP 对我们的项目进行自动化构建了</p>
</li>
<li><p>首先我们要有一个项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- gulp_demo    项目文件夹</span><br><span class="line">  - src        项目源码</span><br><span class="line">    + css      css 文件夹</span><br><span class="line">    + js       js 文件夹</span><br><span class="line">    + pages    html 文件夹</span><br><span class="line">    + sass     sass 文件夹</span><br><span class="line">    + lib      第三方文件夹</span><br><span class="line">    + static   静态资源文件夹</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录结构不一定都是这个样子</p>
</li>
<li><p>但是最好是一个便于管理的文件夹目录结构</p>
</li>
<li><p>因为是一个项目了，最好使用 <code>npm</code> 来帮我们管理一下</p>
<ul>
<li>这样可以记录我们的下载使用了那些依赖</li>
</ul>
</li>
<li><p>所以在项目文件夹 <code>gulp-demo</code> 里面执行一个 <strong><code>npm</code> 初始化</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd gulp_demo</span><br><span class="line"><span class="meta">$</span> npm init -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完毕之后，再来看一下我们的项目目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- gulp_demo</span><br><span class="line">  + src </span><br><span class="line">  + package.json</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="项目-GULP-配置"><a href="#项目-GULP-配置" class="headerlink" title="项目 GULP 配置"></a>项目 GULP 配置</h3><ul>
<li><p>我们之前已经安装过 <code>gulp</code> 全局依赖了</p>
</li>
<li><p>但是每一个项目都要在安装一次 <code>gulp</code> 的项目依赖</p>
</li>
<li><p>因为每一个项目的打包构建规则都不一样，所以不能全都配置成一个</p>
</li>
<li><p>所以我们要在项目里面再次进行 <code>gulp</code> 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd gulp_demo</span><br><span class="line"><span class="meta">$</span> npm install -D gulp@3.9.1</span><br></pre></td></tr></table></figure>
<ul>
<li>项目中的 <code>gulp</code> 依赖要和全局 <code>gulp</code> 环境保持版本一致</li>
</ul>
</li>
<li><p>接下来就是对这个项目进行打包构建的配置</p>
</li>
<li><p><code>gulp</code> 的使用，要在项目目录下新建一个 <code>gulpfile.js</code></p>
</li>
<li><p>在这个 <code>gulpfile.js</code> 文件里面进行配置</p>
</li>
<li><p>然后使用 <code>gulp</code> 进行构建的时候就会按照 <code>gulpfile.js</code> 文件里面的规则进行打包构建</p>
</li>
<li><p>再来看一下我们的目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- gulp_demo</span><br><span class="line">  + node_modules         依赖包目录</span><br><span class="line">  + src                  项目源码</span><br><span class="line">  + gulpfile.js          gulp 配置文件</span><br><span class="line">  + package-lock.json    依赖下载版本 json 文件</span><br><span class="line">  + package.json         项目管理 json 文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来我们就是在 <code>gulpfile.js</code> 文件里面进行配置，让我们的打包构建可以生效</p>
</li>
</ul>
<h3 id="打包-CSS-文件"><a href="#打包-CSS-文件" class="headerlink" title="打包 CSS 文件"></a>打包 CSS 文件</h3><ul>
<li><p>我们从简单的内容开始，先来打包构建 <code>css</code> 文件</p>
</li>
<li><p>其实就是在 <code>gulpfile.js</code> 里面进行一些配置</p>
</li>
<li><p>第一个事情就是引入 <code>gulp</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gulp</code> 是基于任务来完成构建的</p>
</li>
<li><p>所以我们要创建一个打包 <code>css</code> 的任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 css 的任务</span></span><br><span class="line"><span class="comment">//   gulp.task() 是用来创建任务的</span></span><br><span class="line"><span class="comment">//   参数一： 任务名称</span></span><br><span class="line"><span class="comment">//   参数二： 一个函数（这个任务要做什么事情）</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了任务以后，我们就要在 <code>css</code> 这个任务里面写一些这个任务要做的事情了</p>
</li>
<li><p>我们要把 <code>./src/css/所有css文件</code> 都进行压缩处理</p>
</li>
<li><p>这个时候我们自己完成不了，就需要借助一个第三方依赖</p>
<ul>
<li><code>npm i -D gulp-cssmin</code></li>
</ul>
</li>
<li><p>下载完毕以后，去文件中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   <span class="comment">// 对哪些文件进行操作</span></span><br><span class="line">    	.pipe(cssmin())        <span class="comment">// 都做什么，这里做的就是进行 css 压缩</span></span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  <span class="comment">// 把压缩完毕的文件放在 dist 文件夹下的 css 文件夹   </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gulp.src()</code> 是指找到那些文件对其操作</li>
<li><code>gulp.pipe()</code> 是指要做什么</li>
<li><code>gulp.dest()</code> 是指输出到哪个目录下，如果没有这个目录存在会自动创建这个目录</li>
<li>所以上面哪个 <code>css</code> 任务的意思就是<ul>
<li>把 <code>./src/css/</code> 目录下的所有文件</li>
<li>进行压缩</li>
<li>压缩完毕后放在 <code>./dist/</code> 下的 <code>css/</code> 文件夹下</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来，就是执行一下这个叫做 <code>css</code> 的任务就行了</p>
</li>
<li><p>直接在控制台使用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 表示运行 gulpfils.js 配置文件中的 css 任务</span><br><span class="line"><span class="meta">$</span> gulp css</span><br></pre></td></tr></table></figure>
<ul>
<li>执行完毕以后，就会在 <code>gulp_demo</code> 目录下生成一个 <code>dist/</code> 文件夹</li>
<li>里面就有我们压缩好的 <code>css</code> 文件</li>
</ul>
</li>
</ul>
<h4 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h4><ul>
<li><p>我们希望在 <code>css</code> 压缩之前，能帮我自动把需要前缀的属性 <strong>自动把前缀添加上</strong> 就好了</p>
</li>
<li><p>这个是可以做到的</p>
</li>
<li><p>我们又需要一个依赖了</p>
<ul>
<li><code>npm i -D gulp-autoprefixer</code></li>
</ul>
</li>
<li><p>安装完还是去到文件中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>因为添加前缀需要在压缩之前添加</li>
<li>所以我们就直接在任务里面多做一个事情就行了</li>
</ul>
</li>
</ul>
<h3 id="打包-SASS-文件"><a href="#打包-SASS-文件" class="headerlink" title="打包 SASS 文件"></a>打包 SASS 文件</h3><ul>
<li><p>接下来我们解决一下 <code>sass</code> 的问题</p>
</li>
<li><p>因为有的时候我们开发要使用 <code>sass</code> 所以我们要解决一下 <code>sass</code> 的问题</p>
</li>
<li><p>其实打包 <code>sass</code> 和 <code>css</code> 差不多，只不过先要把 <code>sass</code> 解析成 <code>css</code> </p>
<ol>
<li>把 <code>sass</code> 解析成 <code>css</code></li>
<li>自动添加前缀</li>
<li>压缩一下</li>
<li>放到对应的文件夹中</li>
</ol>
</li>
<li><p>使用 <code>gulp</code> 解析 <code>sass</code> 文件需要用到一个依赖</p>
<ul>
<li><code>npm i -D gulp-sass</code></li>
</ul>
</li>
<li><p>然后我们就去到配置文件里面进行配置就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>我们的 <code>sass</code> 文件编译完以后也是 <code>css</code> 文件，所以就也放在 <code>css</code> 文件夹下就好了</li>
<li>就是要注意一下别和本来 <code>css</code> 文件夹下的文件重名就好了</li>
</ul>
</li>
<li><p>然后就可以去命令行执行 <code>sass</code> 这个任务了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 执行 sass 任务</span><br><span class="line"><span class="meta">$</span> gulp sass</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="打包-JS-文件"><a href="#打包-JS-文件" class="headerlink" title="打包 JS 文件"></a>打包 JS 文件</h3><ul>
<li><p>接下来就是打包一下 <code>js</code> 文件了</p>
</li>
<li><p>其实套路是一样的</p>
</li>
<li><p>先来做最简单的操作</p>
</li>
<li><p>压缩一下 <code>js</code> 文件</p>
</li>
<li><p>需要用到一个依赖</p>
<ul>
<li><code>npm i -D gulp-uglify</code></li>
</ul>
</li>
<li><p>然后依旧是去到配置文件中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们去命令行执行 <code>js</code> 这个任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 执行 js 任务</span><br><span class="line"><span class="meta">$</span> gulp js</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编译-ES6-语法"><a href="#编译-ES6-语法" class="headerlink" title="编译 ES6 语法"></a>编译 ES6 语法</h4><ul>
<li><p>之前我们学习 <code>es6</code> 的时候就说过</p>
</li>
<li><p>很多浏览器不是很认识 <code>es6</code> 的语法</p>
</li>
<li><p>我们要把他编译成 <code>es5</code> 的语法</p>
</li>
<li><p>所以我们在打包 <code>js</code> 文件的时候，就要转换一下</p>
</li>
<li><p>我们依旧是使用依赖来完成，只不过 <code>es6</code> 转 <code>es5</code> 需要三个依赖</p>
<ul>
<li><code>npm i -D gulp-babel@7.0.1</code></li>
<li><code>npm i -D babel-core</code></li>
<li><code>npm i -D babel-preset-es2015</code></li>
</ul>
</li>
<li><p>然后我们就去配置文件里面进行配置就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>引入以后，只要在压缩之前执行一下转码就可以了</li>
<li>注意要传递一个参数</li>
</ul>
</li>
<li><p>然后再次执行 <code>js</code> 任务就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 执行 js 任务</span><br><span class="line"><span class="meta">$</span> gulp js</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="打包-HTML-文件"><a href="#打包-HTML-文件" class="headerlink" title="打包 HTML 文件"></a>打包 HTML 文件</h3><ul>
<li><p>接下来就要把 <code>html</code> 文件解决一下了</p>
</li>
<li><p>还是一个套路</p>
</li>
<li><p>压缩 <code>html</code> 文件需要一个依赖</p>
<ul>
<li><code>npm i -D gulp-htmlmin</code></li>
</ul>
</li>
<li><p>下载好以后去到配置文件中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>这样就配置完毕了</li>
</ul>
</li>
<li><p>接下来就是去命令行运行一下 <code>html</code> 任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 运行 html 任务</span><br><span class="line"><span class="meta">$</span> gulp html</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="处理-LIB-和-STATIC-文件"><a href="#处理-LIB-和-STATIC-文件" class="headerlink" title="处理 LIB 和 STATIC 文件"></a>处理 LIB 和 STATIC 文件</h3><ul>
<li><p>接下来我们就是处理 <code>lib</code> 和 <code>static</code> 里面的文件了</p>
</li>
<li><p>因为这些都是第三方的文件和一些图片之类的信息</p>
</li>
<li><p>不需要压缩处理，只要给我转到 <code>dist</code> 文件夹下就可以了</p>
</li>
<li><p>所以不需要依赖，直接处理就行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个 lib 任务</span></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个 static 任务</span></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是去命令行执行 <code>lib</code> 任务和 <code>static</code> 任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 执行 lib 任务</span><br><span class="line"><span class="meta">$</span> gulp lib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 执行 static 任务</span><br><span class="line"><span class="meta">$</span>gulp static</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="批量执行任务"><a href="#批量执行任务" class="headerlink" title="批量执行任务"></a>批量执行任务</h3><ul>
<li><p>我们的几个和文件相关的任务都配置完毕了</p>
</li>
<li><p>但是我们不能在开发过程中一个任务一个任务的去执行</p>
</li>
<li><p>不方便也不是很只能</p>
</li>
<li><p>所以我们要统一执行任务</p>
</li>
<li><p>这个时候就需要进行一个配置，让几个任务一起执行一下</p>
</li>
<li><p>这个不需要依赖，我们只需要配置一个叫做 <code>default</code> 的任务</p>
</li>
<li><p><code>gulp</code> 在运行的时候会默认执行 <code>default</code> 任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个 lib 任务</span></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个 static 任务</span></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 配置一个默认任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'css'</span>, <span class="string">'sass'</span>, <span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'lib'</span>, <span class="string">'static'</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>这样配置完毕以后，当你运行 <code>gulp</code> 的时候，会自动执行 <code>default</code> 任务</li>
<li>然后 <code>default</code> 任务就会把后面数组中写的几个任务并行执行了</li>
</ul>
</li>
<li><p>接下来就是去命令行里面运行 <code>gulp</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 运行 gulp，会默认执行 default 任务</span><br><span class="line"><span class="meta">$</span> gulp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="清除-DIST-文件夹"><a href="#清除-DIST-文件夹" class="headerlink" title="清除 DIST 文件夹"></a>清除 DIST 文件夹</h3><ul>
<li><p>当你在编译的时候，如果第一次编译有一个叫做 <code>a.css</code> 的文件，他会帮你编译</p>
</li>
<li><p>后来你把 <code>a.css</code> 文件改名字了，改叫 <code>b.css</code>，再次进行编译的时候</p>
</li>
<li><p>会给你新生成一个 <code>b.css</code> 文件在 <code>dist</code> 文件夹中</p>
</li>
<li><p>之前的 <code>a.css</code> 文件也不会消失</p>
</li>
<li><p>那么这样就不是很好了</p>
</li>
<li><p>我们比较好的做法是</p>
<ul>
<li>在执行所有的编译之前</li>
<li>先把 <code>dist</code> 文件夹删除掉</li>
<li>然后再执行所有的编译操作</li>
</ul>
</li>
<li><p>这样就不会用多余的文件留下了</p>
</li>
<li><p>这个时候我们就要使用一个依赖</p>
<ul>
<li><code>npm i -D gulp-clean</code></li>
</ul>
</li>
<li><p>然后去配置文件里面配置一个任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 引入 gulp-clean</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个 lib 任务</span></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个 static 任务</span></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 创建一个 clean 任务</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./dist'</span>)</span><br><span class="line">    	.pipe(clean())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 配置一个默认任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'css'</span>, <span class="string">'sass'</span>, <span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'lib'</span>, <span class="string">'static'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来我们执行任务的时候就应该先执行 <code>clean</code> 任务，再执行 <code>default</code> 任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 执行 clean 任务</span><br><span class="line"><span class="meta">$</span> gulp clean</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 执行 default 任务</span><br><span class="line"><span class="meta">$</span> gulp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="按顺序执行任务"><a href="#按顺序执行任务" class="headerlink" title="按顺序执行任务"></a>按顺序执行任务</h3><ul>
<li><p>因为每次打包都要执行一个 <code>clean</code> 任务</p>
</li>
<li><p>那么我们就可以把 <code>clean</code> 任务也加到 <code>default</code> 任务的队列里面执行</p>
<ul>
<li><code>gulp.task(&#39;default&#39;, [&#39;clean&#39;, css&#39;, &#39;sass&#39;, &#39;js&#39;, &#39;html&#39;, &#39;lib&#39;, &#39;static&#39;])</code></li>
</ul>
</li>
<li><p>这样我们运行的时候，每次就都会帮我们执行 <code>clean</code> 任务了</p>
</li>
<li><p>但是会出现一个问题</p>
<ul>
<li>因为后面队列里面的任务是并行的</li>
<li>那么有的时间长有的时间短</li>
<li>那么就会出现有一些文件已经压缩完毕放在 <code>dist/</code> 文件夹里面了</li>
<li>然后 <code>clean</code> 任务执行完毕的时候又给直接清除掉了</li>
<li>这样不是很好</li>
</ul>
</li>
<li><p>我们就需要让这些任务出现先后顺序</p>
<ul>
<li>先执行一下 <code>clean</code> 任务</li>
<li><code>clean</code> 执行完毕以后，剩下的几个压缩文件的任务可以并行执行</li>
</ul>
</li>
<li><p>这个时候我们就需要用到一个依赖</p>
<ul>
<li><code>npm i -D run-sequence</code></li>
</ul>
</li>
<li><p>这个依赖是逐步执行任务的一个包</p>
</li>
<li><p>这个时候我们修改一下 <code>default</code> 任务就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 引入 gulp-clean</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 引入 run-sequence</span></span><br><span class="line"><span class="keyword">const</span> runSequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个 lib 任务</span></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个 static 任务</span></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 创建一个 clean 任务</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./dist'</span>)</span><br><span class="line">    	.pipe(clean())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 改写 default 任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面的每一个参数都可以是一个任务或者一个任务队列</span></span><br><span class="line">    <span class="comment">// 再执行任务的时候，会把前一个任务队列完成的情况下再执行下一个任务队列</span></span><br><span class="line">  	runSequence(<span class="string">'clean'</span>, [<span class="string">'css'</span>, <span class="string">'sass'</span>, <span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'lib'</span>, <span class="string">'static'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>这样依赖，每次都是先执行 <code>clean</code> 任务</li>
<li>执行完毕之后再并行执行那些压缩的任务就不会出现问题了</li>
</ul>
</li>
<li><p>然后我们就去命令行中运行 <code>gulp</code> 执行一下 <code>default</code> 任务就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 运行 gulp</span><br><span class="line"><span class="meta">$</span> gulp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自动打开浏览器"><a href="#自动打开浏览器" class="headerlink" title="自动打开浏览器"></a>自动打开浏览器</h3><ul>
<li><p>我们的打包工作已经完成了</p>
</li>
<li><p>接下来要是能再打包完毕自动帮我把浏览器打开就好了</p>
</li>
<li><p>省的我自己去开了</p>
</li>
<li><p>这个时候是可以做到的</p>
</li>
<li><p>需要一个依赖</p>
<ul>
<li><code>npm i -D gulp-webserver</code></li>
</ul>
</li>
<li><p>然后进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 引入 gulp-clean</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 引入 run-sequence</span></span><br><span class="line"><span class="keyword">const</span> runSequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 引入 gulp-webserver</span></span><br><span class="line"><span class="keyword">const</span> webserver = <span class="built_in">require</span>(<span class="string">'gulp-webserver'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个 lib 任务</span></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个 static 任务</span></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 创建一个 clean 任务</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./dist'</span>)</span><br><span class="line">    	.pipe(clean())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 创建一个 webserver 任务</span></span><br><span class="line">gulp.task(<span class="string">'webserver'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./dist'</span>)</span><br><span class="line">        .pipe(webserver(&#123;</span><br><span class="line">            host: <span class="string">'localhost'</span>,          <span class="comment">// 配置打开浏览器的域名</span></span><br><span class="line">            port: <span class="number">3000</span>,                 <span class="comment">// 配置打开浏览器的端口号</span></span><br><span class="line">            livereload: <span class="literal">true</span>,           <span class="comment">// 自动刷新浏览器</span></span><br><span class="line">            open: <span class="string">'./pages/index.html'</span>  <span class="comment">// 默认打开 dist 文件夹下的哪个文件</span></span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 改写 default 任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面的每一个参数都可以是一个任务或者一个任务队列</span></span><br><span class="line">    <span class="comment">// 再执行任务的时候，会把前一个任务队列完成的情况下再执行下一个任务队列</span></span><br><span class="line">  	runSequence(</span><br><span class="line">        <span class="string">'clean'</span>, </span><br><span class="line">        [<span class="string">'css'</span>, <span class="string">'sass'</span>, <span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'lib'</span>, <span class="string">'static'</span>],</span><br><span class="line">    	<span class="string">'webserver'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>因为我们打开浏览器应该再所有压缩任务都完成以后</li>
<li>再把浏览器打开</li>
<li>所以我们把他排在任务的第三个队列上</li>
</ul>
</li>
<li><p>这个 <code>webserver</code> 会自动帮我们启动一个服务器</p>
</li>
<li><p>是一个 <code>node</code> 的服务器</p>
</li>
<li><p>所以我们的页面也相当于是在服务器上打开的</p>
</li>
</ul>
<h3 id="修改内容自动刷新"><a href="#修改内容自动刷新" class="headerlink" title="修改内容自动刷新"></a>修改内容自动刷新</h3><ul>
<li><p>我们刚才再配置 <code>webserver</code> 的时候有一个自动刷新的功能被我们开启了</p>
</li>
<li><p>但是我们修改一些文件的时候发现并没有自动刷新</p>
</li>
<li><p>这个是因为，我们只是开启了自动刷新，但是你修改文件以后并没有自动帮我们重新编译</p>
</li>
<li><p>那么 <code>dist/</code> 文件夹下的内容就不会更改，那么刷新就没有意义</p>
</li>
<li><p>所以我们应该再制作一个任务，当文件夹下的内容修改的时候，自动帮我们从新编译</p>
</li>
<li><p>这个不需要任何依赖，我们只需要配置一个监控文件改变的任务就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 引入 gulp-cssmin</span></span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 引入 gulp-autoprefixer </span></span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-3. 引入 gulp-sass</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. 引入 gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-2. 引入 gulp-babel</span></span><br><span class="line"><span class="comment">//      es6 转 es5 虽然需要下载三个依赖，但是只需要引入一个 gulp-babel 就可以了</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 引入 gulp-htmlmin</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 引入 gulp-clean</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 引入 run-sequence</span></span><br><span class="line"><span class="keyword">const</span> runSequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 引入 gulp-webserver</span></span><br><span class="line"><span class="keyword">const</span> webserver = <span class="built_in">require</span>(<span class="string">'gulp-webserver'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-1. 创建一个 css 的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2-2. 创建一个 sass 任务</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 js 任务</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个 html 任务</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>, <span class="comment">// 移出所有空属性</span></span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span> <span class="comment">// 压缩 html</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个 lib 任务</span></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个 static 任务</span></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 创建一个 clean 任务</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./dist'</span>)</span><br><span class="line">    	.pipe(clean())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 创建一个 webserver 任务</span></span><br><span class="line">gulp.task(<span class="string">'webserver'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./dist'</span>)</span><br><span class="line">        .pipe(webserver(&#123;</span><br><span class="line">            host: <span class="string">'localhost'</span>,          <span class="comment">// 配置打开浏览器的域名</span></span><br><span class="line">            port: <span class="number">3000</span>,                 <span class="comment">// 配置打开浏览器的端口号</span></span><br><span class="line">            livereload: <span class="literal">true</span>,           <span class="comment">// 自动刷新浏览器</span></span><br><span class="line">            open: <span class="string">'./pages/index.html'</span>  <span class="comment">// 默认打开 dist 文件加下的哪个文件</span></span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 创建一个 watch 任务</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./src/css/**'</span>, [<span class="string">'css'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/sass/**'</span>, [<span class="string">'sass'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/js/**'</span>, [<span class="string">'js'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/pages/**'</span>, [<span class="string">'html'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/lib/**'</span>, [<span class="string">'lib'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/static/**'</span>, [<span class="string">'static'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 改写 default 任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 里面的每一个参数都可以是一个任务或者一个任务队列</span></span><br><span class="line">    <span class="comment">// 再执行任务的时候，会把前一个任务队列完成的情况下再执行下一个任务队列</span></span><br><span class="line">  	runSequence(</span><br><span class="line">        <span class="string">'clean'</span>, </span><br><span class="line">        [<span class="string">'css'</span>, <span class="string">'sass'</span>, <span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'lib'</span>, <span class="string">'static'</span>],</span><br><span class="line">    	[<span class="string">'webserver'</span>, <span class="string">'watch'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>因为再文件压缩完毕以后，我们就可以开始监控了</li>
<li>所以把这个 <code>watch</code> 任务和 <code>webserver</code> 任务并行就可以了</li>
</ul>
</li>
<li><p>接下来我们就可以再命令行运行 <code>gulp</code> 了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 运行 gulp</span><br><span class="line"><span class="meta">$</span> gulp</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候，我们只要进行代码书写就可以了</p>
</li>
<li><p>随着我们写完，会自动帮我们打包编译，并且自动进行浏览器刷新的</p>
</li>
</ul>
<h2 id="使用-GULP-配置代理"><a href="#使用-GULP-配置代理" class="headerlink" title="使用 GULP 配置代理"></a>使用 GULP 配置代理</h2><ul>
<li><p>我们的 <code>gulp</code> 自动打包构建已经完成了</p>
</li>
<li><p>我们的正常开发已经可以进行下去了</p>
</li>
<li><p>我们就剩最后一个功能没有实现了</p>
</li>
<li><p>那就是跨域请求的问题</p>
</li>
<li><p>因为我们的项目中肯定有一些数据是向后台请求过来的</p>
</li>
<li><p>那么我们就要发送请求</p>
</li>
<li><p>我们又不能保重 <strong>服务端接口</strong> 和我们是同源的</p>
</li>
<li><p>所以我们就要配置一个代理</p>
</li>
<li><p><code>gulp</code> 给我们启动的这个服务器是 <code>node</code> 的服务器</p>
</li>
<li><p>所以也可以直接配置代理</p>
</li>
<li><p>不需要任何依赖，只要再 <code>webserver</code> 任务中多加一个配置就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'webserver'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./dist'</span>)</span><br><span class="line">        .pipe(webserver(&#123;</span><br><span class="line">            host: <span class="string">'localhost'</span>,</span><br><span class="line">            port: <span class="number">3000</span>,</span><br><span class="line">            livereload: <span class="literal">true</span>,</span><br><span class="line">            open: <span class="string">'./pages/index.html'</span>,</span><br><span class="line">            proxies: [ <span class="comment">// 配置所有代理</span></span><br><span class="line">                &#123; <span class="comment">// 其中一个代理配置</span></span><br><span class="line">                    source: <span class="string">'/login'</span>, <span class="comment">// 使用的关键字 </span></span><br><span class="line">                    target: <span class="string">'http://localhost:80/login.php'</span> <span class="comment">// 代理的路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>这个时候你就可以正常发送请求了</li>
<li>当你要请求代理地址的时候，只要再这里配置一下，使用代理关键字进行请求就可以了</li>
</ul>
</li>
</ul>
<h1 id="GULP完整配置文件（简单版）"><a href="#GULP完整配置文件（简单版）" class="headerlink" title="GULP完整配置文件（简单版）"></a>GULP完整配置文件（简单版）</h1><ul>
<li><p>所有需要用到的依赖</p>
<ol>
<li><a href="mailto:`gulp@3.9.1" target="_blank" rel="noopener">`gulp@3.9.1</a>`</li>
<li><code>gulp-cssmin</code></li>
<li><code>gulp-autoprefixer</code></li>
<li><code>gulp-sass</code></li>
<li><code>gulp-uglify</code></li>
<li><a href="mailto:`gulp-babel@7.0.1" target="_blank" rel="noopener">`gulp-babel@7.0.1</a>`</li>
<li><code>babel-core</code></li>
<li><code>babel-preset-es2015</code></li>
<li><code>gulp-htmlmin</code></li>
<li><code>gulp-clean</code></li>
<li><code>run-sequence</code></li>
<li><code>gulp-webserver</code></li>
</ol>
</li>
<li><p><code>gulpfile.js</code> 文件内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是 gulpfile.js 文件</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"><span class="keyword">const</span> autoPrefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-urlify'</span>)</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>)</span><br><span class="line"><span class="keyword">const</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>)</span><br><span class="line"><span class="keyword">const</span> runSequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>)</span><br><span class="line"><span class="keyword">const</span> webserver = <span class="built_in">require</span>(<span class="string">'gulp-webserver'</span>)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/css/**'</span>)   </span><br><span class="line">    	.pipe(autoPrefixer(&#123;</span><br><span class="line">        	browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(cssmin())       </span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/sass/**'</span>)</span><br><span class="line">    	.pipe(sass())</span><br><span class="line">    	.pipe(autoPrefixer())</span><br><span class="line">    	.pipe(cssmin())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/js/**'</span>)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">        	presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(uglify())</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/pages/**'</span>)</span><br><span class="line">    	.pipe(htmlmin(&#123;</span><br><span class="line">        	removeEmptyAttibutes: <span class="literal">true</span>,</span><br><span class="line">        	collapseWhitespace: <span class="literal">true</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/pages'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'lib'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/lib/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'static'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./src/static/**'</span>)</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'./dist/static'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">    	.src(<span class="string">'./dist'</span>)</span><br><span class="line">    	.pipe(clean())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'webserver'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./dist'</span>)</span><br><span class="line">        .pipe(webserver(&#123;</span><br><span class="line">            host: <span class="string">'localhost'</span>,          </span><br><span class="line">            port: <span class="number">3000</span>,                 </span><br><span class="line">            livereload: <span class="literal">true</span>,           </span><br><span class="line">            open: <span class="string">'./pages/index.html'</span>,</span><br><span class="line">        	proxies: [</span><br><span class="line">                &#123;</span><br><span class="line">                    source: <span class="string">'/login'</span>,</span><br><span class="line">                    target: <span class="string">'http://localhost:80/login.php'</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./src/css/**'</span>, [<span class="string">'css'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/sass/**'</span>, [<span class="string">'sass'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/js/**'</span>, [<span class="string">'js'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/pages/**'</span>, [<span class="string">'html'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/lib/**'</span>, [<span class="string">'lib'</span>])</span><br><span class="line">    gulp.watch(<span class="string">'./src/static/**'</span>, [<span class="string">'static'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  	runSequence(</span><br><span class="line">        <span class="string">'clean'</span>, </span><br><span class="line">        [<span class="string">'css'</span>, <span class="string">'sass'</span>, <span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'lib'</span>, <span class="string">'static'</span>],</span><br><span class="line">    	[<span class="string">'webserver'</span>, <span class="string">'watch'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>HTML5新特性复习整理</title>
    <url>/2018/05/29/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p> h5是html的最新版本，是14年由w3c完成标准制定。增强了浏览器的原生功能，减少浏览器插件（eg：flash）的应用，提高用户体验满意度，让开发更加方便。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">开头的<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"> 字符编码变得简洁，</span><br></pre></td></tr></table></figure><a id="more"></a>

<ol>
<li><p>不区分大小写，</p>
</li>
<li><p>添加了布尔值，类似checked，selected</p>
</li>
<li><p>引号可以省略，但是编码规范来说，不建议</p>
</li>
<li><p>有可以省略结束符的标签，和完全省略的标签应用。</p>
<p>标签增删</p>
<p>(1)结构标签（8个语义化元素） header, footer, section, article,aside ,nav, main,figure （全都是块元素）</p>
<p>其他语义化标签 figcaption, hgroup, dialog,details,summary</p>
<p>(2)其他功能标签，mark ，progress ，command，ruby，（rt，rp），wbr，time</p>
<p>(3)新的表单控件（input的type输入性）：email tel url number search range color</p>
<p>Date Pickers：日期选择器；（time datetime （UTC时间）datetime-local（本地时间） date month week ）</p>
<p><img src="https://img-blog.csdnimg.cn/20200313155857293.png" alt="在这里插入图片描述"> </p>
<p>（4）input新增属性值：placeholder autofocus multiple autocomplete required list height和width min和max等</p>
<p><img src="https://img-blog.csdnimg.cn/20200313161025405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
</li>
</ol>
<p>（5）新的表单元素 detailest，keygen，output</p>
<p>（6）移除过时标签 big font frame frameset</p>
<ul>
<li><p>canvas绘图 支持内联SVG 支持MathML</p>
</li>
<li><p>多媒体元素 audio video source track embed</p>
</li>
<li><p>本地离线储存 把需要离线存储在本地的文件列在一个manifest文件中</p>
</li>
<li><p>web存储 localStorage，SessionStorage**</p>
</li>
<li><p>地理定位</p>
<h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1.语义化标签"></a>1.语义化标签</h3><p>header（双标签）页眉，用于页面头部信息介绍或者板块头部。 |</p>
<p>footer（双标签）：页脚，用于页面底部或者板块底部。</p>
<p>section（双标签）：板块，用于划分页面上的不同区域，或者划分文章里不同节，属于article的部分。</p>
<p>artilce（双标签）：用来在页面中表示一套结构完整并且独立的部分，可以呈现论坛的一个帖子，杂志或报纸中的一篇文章，用户提交的评论内容，可互动的页面模块挂件等。（可以用header/footer/section等做为头部，脚步，部分）</p>
<p>aside（双标签）：用来定义其所处内容之外的内容 侧边，aside的内容应该与article相关。</p>
<p>nav（双标签）：导航，包含链接的一个列表。</p>
<p>figure（双标签） ：和文档有关的图例。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;figcaption&gt; 标签定义 figure 元素的标题（caption）。</span><br><span class="line">      &lt;figure&gt;</span><br><span class="line">       &lt;figcaption&gt;黄浦江上的的卢浦大桥&lt;/figcaption&gt;</span><br><span class="line">      &lt;img src=&quot;shanghai_lupu_bridge.jpg&quot; width=&quot;350&quot; height=&quot;234&quot; /&gt;</span><br><span class="line">     &lt; /figure&gt;</span><br><span class="line">     &quot;figcaption&quot; 元素应该被置于 &quot;figure&quot; 元素的第一个或最后一个子元素的位置。</span><br></pre></td></tr></table></figure>
<p>main（双标签）：规定文章的主要内容。<strong>注意！</strong>在一个文档中不应该出现一个以上的main元素，且main元素不能是一下元素的后代：header，footer,artilce,aside,nav.</p>
<p>hgroup（双标签）：用于对一个页面中一个区块或整个页面的标题进行组合。定义有关文档中的 section 的信息。</p>
<h3 id="2-其他功能标签"><a href="#2-其他功能标签" class="headerlink" title="2.其他功能标签"></a>2.其他功能标签</h3><p>mark ：用来展示文字高亮</p>
<p>progress：用来展示任何类型的任务的进度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;progress max=&quot;最大进度条的值&quot; value=&quot;当前进度条的值&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>command：可以定义命令按钮，比如单选按钮、复选框或按钮。</p>
<p>ruby</p>
<p>ruby ：对某一个字进行注释；</p>
<p>rt: 定义 ruby 注释的解释。(和ruby一起使用)</p>
<p>rp：rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。（和rt ruby一起使用）</p>
<p>ruby实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ruby&gt;</span><br><span class="line">漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;</span><br><span class="line">&lt;/ruby&gt;</span><br></pre></td></tr></table></figure>
<p> <strong>wbr</strong> ：软换行 （wbr元素指浏览器窗口或父级元素宽度够高时，不进行换行，宽度不够时，主动再此换行）</p>
<p><strong>time</strong>：数据标签，给搜索引擎使用；（目前所有主流浏览器不支持标签） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发布日期&lt;time datetime=&quot;2014-12-25T09:00&quot;&gt;9：00&lt;/time&gt;</span><br><span class="line">更新日期&lt;time datetime=&quot;2015- 01-23T04:00&quot; pubdate&gt;4:00&lt;/time&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-表单控件"><a href="#3-表单控件" class="headerlink" title="3.表单控件"></a>3.表单控件</h3><p> <img src="https://img-blog.csdnimg.cn/20200311211457721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20200311211745639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="4-input-属性值"><a href="#4-input-属性值" class="headerlink" title="4.input 属性值"></a>4.input 属性值</h3><p> <img src="https://img-blog.csdnimg.cn/20200311211932255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> 效果图 </p>
<p> <img src="https://img-blog.csdnimg.cn/20200311212142481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="5-新的表单元素"><a href="#5-新的表单元素" class="headerlink" title="5.新的表单元素"></a>5.新的表单元素</h3><p> <strong>datalist</strong> ：下拉菜单 定义选项列表，需要和input搭配使用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;</span><br><span class="line">        &lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;BMW&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;Ford&quot;&gt;</span><br><span class="line">       &lt;option value=&quot;Volvo&quot;&gt;</span><br><span class="line">      &lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<p> keygen：表示生成秘钥 （当提交表单时，私钥存储在本地，公钥发送到服务器。）（单标签） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;</span><br><span class="line">      用户名：&lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt;</span><br><span class="line">       &lt;keygen name=&quot;security&quot; /&gt;</span><br><span class="line">       &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/20200313180543842.png" alt="效果图"> </p>
<ul>
<li><p><strong>output</strong> ：定义不同类型的输出，比如脚本的输出。</p>
<h3 id="6-canvas元素：定义图形，比如图表和其他图像。"><a href="#6-canvas元素：定义图形，比如图表和其他图像。" class="headerlink" title="6.canvas元素：定义图形，比如图表和其他图像。"></a>6.canvas元素：定义图形，比如图表和其他图像。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形。</span><br><span class="line">    利用Canvas API进行绘图，首先要获取canvas元素的上下文，然后用该上下文中封装的各种绘图功能进行绘图。</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot;&gt;替代内容&lt;/canvas&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">  </span><br><span class="line">   var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">  </span><br><span class="line">   var context =canvas.getContext(&quot;2d&quot;); // 获取上下文</span><br><span class="line">  </span><br><span class="line">   //设置纯色</span><br><span class="line">  </span><br><span class="line">  context.fillStyle = &quot;red&quot;;</span><br><span class="line">  </span><br><span class="line">  context.strokeStyle = &quot;blue&quot;;</span><br><span class="line">  </span><br><span class="line"> // 实践表明在不设置fillStyle下的默认fillStyle为black</span><br><span class="line">  </span><br><span class="line">  context.fillRect(0, 0, 100, 100);</span><br><span class="line">  </span><br><span class="line">// 实践表明在不设置strokeStyle下的默认strokeStyle为black</span><br><span class="line">  </span><br><span class="line"> context.strokeRect(120, 0, 100, 100);</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-多媒体元素"><a href="#7-多媒体元素" class="headerlink" title="7.多媒体元素"></a>7.多媒体元素</h3></li>
</ul>
<p>audio： 定义声音或音乐内容 （支持ogg MP3 wav三种声音文件）</p>
<p>video ： 定义视频或影片内容 （支持ogg MP4 webM 三种视频格式）</p>
<p>Audio/Video 方法</p>
<p>source： 定义 audio和video和来源</p>
<p>track：为诸如 video 元素之类的媒介规定外部文本轨道。</p>
<p>用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。（目前所有主流浏览器都不支持 track标签）</p>
<p>embed 定义嵌入的内容，比如插件。（可以插入各种多媒体）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;embed src=&quot;/i/helloworld.swf&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-离线存储"><a href="#8-离线存储" class="headerlink" title="8.离线存储"></a>8.离线存储</h3><p> <a href="https://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="noopener">通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本</a> </p>
<h3 id="9-web存储："><a href="#9-web存储：" class="headerlink" title="9.web存储："></a>9.web存储：</h3><p>WebStorage API 可以在客户端本地存储数据，类似html4中的cookie，实现功能比cookie强</p>
<p>sessionStorage：将数据存储在session中，浏览器关闭时，数据就会消失。</p>
<p>localStorage：将数据储存在客户端本地，除非手动删除，否则一直保存。</p>
<h3 id="10-地理定位"><a href="#10-地理定位" class="headerlink" title="10.地理定位"></a>10.地理定位</h3><p><a href="https://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="noopener">HTML5 Geolocation API 用于获得用户的地理位置</a> </p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>DAY7-4_GIT</title>
    <url>/2021/11/03/DAY7-4-GIT/</url>
    <content><![CDATA[<h1 id="GIT-和-GITHUB"><a href="#GIT-和-GITHUB" class="headerlink" title="GIT 和 GITHUB"></a>GIT 和 GITHUB</h1><ul>
<li>在学习之前我们要先要清楚几个东西</li>
<li><code>git</code> 和 <code>github</code> 是两个东西，不是一个东西</li>
<li>就像 <code>java</code> 和 <code>javascript</code> 一样，是两个东西</li>
<li>需要搞清楚几个词语的意思<ul>
<li>本地：我自己的终端</li>
<li>远程：在网络那一头的终端</li>
<li>仓库：一个被 <code>git</code> 管理了的文件夹</li>
</ul>
</li>
</ul><h2 id="什么是-GIT"><a href="#什么是-GIT" class="headerlink" title="什么是 GIT"></a>什么是 GIT</h2><ul>
<li><code>git</code> 官方名称： <strong>分布式版本管理器</strong></li>
<li>私人解释： 就是一个管理我们文件夹的工具<ul>
<li>只不过可以保留所有的版本信息</li>
</ul>
</li>
<li>就是我们安装一个软件<ul>
<li>然后用这个软件来管理我们的一个文件夹</li>
<li>这个文件夹被 <code>git</code> 管理以后，我们可以对他进行各种操作</li>
<li>保证我们写过的内容不会丢失</li>
</ul>
</li>
</ul><a id="more"></a>

<h2 id="什么是-GITHUB"><a href="#什么是-GITHUB" class="headerlink" title="什么是 GITHUB"></a>什么是 GITHUB</h2><ul>
<li><code>github</code> 是一个网站，是一个我们托管项目的平台</li>
<li>是一个 <strong>世界级别</strong> 的大型网站</li>
<li>也就是说，我们写的项目的 <strong>源码</strong> 可以放在上面保存，只要我们不自己删除，不会丢失<ul>
<li>就相当于百度云</li>
<li>只不过功能更加强大，上面都是开发人员（世界级别）</li>
</ul>
</li>
<li>因为 <code>github</code> 只接受 <code>git</code> 来上传代码，所以叫做 <code>github</code></li>
<li>也就是说，我们可以通过 <code>git</code> 这个软件来管理我们本地的文件夹<ul>
<li>并且可以把文件夹里面的代码上传到 <code>github</code> 保存</li>
<li>也可以写一个插件之类的工具，上传到 <code>github</code> 上面让其他开发者使用</li>
<li>也可以从 <code>github</code> 上找到其他开发者写的插件之类的东西下载使用</li>
</ul>
</li>
<li>所以说，<code>github</code> 也是一个大型的 <strong>开源</strong> 的资源共享平台</li>
</ul>
<h2 id="GIT-使用"><a href="#GIT-使用" class="headerlink" title="GIT 使用"></a>GIT 使用</h2><ul>
<li>刚才我们说过，<code>git</code> 是一个管理我们文件夹的工具</li>
<li>那么我们就要先安装工具，再使用工具管理我们的文件夹</li>
</ul>
<h3 id="GIT-安装"><a href="#GIT-安装" class="headerlink" title="GIT 安装"></a>GIT 安装</h3><ul>
<li><p>下载 <code>git</code> 直接到官网下载就可以</p>
<ul>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a></li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git下载中心</a></li>
</ul>
</li>
<li><p>找到和操作系统对应的版本就可以了</p>
<ol>
<li><p>方法一： 打开官网，直接点击下载</p>
<p><img src="J:/课程资料/week7/assets/官网下载.png" alt></p>
</li>
<li><p>方法二： 打开下载中心，选择操作系统，选择下载版本</p>
<p><img src="J:/课程资料/week7/assets/下载中心1.png" alt></p>
<p><img src="J:/课程资料/week7/assets/下载中心2.png" alt></p>
</li>
</ol>
</li>
<li><p>下载好以后，直接双击进行安装就行</p>
</li>
<li><p>一直下一步就可以，安装再默认路径就行</p>
</li>
<li><p>安装完毕后检测一下安装是否成功</p>
<ol>
<li><p>方法一： 打开 <code>cmd</code> 窗口，输入指令检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 检测 git 是否安装</span><br><span class="line"><span class="meta">$</span> git --version</span><br></pre></td></tr></table></figure>
<ul>
<li><p>出现版本号，说明安装成功</p>
<p><img src="J:/课程资料/week7/assets/git安装检测1.png" alt></p>
</li>
</ul>
</li>
<li><p>方法二： 随便找个地方单机 <strong>鼠标右键</strong>，出现下图内容，说明安装成功</p>
<p><img src="J:/课程资料/week7/assets/git安装检测2.png" alt></p>
</li>
</ol>
</li>
<li><p>安装完毕，接下来我们就可以开始使用了</p>
</li>
</ul>
<h3 id="GIT-使用-1"><a href="#GIT-使用-1" class="headerlink" title="GIT 使用"></a>GIT 使用</h3><ul>
<li><p><code>git</code> 是一个软件没错，但是不是那种安装了会再桌面出现一个图标的软件</p>
</li>
<li><p>而是一个需要在 <strong>命令行</strong> 进行操作的软件</p>
</li>
<li><p>我们单机鼠标右键，点击 <code>Git Bash Here</code></p>
</li>
<li><p>会出现下图内容</p>
<p><img src="J:/课程资料/week7/assets/git窗口1.png" alt></p>
</li>
<li><p>我们发现点开以后，就是一个 <strong>命令行窗口</strong></p>
</li>
<li><p>其实就是给我们写一些指令使用的，只不过色彩鲜艳一点</p>
<ul>
<li>使用 <code>cmd</code> 或者 <code>powershell</code> 窗口来运行 <code>git</code> 指令也可以</li>
<li>只要是再终端运行就行</li>
<li>OS 操作系统直接在 <strong>终端</strong> 中运行就行</li>
</ul>
</li>
<li><p><code>Git Bash Here</code> 表示再当前目录下运行 <code>Git Base</code></p>
</li>
<li><p>所以，你在哪个文件夹下点击的，那么你出来的命令行窗口的目录就是哪里</p>
</li>
<li><p>我们就在命令行里面使用 <code>git</code> 来管理我们的文件夹</p>
</li>
</ul>
<h4 id="GIT-初始化"><a href="#GIT-初始化" class="headerlink" title="GIT 初始化"></a>GIT 初始化</h4><ul>
<li><p>我们希望一个文件夹被 <code>git</code> 管理的话，那么就要在一个文件夹下进行 <strong>git 初始化</strong></p>
</li>
<li><p>找到一个希望被 <code>git</code> 管理的文件夹</p>
</li>
<li><p>在文件夹内单击鼠标右键，点开 <code>Git Bash Here</code></p>
</li>
<li><p>输入指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> git 初始化的指令</span><br><span class="line"><span class="meta">$</span> git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后文件夹内会多一个 <code>.git</code> 的文件夹（这个文件夹是一个隐藏文件夹）</p>
<p><img src="J:/课程资料/week7/assets/git-init.png" alt></p>
</li>
<li><p>这个时候，我的这个 <code>git_demo</code> 文件夹就被 <code>git</code> 管理了</p>
<ul>
<li><code>git</code> 不光管理这一个文件夹，包括所有的子文件夹和子文件都会被管理</li>
</ul>
</li>
<li><p>注意： <strong>只有当一个文件夹被 git 管理以后，我们才可以使用 git 的功能去做版本管理</strong></p>
<ul>
<li>也就是说，我们必须要把我们电脑中的某一个文件夹授权给 <code>git</code></li>
<li><code>git</code> 才能对这个文件夹里面的内容进行各种操作</li>
<li>而 <code>git init</code> 就是在进行这个授权的操作</li>
</ul>
</li>
</ul>
<h4 id="GIT-暂存区"><a href="#GIT-暂存区" class="headerlink" title="GIT 暂存区"></a>GIT 暂存区</h4><ul>
<li><p>当一个文件夹被 <code>git</code> 管理了以后</p>
</li>
<li><p><code>git</code> 就会对当前文件夹进行 <strong>“分区”</strong></p>
</li>
<li><p>会分为三个区域</p>
<ol>
<li>工作区：我们书写的源码就在工作区里面</li>
<li>暂存区：把我们想要存储的内容放在暂存区</li>
<li>历史区：把暂存区里面的内容拿出来形成一个历史版本</li>
</ol>
</li>
<li><p>也就是说，我们需要把想成为一个版本的代码</p>
<ul>
<li>要先放在暂存区</li>
<li>然后才能在暂存区里面放到历史去</li>
<li>才可以生成一个版本保存下来</li>
</ul>
</li>
<li><p>我们要放入暂存区，要使用 <code>git add</code> 指令</p>
</li>
<li><p>把单独一个文件放在暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 把文件夹下的 index.txt 文本放在暂存区</span><br><span class="line"><span class="meta">$</span> git add index.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>把单独一个文件夹放在暂存区（暂存区不能存放空文件夹）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 把文件夹下的 ceshi文件夹 放在暂存区</span><br><span class="line"><span class="meta">$</span> git add ceshi/</span><br></pre></td></tr></table></figure>
</li>
<li><p>把所有文件都放在暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 把文件夹下所有的内容都放在暂存区</span><br><span class="line"><span class="meta">$</span> git add --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> git add --all 有一个简单的写法</span><br><span class="line"><span class="meta">$</span> git add .</span><br></pre></td></tr></table></figure>
<ul>
<li>全部存放的时候使用上面两个指令哪个都行</li>
</ul>
</li>
<li><p>把已经放在暂存区的内容在拉回到工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 拉回暂存区的 index.txt 文件</span><br><span class="line"><span class="meta">$</span> git reset HEAD -- index.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 拉回暂存区的 ceshi 文件夹</span><br><span class="line"><span class="meta">$</span> git reset HEAD -- ceshi/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 拉回暂存区的 所有文件</span><br><span class="line"><span class="meta">$</span> git reset HEAD -- .</span><br></pre></td></tr></table></figure>
<ul>
<li>注意： <strong><code>--</code> 两边都有空格，拉回所有文件的时候有个 <code>.</code></strong></li>
</ul>
</li>
<li><p>暂存区，只是帮我们暂时存放内容，我们删除了还是会丢的</p>
</li>
<li><p>要想帮我们保存下来，那么还需要把暂存区的内容放到历史区</p>
</li>
</ul>
<h4 id="GIT-历史区"><a href="#GIT-历史区" class="headerlink" title="GIT 历史区"></a>GIT 历史区</h4><ul>
<li><p><code>git</code> 的历史区，就是把我们暂存区里面的文件变成一个历史版本</p>
</li>
<li><p>当一些文件形成一个版本的时候，就会被一直记录下来了</p>
</li>
<li><p>向历史区里面添加内容的时候，必须保证 <strong>暂存区</strong> 有内容</p>
</li>
<li><p>因为历史区就是把暂存区里面的内容收录进去</p>
</li>
<li><p>向历史区添加内容使用 <code>git commit -m &quot;做一个简单的说明&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 把暂存区的内容放到历史区</span><br><span class="line"><span class="meta">$</span> git commit -m "我是第一个版本"</span><br></pre></td></tr></table></figure>
<ul>
<li>我们一定要写一个简单的说明</li>
<li>因为当我们的历史版本多了以后，我们自己也记不住哪个版本做了哪些修改</li>
<li>所以有个简单的说明会好很多</li>
</ul>
</li>
<li><p>这个时候历史区就有了我们的第一个版本</p>
</li>
<li><p>我们使用 <code>git log</code> 这个指令查看版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前历史区版本信息</span><br><span class="line"><span class="meta">$</span> git log</span><br></pre></td></tr></table></figure>
<p><img src="J:/课程资料/week7/assets/git版本信息.png" alt></p>
<ul>
<li><code>commit</code>：这一个版本的版本编号</li>
<li><code>Author</code>：作者</li>
<li><code>Date</code>：本次版本的记录时间</li>
<li>后面的内容就是我刚才提交的时候写的说明</li>
</ul>
</li>
<li><p>接下来我们对文件夹内的内容进行一些修改，然后再次创建一个历史版本</p>
</li>
<li><p>对 <code>index.txt</code> 中的文本内容进行修改</p>
<ul>
<li>从 <code>hello world</code> 改变成 <code>你好 世界</code></li>
</ul>
</li>
<li><p>然后我们再次打印日志看一下</p>
<p><img src="J:/课程资料/week7/assets/git版本信息2.png" alt></p>
<ul>
<li>我们发现，日志信息变成了两条，也就是我们存在着两个版本的内容了</li>
</ul>
</li>
<li><p>放在历史区的内容，理论上就丢不了了</p>
</li>
<li><p>现在我们可以把我们本地工作区中的内容给删除了，删除以后我们进行历史回退</p>
</li>
<li><p>我们使用 <code>git reset --hard 版本编号</code> 进行历史回退</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 回退到第一次提交的版本</span><br><span class="line"><span class="meta">$</span> git reset --hard ce0c17f7a703c6847552c7aaab6becea6f0197f2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 回退到第二次提交的版本</span><br><span class="line"><span class="meta">$</span> git reset --hard abb2c4f12566440e04bc166c3285f855a37a3bb2</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候我们就可以来回来去的玩我们的历史记录了</p>
</li>
</ul>
<h4 id="GIT-分支"><a href="#GIT-分支" class="headerlink" title="GIT 分支"></a>GIT 分支</h4><ul>
<li><p><code>git</code> 分支，就是我们自己把我们的整个文件夹分成一个一个独立的区域</p>
</li>
<li><p>比如我在开发 <strong>登录</strong> 功能的时候，可以放在 <code>login</code> 分支下进行开发</p>
<ul>
<li>开发 <strong>列表</strong> 功能的时候，可以放在 <code>list</code> 分支下进行开发</li>
<li>大家互不干扰，每一个功能都是一个独立的功能分支</li>
</ul>
</li>
<li><p>这样开发就会好很多</p>
</li>
<li><p><code>git</code> 在初始化的时候，会自动生成一个分支，叫做 <code>master</code> </p>
</li>
<li><p>是表示主要分支的意思</p>
</li>
<li><p>我们就可以自己开辟出很多独立分支</p>
</li>
<li><p>开辟一个分支使用 <code>git branch 分支名称</code> 指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 开辟一个 login 分支</span><br><span class="line"><span class="meta">$</span> git branch login</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看一下当前分支情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前分支情况</span><br><span class="line"><span class="meta">$</span> git branch</span><br></pre></td></tr></table></figure>
<p><img src="J:/课程资料/week7/assets/查看分支情况.png" alt></p>
<ul>
<li>会看到，当前有两个分支了</li>
<li>一个是 <code>master</code>，一个是 <code>login</code></li>
<li>前面有个 <code>*</code> 号，并且有高亮显示的，表示你当前所处的分支</li>
</ul>
</li>
<li><p>我们对 <strong>登录</strong> 功能的开发要移动到 <code>login</code> 分支去完成</p>
</li>
<li><p>我们切换所处分支使用 <code>git checkout 分支名称</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 切换到 login 分支</span><br><span class="line"><span class="meta">$</span> git checkout login</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们在整个分支上进行 <strong>登录</strong> 功能的开发</p>
</li>
<li><p>开发完毕以后，我们就在当前分支上进行提交</p>
</li>
<li><p>提交以后我们进行分支切换</p>
<ul>
<li>发现 <code>master</code> 上面还是最初始的状态</li>
<li>而 <code>login</code> 分支上有我们新写的 <strong>登录</strong> 功能的代码</li>
</ul>
</li>
<li><p>我们按照分支把所有功能都开发完毕了以后</p>
<ul>
<li>只要把所有代码都合并到 <code>master</code> 主分支上就行了</li>
</ul>
</li>
<li><p><code>git</code> 的合并分支，只能是把别的分支的内容合并到自己的分支上</p>
</li>
<li><p>使用的指令是 <code>git merge</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 切换到 master 分支</span><br><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 把 login 的内容合并到自己的分支</span><br><span class="line"><span class="meta">$</span> git merge login</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候，我们刚才在 <code>login</code> 上开发的东西就都来到了 <code>master</code> 主分支上</p>
</li>
<li><p>如果是有多个分支的话，那么所有的最后都合并到 <code>master</code> 分支上的时候</p>
</li>
<li><p>我们的主分支上就有完整网站的所有页面</p>
<ul>
<li>各个分支上都是单独的页面和功能</li>
</ul>
</li>
<li><p>这个时候我们开辟的分支就没有什么用了，就可以删除分支了</p>
<ol>
<li><p>先切换到别的分支</p>
</li>
<li><p>使用指令 <code>git branch -d 分支名称</code> 来删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 先切换到别的分支</span><br><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除 login 分支</span><br><span class="line"><span class="meta">$</span> git branch -d login</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h5 id="常用的分支命名"><a href="#常用的分支命名" class="headerlink" title="常用的分支命名"></a>常用的分支命名</h5><ul>
<li>我们的分支命名也要规范一些</li>
<li>我们有一些分支名称大家都默认是有特殊意义的</li>
<li>比如我们之前的写的 <code>login</code> 分支就是不规范的分支名称<ul>
<li>而且也是不规范的分支操作</li>
</ul>
</li>
<li>常见的分支名称<ol>
<li>master：主分支，永远只存储一个可以稳定运行的版本，不能再这个分支上直接开发</li>
<li>develop： 主要开发分支，主要用于所用功能开发的代码合并，记录一个个的完整版本<ul>
<li>包含测试版本和稳定版本</li>
<li>不要再这个分支上进行开发</li>
</ul>
</li>
<li>feature-xxx：功能开发分支，从 <code>develop</code> 创建的分支<ul>
<li>主要用作某一个功能的开发</li>
<li>以自己功能来命名就行，例如 <code>feature-login</code> / <code>feature-list</code></li>
<li>开发完毕后合并到 <code>develop</code> 分支上</li>
</ul>
</li>
<li>feature-xxx-fix:  某一分支出现 <code>bug</code> 以后，在当前分支下开启一个 <code>fix</code> 分支<ul>
<li>解决完 <code>bug</code> 以后，合并到当前功能分支上</li>
<li>如果是功能分支已经合并之后发现 <code>bug</code> 可以直接在 <code>develop</code> 上开启分支</li>
<li>修复完成之后合并到 <code>develop</code> 分支上</li>
</ul>
</li>
<li>hotfix-xxx： 用于紧急 <code>bug</code> 修复<ul>
<li>直接在 <code>master</code> 分支上开启</li>
<li>修复完成之后合并回 <code>master</code> </li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="GIT-推送"><a href="#GIT-推送" class="headerlink" title="GIT 推送"></a>GIT 推送</h4><ul>
<li>我们的所有内容已经全部保留在了本地历史区</li>
<li>理论上是不会丢失了<ul>
<li>但是如果把文件夹删除了，还是没有了</li>
</ul>
</li>
<li>所以我们要使用 <code>git</code> 把我们所有的内容推送到 <code>github</code> 上面保存起来</li>
<li>那么就本地文件夹就算删除了，那么远程上面还有一份，还可以拿回来使用</li>
<li>所以我们现在就要把本地内容推送到远程</li>
<li>这个时候我们接需要一个 <code>github</code> 的账号了</li>
<li>先去 <a href="https://github.com/" target="_blank" rel="noopener">github官网</a> 注册一个账号</li>
</ul>
<h5 id="开辟一个远程仓库"><a href="#开辟一个远程仓库" class="headerlink" title="开辟一个远程仓库"></a>开辟一个远程仓库</h5><ul>
<li><p>有了 <code>github</code>  账号以后</p>
</li>
<li><p>我们就登录 <code>github</code> 网站，开辟一个远程仓库</p>
</li>
<li><p><code>github</code> 的远程也是以一个仓库一个仓库的形式来保存代码</p>
<ul>
<li>我们可以在一个 <code>github</code> 上保存很多的项目</li>
<li>只要一个项目一个仓库就可以了</li>
</ul>
</li>
<li><p>按照下面步骤开辟仓库</p>
<ol>
<li><p>先点击新建仓库</p>
<p><img src="J:/课程资料/week7/assets/github开辟仓库1.png" alt></p>
</li>
<li><p>按照要求填写内容</p>
<p><img src="J:/课程资料/week7/assets/github开辟仓库2.png" alt></p>
</li>
<li><p>出现下图表示创建仓库成功</p>
<p><img src="J:/课程资料/week7/assets/github开辟仓库3.png" alt></p>
</li>
</ol>
</li>
<li><p>现在我们的远程仓库建立完毕了，我们就要把我们的项目代码整个上传了</p>
</li>
</ul>
<h5 id="添加仓库地址"><a href="#添加仓库地址" class="headerlink" title="添加仓库地址"></a>添加仓库地址</h5><ul>
<li><p>接下来，要使用 <code>git</code> 上传代码了</p>
</li>
<li><p>我们先要告诉 <code>git</code> 上传到哪里</p>
</li>
<li><p>也就是给 <code>git</code> 添加一个上传的地址</p>
</li>
<li><p>我们还是来到我们的项目文件夹</p>
</li>
<li><p>使用 <code>git remote add origin 仓库地址</code> 来添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 在项目文件夹下打开 git base</span><br><span class="line"><span class="meta">#</span> 添加仓库地址</span><br><span class="line"><span class="meta">$</span> git remote add origin https://github.com/guoxiang910223/ceshi1913.git</span><br></pre></td></tr></table></figure>
<ul>
<li>remote：远程的意思</li>
<li>add：添加的意思</li>
<li>origin：是一个变量名（就是指代后面一长串的地址）</li>
</ul>
</li>
</ul>
<h5 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h5><ul>
<li><p>上传到哪里的地址我们已经添加好了</p>
</li>
<li><p>接下来就是上传内容了</p>
<ul>
<li>上传要保证 <strong>历史区</strong> 里面有内容</li>
<li>上传的过程会把 <strong>历史区</strong> 里面所有的内容上传到远端</li>
</ul>
</li>
<li><p>我们使用 <code>git push</code> 指令来上传</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 上传内容</span><br><span class="line"><span class="meta">$</span> git push -u origin master</span><br><span class="line"><span class="meta">#</span> 表示把内容上传到 origin 这个地址</span><br><span class="line"><span class="meta">#</span> master 是上传到远程的 master 分支</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code> 是我们第一次的使用用到了，是为了记录一下用户名和密码</li>
<li>下次上传的时候就不需要再写了</li>
</ul>
</li>
<li><p>第二次上传</p>
<ul>
<li><p>第二次上传的时候，因为有刚才的记录，就不需要再写 <code>origin</code> 和 <code>master</code> 了</p>
</li>
<li><p>会默认传递到 <code>origin</code> 这个地址的 <code>master</code> 分支上</p>
</li>
<li><p>除非你要传递到别的分支上的时候再进行书写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 第二次上传</span><br><span class="line"><span class="meta">$</span> git push</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>到这里，就完成了一次 <code>git</code> 推送</p>
</li>
<li><p>这个时候本地的文件夹就真的可以删除了</p>
</li>
<li><p>因为远程有一份我们的内容，本地的删除了，可以直接把远程的拉回来就行</p>
</li>
</ul>
<h3 id="GIT-克隆"><a href="#GIT-克隆" class="headerlink" title="GIT 克隆"></a>GIT 克隆</h3><ul>
<li><p><code>git</code> 克隆是指把远程仓库里面的内容克隆一份到本地</p>
</li>
<li><p>可以克隆别人的 <strong>公开</strong> 的仓库，也可以克隆自己的仓库</p>
</li>
<li><p>克隆别人的仓库，我们只能拿下来用，修改后不能从新上传</p>
</li>
<li><p>克隆自己的仓库，我们修改后还可以再次上传更新</p>
</li>
<li><p>我们先找到一个别人的仓库，或者自己的仓库（这里以 jQuery 的仓库为例）</p>
<p><img src="J:/课程资料/week7/assets/github克隆仓库1.png" alt></p>
</li>
<li><p>复制好地址以后，选择一个我们要存放内容的文件夹（我这里以桌面为例）</p>
</li>
<li><p>直接在想存放内容的位置打开 <code>git base</code></p>
</li>
<li><p>输入克隆指令 <code>git clone 仓库地址</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 直接克隆仓库</span><br><span class="line"><span class="meta">$</span> git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待一段时间</p>
</li>
<li><p>你就会发现你的文件夹里面多了一个叫做  <code>jquery</code> 的文件夹</p>
</li>
<li><p>里面就是人家仓库的所有内容</p>
</li>
</ul>
<h3 id="GIT-下拉"><a href="#GIT-下拉" class="headerlink" title="GIT 下拉"></a>GIT 下拉</h3><ul>
<li><p>不管是你克隆下来的仓库还是别的方式弄得本地仓库</p>
</li>
<li><p>当人家的代码更新以后，你想获得最新的代码</p>
</li>
<li><p>我们不需要从新克隆</p>
</li>
<li><p>只要拉取一次代码就可以了</p>
</li>
<li><p>直接在项目文件夹里面使用指令下拉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 拉取远程最新代码</span><br><span class="line"><span class="meta">$</span> git pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样一来，你本地的仓库就可远程的仓库同步了</p>
</li>
</ul>
<h2 id="GIT-冲突"><a href="#GIT-冲突" class="headerlink" title="GIT 冲突"></a>GIT 冲突</h2><ul>
<li><p><code>git</code> 冲突是指在我们的上传过程中</p>
</li>
<li><p>本地的版本和远程的版本不一致导致的</p>
</li>
<li><p>这个时候只要先使用 <code>git pull</code> 拉取回来</p>
<ul>
<li>让本地和远程保持一致</li>
</ul>
</li>
<li><p>然后再从新上传就好了</p>
</li>
<li><p>但是 <code>git pull</code> 相对不安全，因为会自动和本地内容合并</p>
</li>
<li><p>我们也可以选择使用 <code>git fetch</code> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 使用 fetch 获取远程最新信息并开辟一个临时分支</span><br><span class="line"><span class="meta">$</span> git fetch origin master:tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 讲当前分支和临时分支的内容进行对比</span><br><span class="line"><span class="meta">$</span> git diff tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 再选择合并分支内容</span><br><span class="line"><span class="meta">$</span> git merge tmp</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
  <entry>
    <title>HTML相关的面试题</title>
    <url>/2018/05/30/HTML%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="html相关-面试问题"><a href="#html相关-面试问题" class="headerlink" title="html相关 面试问题"></a>html相关 面试问题</h1><h4 id="1-h5新标签有哪些？为什么要加强语义化？"><a href="#1-h5新标签有哪些？为什么要加强语义化？" class="headerlink" title="1. h5新标签有哪些？为什么要加强语义化？"></a>1. h5新标签有哪些？为什么要加强语义化？</h4><p>新标签：</p><p><strong>文档类型设定</strong>：<code>!doctype html</code>；</p><p><strong>字符设定</strong>：<code>meta charset=&quot;utf-8&quot;</code>；</p><p><strong>常用新标签</strong>：</p><p> <code>header</code>，一般作为网页的<strong>头部</strong>使用，可以多个；</p><p> <code>footer</code>，底部，<strong>不一定是文档最底部</strong>，可以多个；</p><a id="more"></a>





<p> <code>aside</code>，<strong>侧边</strong>栏；</p>
<p> <code>nav</code>，<strong>导航</strong>栏；</p>
<p> <code>article</code>，独立内容区域，与session类似，<strong>用于文章blog、帖子、短文或者回复、评论</strong>等；</p>
<p> <code>section</code>，代表某一个区域/分区/页面/文档的<strong>一部分区域</strong>，有独立的内容，但结构相近，就可以用section，范围比div大，语义比div更强，可以包含header、<code>h1-h6</code>……凸显语义的标签；</p>
<p> <code>datalist</code>，<strong>标签定义选项列表</strong>，请与 input 元素配合使用该元素；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;输入&quot; list=&quot;TFboys&quot;/&gt; &lt;!--  input里面用list --&gt;</span><br><span class="line">&lt;datalist id=&quot;TFboys&quot;&gt;   &lt;!-- datalist里面用id --&gt;  </span><br><span class="line">        &lt;option&gt;易烊千玺&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;王俊凯&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;王源&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<p> <code>fieldset</code>，可<strong>将表单内的相关元素分组</strong>，打包legend（为<code>fieldset</code>元素定义标题）使用； </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;fieldset&gt;</span><br><span class="line">	&lt;legend&gt;用户登录&lt;/legend&gt;</span><br><span class="line">    	用户名: &lt;input type=&quot;text&quot;&gt;&lt;br /&gt;</span><br><span class="line">		密　码: &lt;input type=&quot;password&quot;&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br></pre></td></tr></table></figure>
<p> <code>address</code>，<strong>标签定义文档或文章的作者/拥有者的联系信息</strong>，字体样式默认倾斜； <code>time</code>，时间标签，主要用于搜索引擎和其它一些内容引擎特殊的解析和展示； <code>hgroup</code>，专门用来包含标题<strong>h标签的分组</strong>；</p>
<p> <code>detail</code>，<em>细节、详情</em> ，open属性：默认展开，summary相当于详情的标题；</p>
<p> <strong>新增了许多input type属性</strong>：<code>email</code>、<code>tel</code>、<code>url</code>、<code>number</code>、<code>search搜索框，加强语义</code>、<code>range自由拖动滑块</code>、<code>time</code>、<code>date日期</code>、<code>datetime时间</code>、<code>month</code>、<code>week</code></p>
<p> <strong>新增了许多input的属性</strong>：<code>placeholder占位符，默认文字</code>、<code>autofocus页面加载时自动获得焦点</code>、<code>multiple多文件上传</code>、<code>autocomplete</code>、<code>required必填项</code>、<code>accesskey规定激活元素的快捷键</code></p>
<p> <strong>多媒体标签</strong>：<code>embed定义嵌入的内容</code>、<code>audio播放音频</code>、<code>video播放视频</code>；</p>
<p> <code>src导入</code>，<code>autoplay自动播放</code>、<code>controls是否默认显示播放件</code>、<code>loop循环播放</code></p>
<p> ……</p>
<p> 原因：1.默认样式不一样 ；2.有SEO优化作用；</p>
<h4 id="2-行内元素、块元素有哪些？它们有什么不同？"><a href="#2-行内元素、块元素有哪些？它们有什么不同？" class="headerlink" title="2.行内元素、块元素有哪些？它们有什么不同？"></a>2.行内元素、块元素有哪些？它们有什么不同？</h4><p>行内元素：b、span、a、u、em、i、img、input、select、label、textarea、button</p>
<p>块级元素：div、h、ol、ul、dl、li、table、td、th、tr、dd、dt、p、caption</p>
<p>空元素：area、meta、link</p>
<ul>
<li><p>行内元素的特点：</p>
<p>1、行内元素<strong>只能容纳文本或者其他行内元素</strong>。</p>
<p>2、<strong>宽度只与内容有关</strong>。</p>
<p>3、和其他元素都<strong>在一行上</strong>。</p>
<p>4、高，行高及外边距和内边距<strong>左右可改变</strong>。</p>
</li>
<li><p>块级元素的特点：</p>
<p>1、高度，行高以及外边距和内边距<strong>都可控制</strong>。</p>
<p>2、总是在新行上开始，<strong>占据一整行</strong>。</p>
<p>3、它可以<strong>容纳内联元素和其他块元素</strong>。</p>
<p>4、<strong>宽度</strong>始终是与浏览器宽度一样，<strong>与内容无关</strong>。</p>
</li>
<li><p>区别：</p>
<p>1、<strong>行内元素</strong>会在<strong>一条直线上分列</strong>，都是统一行的，程度偏向分列。</p>
<p> <strong>块级元素各盘踞一行</strong>，垂直偏向分列；块级元素重新行开端停止接着一个断行。</p>
<p>2、<strong>行内元素</strong>不可以包括块级元素，只能包容文本或许其余行内元素。</p>
<p> <strong>块级元素</strong>能够包括行内元素和块级元素，还能够包容内联元素和其余元素；。</p>
<p>3、行内元素与块级元素属性的分歧，主要在盒模子属性上。</p>
<p><strong>行内元素</strong>设置width无效，height无效（<strong>能够设置line-height</strong>），margin、padding设置上下有效。</p>
</li>
<li><p>行内元素内嵌块级元素。高度被子元素撑大，而<strong>宽度和父级一致</strong>（父级是body就是body的宽度）。</p>
</li>
<li><p><strong>行内块元素</strong>内嵌块级元素。宽高都会<strong>被子元素撑大</strong>的。</p>
</li>
</ul>
<h4 id="3-html中首行-lt-doctype-gt-的作用？"><a href="#3-html中首行-lt-doctype-gt-的作用？" class="headerlink" title="3.html中首行&lt;!doctype&gt;的作用？"></a>3.html中首行&lt;!doctype&gt;的作用？</h4><p> <strong>文档类型声明</strong>，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档；声明必须是HTML文档的第一行，位于html标签之前；</p>
<h4 id="4-rem相对于根节点。em相对于父元素"><a href="#4-rem相对于根节点。em相对于父元素" class="headerlink" title="4.rem相对于根节点。em相对于父元素"></a>4.rem相对于根节点。em相对于父元素</h4><h4 id="5-一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行"><a href="#5-一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行" class="headerlink" title="5.一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行"></a>5.一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行</h4><h5 id="Dom文档加载的步骤："><a href="#Dom文档加载的步骤：" class="headerlink" title="Dom文档加载的步骤："></a>Dom文档加载的步骤：</h5><ol>
<li>解析html结构；</li>
<li><strong>加载外部</strong>脚本和样式表文件；</li>
<li>解析并执行脚本；</li>
<li>dom树构建完成（DOMContentLoaded）；</li>
<li>加载图片等外部文件；</li>
<li>页面加载完毕。</li>
</ol>
<p>DOM ready：（也叫DOMContentLoaded ），在第4步完成后触发； 图片onload：是在第5步完成后触发； 页面onload：是第6步完成后触发。</p>
<p>由此可见三者执行顺序为：<strong>domready→图片load→页面load。</strong></p>
<p>执行时间上，<strong>onready比onload先执行</strong>：</p>
<p> <strong>window.onload</strong>必须等到页面内包括图片的<strong>所有元素加载完毕后才能执行</strong>。</p>
<p> <strong>$(document).ready()</strong>是<strong>DOM结构绘制完毕后就执行</strong>，不必等到加载完毕。</p>
<p><strong>onload只执行最后一个</strong>而<strong>onready可以执行多个</strong>：</p>
<p>编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行最后一个。 <strong>$(document).ready()可以同时编写多个，并且都可以按顺序得到执行</strong>。</p>
<p>注：$(document).ready(function(){})可以简写成$(function(){});</p>
<h4 id="6-html是怎么渲染的"><a href="#6-html是怎么渲染的" class="headerlink" title="6.html是怎么渲染的"></a>6.html是怎么渲染的</h4><p>1.解析html文件，创建DOM树 自上而下解析，遇到任何样式（link、style）和脚本（script）都会阻塞 　　1）css加载不会阻塞html文件的解析，但会阻塞dom的渲染 　　2）css加载会阻塞后面js语句的执行 　　3）js会阻塞html的解析和渲染 　　4）没有defer和async标签的script会立即加载并执行 　　5）有async标签的js，js的加载执行和html的解析和渲染并行 　　6）有defer标签的js，js的加载和html的解析和渲染并行，但会在html解析完成后执行,在触 发DOMContentLoaded事件前执行 　　7）DOMContentLoaded和onload的区别：DOMContentLoaded在html解析完毕后执行，loload在页面完全加载完成后执行（包括样式和图片） 2.解析css，生成CSSOM，css对象模型 3.dom和css合并，构建渲染树（Render Tree） 4.布局（Layout）和绘制（Paint），重绘（repaint）和重排（reflow/回流） 1）重绘：根据元素的新属性重新绘制，使元素呈现新的外观 　　2）重排：当渲染树中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建 　　3）重排必定会引发重绘，但重绘不一定会引发重排</p>
<h4 id="7-滚动条"><a href="#7-滚动条" class="headerlink" title="7.滚动条"></a>7.滚动条</h4><p>只要网页内容大于视窗，滚动条就会出现。</p>
<p>目标：没有滚动条影响美观，但仍旧可以滚动</p>
<p><strong>方法1</strong>：在webkit内核的浏览器里可以定义滚动条样式，在CSS初始处定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--Chrome--</span><br><span class="line">body::-webkit-scrollbar&#123;</span><br><span class="line">	display:none;</span><br><span class="line">&#125;</span><br><span class="line">--IE/Edge--</span><br><span class="line">body&#123;</span><br><span class="line">    -ms-overflow-style: none;</span><br><span class="line">&#125;</span><br><span class="line">--Firefox--</span><br><span class="line">html &#123;</span><br><span class="line">    overflow: -moz-hidden-unscrollable; /*注意！若只打 hidden，chrome 的其它 hidden 会出问题*/</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">	height: 100%;</span><br><span class="line">	width: calc(100vw + 18px); /*浏览器滚动条的长度大约是 18px*/</span><br><span class="line">	overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2：在div外面再套一个div，内层是有滚动条的，但是我们看不到了</p>
<p>外面的div设置overflow:hidden；</p>
<p>里面的div设置 overflow-y: scroll;overflow-x: hidden;</p>
<p>再设置外层div的width小于内层div的width。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner&quot;&gt;     </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer&#123;</span><br><span class="line">	overflow:hidden;</span><br><span class="line">    width:200px;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    overflow-y:scroll;</span><br><span class="line">    overflow-x:hidden;</span><br><span class="line">    width:220px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-router</title>
    <url>/2018/08/15/Vue-router/</url>
    <content><![CDATA[<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p>
</li>
<li><p>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>
</li>
<li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>
</li>
</ol><a id="more"></a>
<h3 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h3><p>导入 vue-router 组件类库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span><br><span class="line">  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用 router-link 组件来导航</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>使用 router-view 组件来显示匹配到的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>创建使用<code>Vue.extend</code>创建组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 4.1 使用 Vue.extend 来创建登录组件</span><br><span class="line">   var login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 4.2 使用 Vue.extend 来创建注册组件</span><br><span class="line">   var register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span><br><span class="line">    var router = new VueRouter(&#123;</span><br><span class="line">      routes: [</span><br><span class="line">        &#123; path: &apos;/login&apos;, component: login &#125;,</span><br><span class="line">        &#123; path: &apos;/register&apos;, component: register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>使用 router 属性来使用路由规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 6. 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      router: router // 使用 router 属性来使用路由规则</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h3><p>在规则中定义参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; path: &apos;/register/:id&apos;, component: register &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>this.$route.params</code>来获取路由中的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var register = Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   // 父路由中的组件</span><br><span class="line">   const account = Vue.extend(&#123;</span><br><span class="line">     template: `&lt;div&gt;</span><br><span class="line">       这是account组件</span><br><span class="line">       &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | </span><br><span class="line">       &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;</span><br><span class="line">       &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">     &lt;/div&gt;`</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 login 组件</span><br><span class="line">   const login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;登录组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 register 组件</span><br><span class="line">   const register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 路由实例</span><br><span class="line">   var router = new VueRouter(&#123;</span><br><span class="line">     routes: [</span><br><span class="line">       &#123; path: &apos;/&apos;, redirect: &apos;/account/login&apos; &#125;, // 使用 redirect 实现路由重定向</span><br><span class="line">       &#123;</span><br><span class="line">         path: &apos;/account&apos;,</span><br><span class="line">         component: account,</span><br><span class="line">         children: [ // 通过 children 数组属性，来实现路由的嵌套</span><br><span class="line">           &#123; path: &apos;login&apos;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符</span><br><span class="line">           &#123; path: &apos;register&apos;, component: register &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">   var vm = new Vue(&#123;</span><br><span class="line">     el: &apos;#app&apos;,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     methods: &#123;&#125;,</span><br><span class="line">     components: &#123;</span><br><span class="line">       account</span><br><span class="line">     &#125;,</span><br><span class="line">     router: router</span><br><span class="line">   &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-resource插件</title>
    <url>/2018/07/27/Vue-resource%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p> <strong>下载地址：</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/pagekit/vue-resource/blob/develop/docs/http.md</span><br></pre></td></tr></table></figure><p>$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。</p><a id="more"></a>


<p>vue-resource的特点：</p>
<ol>
<li>体积小</li>
</ol>
<p>vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。</p>
<ol start="2">
<li>支持主流的浏览器</li>
</ol>
<p>和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。</p>
<ol start="3">
<li>支持Promise API和URI Templates</li>
</ol>
<p>Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。<br>URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。</p>
<ol start="4">
<li>支持拦截器</li>
</ol>
<p>拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。<br>拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。</p>
<h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        userList:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getdata:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//请求的url</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="string">'https://www.layui.com/demo/table/user/'</span>;</span><br><span class="line">            <span class="comment">//利用vue-resource发出Ajax请求</span></span><br><span class="line">            <span class="keyword">this</span>.$http.get(url)<span class="comment">//发出请求</span></span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;<span class="comment">//获取服务器返回的数据</span></span><br><span class="line">                <span class="keyword">this</span>.userList = response.body;<span class="comment">//获取当前url响应回来的数据</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        postdata:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//请求的url</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="string">'https://www.layui.com/demo/table/user/'</span>;</span><br><span class="line">            <span class="comment">//利用vue-resource发出Ajax请求</span></span><br><span class="line">            <span class="comment">//post有三个参数:post(url,传入服务器的请求报文体数据,&#123;emulateJson:true&#125;)</span></span><br><span class="line">            <span class="keyword">this</span>.$http.post(url,&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;,&#123;<span class="attr">emulateJson</span>:<span class="literal">true</span>&#125;)<span class="comment">//发出post请求</span></span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;<span class="comment">//获取服务器返回的数据</span></span><br><span class="line">                <span class="built_in">console</span>.log(response.body);<span class="comment">//获取当前url响应回来的数据</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-router导航守卫</title>
    <url>/2018/08/29/Vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><p> 其实，导航守卫就是路由跳转过程中的一些钩子函数，再直白点路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。 </p><a id="more"></a>

<p> <strong>导航守卫分为</strong>：全局的、单个路由独享的、组件内的三种。分别来看一下： </p>
<p><strong>【全局的】</strong>：是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数，如下的写法。钩子函数按执行顺序包括<code>beforeEach</code>、<code>beforeResolve</code>（2.5+）、<code>afterEach</code>三个（以下的钩子函数都是按执行顺序讲解的）： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> <strong>全局守卫</strong></p>
<p>[<code>beforeEach</code>]：在路由跳转前触发，参数包括<code>to</code>,<code>from</code>,<code>next</code>（参数会单独介绍）三个，这个钩子作用主要是用于登录验证，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚。 </p>
<p> [<code>beforeResolve</code>]（2.5+）：这个钩子和<code>beforeEach</code>类似，也是路由跳转前触发，参数也是<code>to</code>,<code>from</code>,<code>next</code>三个，和<code>beforeEach</code>区别官方解释为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</span><br></pre></td></tr></table></figure>
<p> 即在 <code>beforeEach</code> 和 组件内<code>beforeRouteEnter</code> 之后，<code>afterEach</code>之前调用。 </p>
<p> [<code>afterEach</code>]：和<code>beforeEach</code>相反，他是在路由跳转完成后触发，参数包括<code>to</code>,<code>from</code>没有了<code>next</code>（参数会单独介绍）,他发生在<code>beforeEach</code>和<code>beforeResolve</code>之后，<code>beforeRouteEnter</code>（组件内守卫，后讲）之前。 </p>
<p><strong>路由守卫</strong></p>
<p><code>beforeEnter</code></p>
<p><strong>组件守卫</strong></p>
<p><code>beforeRouteEnter</code></p>
<p>  // 在渲染该组件的对应路由被 confirm 前调用</p>
<p>  // 不！能！获取组件实例 <code>this</code></p>
<p>  // 因为当守卫执行前，组件实例还没被创建</p>
<p>  虽然无法直接获取组件实力</p>
<p>  但是我们可以通过next参数的回调函数获取到当前实例进行操作</p>
<p>  beforeRouteEnter: (to, from, next) =&gt; {</p>
<pre><code>next((vm) =&gt; {

  //vm就是当前组件实例

});
</code></pre><p>  }</p>
<p><code>beforeRouteUpdate</code></p>
<p>  // 在当前路由改变，但是该组件被复用时调用</p>
<p>  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</p>
<p>  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</p>
<p>  // 可以访问组件实例 <code>this</code></p>
<p><code>beforeRouteLeave</code></p>
<p>  // 导航离开该组件的对应路由时调用</p>
<p>  // 可以访问组件实例 <code>this</code></p>
<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Froute-object.html" target="_blank" rel="noopener">路由对象</a></li>
<li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li>
<li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> （确认的）。</li>
<li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-link.html" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。</li>
<li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.onError()</code></a> 注册过的回调。</li>
</ul>
</li>
</ul>
<p><strong>确保要调用 <code>next</code> 方法，否则钩子就不会被 resolved。</strong></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue中computed与watch的区别</title>
    <url>/2018/08/16/Vue%E4%B8%ADcomputed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="computed计算属性与watch的区别"><a href="#computed计算属性与watch的区别" class="headerlink" title="computed计算属性与watch的区别"></a><code>computed</code>计算属性与<code>watch</code>的区别</h3><p><code>computed</code>和<code>watch</code>都是观察页面的数据变化的。 </p><p><code>computed</code>只有当页面数据变化时才会计算，当数据没有变化时，它会读取缓存。而<code>watch</code>每次都需要执行函数，<code>methods</code>也是每次都需要执行</p><p><code>computed</code>属性的结果会被缓存，除非以来的响应式属性变化才会重新计算，主要当做属性来使用；</p><a id="more"></a>


<p><code>methods</code>方法表示一个具体的操作，主要来写业务逻辑；</p>
<p><code>watch</code>一个对象，键是需要监听的表达式，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看做是<code>computed</code>和<code>methods</code>的结合体。</p>
<p>如果一个数据依赖于其他数据，那么把这个数据设计为<code>computed</code>的</p>
<p>如果你需要在某个数据变化时做一些事情，使用<code>watch</code>来观察这个数据变化</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2018/09/05/Vuex/</url>
    <content><![CDATA[<h1 id="vuex的基本介绍"><a href="#vuex的基本介绍" class="headerlink" title="vuex的基本介绍"></a><code>vuex</code>的基本介绍</h1><p><code>Vuex</code>是一个专门为<code>Vue.js</code>应用程序开发的状态管理模式。它采用集中式的存储管理应用所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变。 </p><p><code>vuex</code>是<code>vue</code>的状态管理工具，状态即数据， 状态管理就是管理<code>vue</code>中的数据。 </p><h4 id="vuex的优点"><a href="#vuex的优点" class="headerlink" title="vuex的优点"></a><code>vuex</code>的优点</h4><ul>
<li>可以用来解决组件通讯的问题</li>
<li><code>vuex</code>可以用来集中的管理<code>vue</code>项目中用到的所有数据（这并不意味着要将所有的数据都交给<code>vuex</code>进行管理）</li>
</ul><a id="more"></a>


<h4 id="为什么要使用vuex"><a href="#为什么要使用vuex" class="headerlink" title="为什么要使用vuex"></a>为什么要使用<code>vuex</code></h4><ul>
<li>在大型的项目中，组件通讯会变得很混乱，使用<code>vuex</code>可以统一的管理组件之间的通讯。并且可以通过开发者工具，追踪到变化。</li>
<li>当你要开发一个大型的<code>SPA</code>应用的时候，会出现：多个视图公用一个状态、不同视图的行为要改变同一个状态的情况，遇到这种情况的时候就需要考虑使用<code>Vuex</code>了，它会把组件的共享状态抽取出来，当做一个全局单例模式进行管理，这样不管你何时何地改变状态，都会通知到使用该状态的组件做出相应的修改；</li>
</ul>
<p><code>vuex</code>其实就是用一个全局的变量保存了<code>Vue</code>项目中的所有的公共数据，类似与在前端这块放了一个数据库，大家都可以在这里存数据，删数据，改数据，读数据，是不是有点熟悉：增，删，改，查；不过这个全局的变量给他定义了一个固定的名字就叫：<code>store</code>（仓库），是不是很形象，而这个仓库里面装数据的袋子就是<code>state</code>，加工数据的机器就叫做：<code>mutations</code>，操作机器的工人就叫做：<code>actions</code>，把数据装起来取走的卡车就叫做：<code>getters</code>;<br> 所以一个简单的<code>vuex</code>就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new vuex.store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Vuex-特点"><a href="#Vuex-特点" class="headerlink" title="Vuex 特点"></a><code>Vuex</code> 特点</h3><ul>
<li><code>Vuex</code>的状态存储是响应式的。当<code>Vue</code>组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 <code>store</code> 中的状态。改变 <code>store</code> 中的状态的唯一途径就是显式地提交(<code>commit</code>) <code>mutations</code>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ul>
<h3 id="Vuex实例"><a href="#Vuex实例" class="headerlink" title="Vuex实例"></a><code>Vuex</code>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这就是一个<code>vuex</code>的最简单实例，<code>store</code>就是组件中的共享状态，而改变状态的方法(其实是一个对象包含很多方法，但都是来改变<code>store</code>的)叫做:<code>mutations</code>；<br> 需要特变注意的是只能通过<code>mutations</code>改变<code>store</code>的<code>state</code>的状态，不能通过<code>store.state.count = 5</code>;直接更改（其实可以更改，不建议这么做，不通过<code>mutations</code>改变<code>state</code>，状态不会被同步）。<br> 使用<code>store.commit</code>方法触发<code>mutations</code>改变<code>state</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;);</span><br><span class="line">console.log(store.state.count)  // 1</span><br></pre></td></tr></table></figure>
<p> 这样一个简简单单的Vuex应用就实现了。 </p>
<h3 id="在Vue组件里使用Vuex"><a href="#在Vue组件里使用Vuex" class="headerlink" title="在Vue组件里使用Vuex"></a>在<code>Vue</code>组件里使用<code>Vuex</code></h3><p> <code>Vuex</code>的状态获取是一个方法，当<code>Vuex</code>状态更新时，相应的<code>Vue</code>组件也要更新，所以<code>Vue</code>应该在计算属性（<code>computed</code>）获取<code>state</code>； </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return store.state.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面的例子是直接操作全局状态<code>store.state.count</code>，那么每个使用该<code>Vuex</code>的组件都要引入。为了解决这个，<code>Vuex</code>通过<code>store</code>选项，提供了一种机制将状态从根组件注入到每一个子组件中。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 根组件</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    store,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Counter</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">            &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 通过这种注入机制，就能在子组件<code>Counter</code>通过<code>this.$store</code>访问： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return this.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mapState函数"><a href="#mapState函数" class="headerlink" title="mapState函数"></a><code>mapState</code>函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">        return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这样通过<code>count</code>计算属性获取同名<code>state.count</code>属性，是不是显得太重复了，我们可以使用<code>mapState</code>函数简化这个过程。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: state =&gt; state.count,</span><br><span class="line">        countAlias: &apos;count&apos;,    // 别名 `count` 等价于 state =&gt; state.count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 还有更简单的使用方法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h5 id="Getters对象"><a href="#Getters对象" class="headerlink" title="Getters对象"></a><code>Getters</code>对象</h5><p> 如果我们需要对<code>state</code>对象进行做处理计算，如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数。这样是很没有效率的事情，当这个处理过程更改了，还有在多个组件中进行同样的更改，这就更加不易于维护。</p>
<p><code>Vuex</code>中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理。<code>Getters</code>接受<code>state</code>作为第一个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 在<code>Vue</code>中通过<code>store.getters</code>对象调用。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodos () &#123;</span><br><span class="line">    return this.$store.getters.doneTodos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>Getter</code>也可以接受其他<code>getters</code>作为第二个参数： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">  &#125;,</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue之路第一篇</title>
    <url>/2018/07/15/Vue%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h4 id="1、开发工具选择"><a href="#1、开发工具选择" class="headerlink" title="1、开发工具选择"></a>1、开发工具选择</h4><p> 这个和个人的开发习惯有关，并不做强求，厉害的话用记事本也可以。但是我还是建议用人气比较高的编辑工具，毕竟功能比较全面，开发起来效率比较高。 </p><p>Visual Studio Code：一个运行于 Mac OS X、<a href="https://baike.baidu.com/item/Windows" target="_blank" rel="noopener">Windows</a>和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。</p><a id="more"></a>

<p>Visual Studio Code 官方免费下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p>
<p>另外说一句 VS yyds！！！！</p>
<h4 id="2、Vue安装"><a href="#2、Vue安装" class="headerlink" title="2、Vue安装"></a>2、Vue安装</h4><p> 直接下载并用  script 标签引入，Vue会被注册为一个全局变量。 </p>
<p>开发版本链接：<a href="https://cn.vuejs.org/js/vue.js" target="_blank" rel="noopener">https://cn.vuejs.org/js/vue.js</a></p>
<p>生产版本链接：<a href="https://cn.vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://cn.vuejs.org/js/vue.min.js</a></p>
<p>CDN：</p>
<p>对于学习 我们可以这样使用最新版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue之路第二篇</title>
    <url>/2018/07/16/Vue%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
    <content><![CDATA[<h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><p>1、首先创建一个html页面 导入Vue 包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js/vue.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p> 每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的： </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       el : <span class="string">"#app"</span>,</span><br><span class="line">       data : &#123;</span><br><span class="line">            msg : <span class="string">"Hello Vue"</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p> 通过new的方式创建了一个Vue对象，对象包含了 el 和 data两个属性(这一篇只涉及这两个属性)，</p>
<p>“el” 是用来绑定元素节点的，对应的是id为app的元素节点</p>
<p>“data” 是Vue对象里绑定的数据，采用的 key-value形式定义。展示数据的时候采用的是插值表达式 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue双向数据绑定v-model指令</title>
    <url>/2018/07/18/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。"><a href="#双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。" class="headerlink" title="双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。"></a>双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。</h3><p>指令中v-model可以实现双向数据绑定。</p><p>v-model只能应用在表单元素中，如：input（radio、text、address、email…）、checkbox、select、textarea等。</p><a id="more"></a>

<h3 id="看例子"><a href="#看例子" class="headerlink" title="看例子"></a>看例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-bind:value</span>=<span class="string">"msg"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;</span><br><span class="line"><span class="javascript">                msg : <span class="string">'This is a msg'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods : &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候我们 打开浏览器控制台输入：vm.msg，按下enter键查看对象属性。</p>
<p>“This is a msg”</p>
<p>接下来在控制台执行一条语句：vm.msg = 123 ，对msg数据重新赋值</p>
<p>123</p>
<p>可以看到我们在赋值的同时，页面的数据也随之发生了变化；那么我们再试试改变页面展示的数据，看看msg后台数据会不会发生变化。</p>
<p>先在页面input框里加上了“aaa”，然后在页面控制台中输入vm.msg查看，发现其值没有发生变化，还是“123”，这就是数据单向绑定。</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到我们连input框的value元素都不用写，直接用v-model指令即可，其值会默认赋值在value属性上（这也是为什么v-model仅局限于表单元素使用的原因）。</p>
<p>我们先在浏览器控制台中做赋值：vm.msg = 123，观察到页面数据也会随之变化。</p>
<p> 然后我们在输入框中加上“神奇”二字，会发现input框上面的h4标签的文字会随之变化，控制台输入：vm.msg，其对象值也发生了变化，这就是双向数据绑定。 </p>
<h3 id="v-model指令后面还可以添加参数"><a href="#v-model指令后面还可以添加参数" class="headerlink" title="v-model指令后面还可以添加参数"></a>v-model指令后面还可以添加参数</h3><p> lazy：将数据变化改到change事件中发生 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在v-model后加上了“.lazy”，这时我们在Input框里输入内容的时候，h4标签的内容不会马上变化，只有当输入完毕，光标不再聚焦于input框的时候，值才会同步，相当于change事件触发时才会同步数据。还有一些参数，比如：number、debounce</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue子组件向父组件传值</title>
    <url>/2018/08/14/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><ol>
<li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li>
<li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li>
</ol><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure>
<p>3、子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 引用父组件 --&gt;</span><br><span class="line">    &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 组件模板定义 --&gt;</span><br><span class="line">    &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 子组件的定义方式</span><br><span class="line">    Vue.component(&apos;son&apos;, &#123;</span><br><span class="line">      template: &apos;#son&apos;, // 组件模板Id</span><br><span class="line">      methods: &#123;</span><br><span class="line">        sendMsg() &#123; // 按钮的点击事件</span><br><span class="line">          this.$emit(&apos;func&apos;, &apos;OK&apos;); // 调用父组件传递过来的方法，同时把数据传递出去</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span><br><span class="line">          alert(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue事件修饰符</title>
    <url>/2018/07/18/Vue%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p> 顾名思义，“事件修饰符”那么肯定是用来修饰事件，既然和事件有关系，那么肯定和“v-on”指令也可简写为：@ 有关系。 </p><p>事件修饰符有以下几类：</p><p>.stop：阻止冒泡</p><p>.prevent：阻止默认事件</p><p>.capture：事件捕获</p><p>.self：只当事件在该元素本身触发时触发回调</p><p>.once：事件只触发一次</p><h3 id="1、阻止冒泡"><a href="#1、阻止冒泡" class="headerlink" title="1、阻止冒泡"></a>1、阻止冒泡</h3><a id="more"></a>






<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"clickDiv()"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickButton()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>样式代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#715F5F</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">　　　　 <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>JS</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el : <span class="string">"#app"</span>,</span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">                clickDiv()&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'点击了div'</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                clickButton()&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'点击了button'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p> 当点击按钮的时候，浏览器控制台除了会输出“点击了button”还会输出“点击了div”，这是因为button按钮是div里的元素节点，当你点击button的时候，事件会向上冒泡，触发包含它的父元素所定义的事件，这就是冒泡事件。如果想阻止冒泡事件就需用到“.stop”修饰符。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"clickButton"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时再点击按钮不会触发点击父元素div的事件。</p>
<h3 id="2、阻止默认事件"><a href="#2、阻止默认事件" class="headerlink" title="2、阻止默认事件"></a>2、阻止默认事件</h3><p>什么是默认事件？如：点击a链接自动进行跳转、点击submit按钮自动提交表单等。我们以a链接为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"linkClick()"</span>&gt;</span>有问题，先百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">                linkClick()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'点击了a链接'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 加上.prevent修饰符后，a链接不能进行跳转，但是仍然可以触发click事件。 </p>
<h3 id="3、事件捕获"><a href="#3、事件捕获" class="headerlink" title="3、事件捕获"></a>3、事件捕获</h3><p> 还记得冒泡事件中触发的顺序吗？即：先触发button按钮的点击事件，然后会触发button父元素div的点击事件；如果我想点击button之后先触发父元素div的点击事件，然后再触发子元素button的点击事件呢？ </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.capture</span>=<span class="string">"clickDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickButton"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 即：在事件触发中进行捕获，优先执行含有“.capture”修饰符的事件。 </p>
<h3 id="4、只当事件在该元素本身触发时触发回调"><a href="#4、只当事件在该元素本身触发时触发回调" class="headerlink" title="4、只当事件在该元素本身触发时触发回调"></a>4、只当事件在该元素本身触发时触发回调</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.self</span>=<span class="string">"clickDiv"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickButton"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 我们在父元素div里加了“.self”，这样父元素的点击事件只有在点击自身元素的情况下才可以触发，点击其他的任何元素（如子元素button）都不会触发包含修饰符“.self”的元素事件。 </p>
<h3 id="5、事件只触发一次"><a href="#5、事件只触发一次" class="headerlink" title="5、事件只触发一次"></a>5、事件只触发一次</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> @<span class="attr">click.prevent.once</span>=<span class="string">"clickLink()"</span>&gt;</span>有问题，去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">                clickLink()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'点击了a链接'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的修饰符“.once”的作用是让默认阻止行为（.prevent）只生效一次，所以当我们第一次点击a链接的时候，浏览器控制台会输出“点击了a链接”，但是页面不会跳转，当我们再次点击a链接的时候页面会跳转到百度页面，这就是”.once”修饰符的作用。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令v-if和v-show</title>
    <url>/2018/07/23/Vue%E6%8C%87%E4%BB%A4v-if%E5%92%8Cv-show/</url>
    <content><![CDATA[<h3 id="v-if和v-show都是用来实现条件判断的指令。"><a href="#v-if和v-show都是用来实现条件判断的指令。" class="headerlink" title="v-if和v-show都是用来实现条件判断的指令。"></a>v-if和v-show都是用来实现条件判断的指令。</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"reverse()"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span>这是v-if指令控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span>这是v-show指令控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                flag:<span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                reverse()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>
<p>当页面元素隐藏或者显示的时候，v-if每次都会重新删除或创建元素，v-show指令则通过控制样式属性display的值来实现同样的效果。</p>
<p>总结：</p>
<p>v-if由于每次都会重新删除或创建元素，所以有较高的切换性能消耗。</p>
<p>v-show通过控制样式属性display的值来显示隐藏元素，但是即使你不需要显示，该元素还是被页面渲染了，所以其有较高的初始渲染消耗。</p>
<p>具体使用哪一个还是要根据实际的业务场景来判断使用。</p>
<p>如果元素涉及到频繁的切换，最好不要使用<code>v-if</code>,如果元素可能永远也不会被显示出来被用户看到则推荐使用<code>v-if</code> </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令V-for</title>
    <url>/2018/07/23/Vue%E6%8C%87%E4%BB%A4V-for/</url>
    <content><![CDATA[<p>v-for指令，看名字想必大家也能猜到其作用，没错，就是用来迭代、遍历的。</p><h3 id="1、简单数组的遍历"><a href="#1、简单数组的遍历" class="headerlink" title="1、简单数组的遍历"></a>1、简单数组的遍历</h3><p> 我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span>&#123;&#123;item&#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                list:[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>,<span class="string">'five'</span>]</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>data里定义了list字符串数组，在页面中使用v-for指令对list进行遍历，”item”是当前正在遍历的元素对象，“in”是固定语法，“list”是被遍历的数组。用插值表达式来展示当前遍历的对象。</p>
<p>有时除了遍历数据外，我们还需要当前遍历的序号：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item,i) in list"</span>&gt;</span>序号为：&#123;&#123;i&#125;&#125;，元素为：&#123;&#123;item&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> （Item,i）其中i为序号，当然i和item是临时变量可以任意定义。</p>
<h3 id="2、对象数组的遍历"><a href="#2、对象数组的遍历" class="headerlink" title="2、对象数组的遍历"></a>2、对象数组的遍历</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item,i) in list"</span>&gt;</span>序号：&#123;&#123;i&#125;&#125;，科目为：&#123;&#123;item.course&#125;&#125;，分数为：&#123;&#123;item.score&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                list:[</span><br><span class="line"><span class="javascript">                    &#123;<span class="string">'course'</span>:<span class="string">'语文'</span>, <span class="string">'score'</span>:<span class="number">89</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">'course'</span>:<span class="string">'数学'</span>, <span class="string">'score'</span>:<span class="number">80</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">'course'</span>:<span class="string">'英语'</span>, <span class="string">'score'</span>:<span class="number">90</span>&#125;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 通过”item.score”的方法，来获取对象的属性值。</p>
<h3 id="3、遍历对象"><a href="#3、遍历对象" class="headerlink" title="3、遍历对象"></a>3、遍历对象</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in mark"</span>&gt;</span>属性名：&#123;&#123;key&#125;&#125;，属性值：&#123;&#123;value&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                mark:&#123;</span><br><span class="line"><span class="javascript">                    <span class="string">'语文'</span>:<span class="number">90</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'数学'</span>:<span class="number">95</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'英语'</span>:<span class="number">89</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个mark对象，该对象有三个属性，遍历对象的时候固定写法为：(XX,YY)，其中YY为对象的key，XX为对象的值。 当然也可以写成：(XX,YY,i)，其中i为索引值。 </p>
<h3 id="4、遍历数字"><a href="#4、遍历数字" class="headerlink" title="4、遍历数字"></a>4、遍历数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;divi id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;span v-for=&quot;count in 5&quot;&gt;当前数字为：&#123;&#123;count&#125;&#125;&lt;br&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p> 这里in后面直接写的是具体的数字 。</p>
<h3 id="5、维护状态"><a href="#5、维护状态" class="headerlink" title="5、维护状态"></a>5、维护状态</h3><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code>。</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
<p> 不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令v-on</title>
    <url>/2018/07/17/Vue%E6%8C%87%E4%BB%A4v-on/</url>
    <content><![CDATA[<p> v-on指令用来触发页面事件的指令。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"show()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">'aa'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>如上代码，指令书写格式为：v-on:事件名称，不要忘记书写:，等于号后面的内容是Vue对象里声明的方法。</p>
<p>在Vue对象里，我们添加了一个新的属性，叫做methods，它用来声明方法对象，其中show即为我们声明的方法对象。</p>
<p> 在Vue中，我们还可以对v-on进行简化，用@来代替，效果是一样的，代码如下所示： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;show()&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>除了click事件，我们还可以定义其他的一些常用事件，如：</p>
<p>mouseover：鼠标放上事件</p>
<p>mouseout：鼠标移开事件</p>
<p>change：内容改变</p>
<p>dblclick：双击事件</p>
<p>focus：聚焦事件</p>
<p>blur：失去焦点事件</p>
<p>等等等……</p>
<p>es6方法定义新写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前的写法</span></span><br><span class="line">show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'aa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Es6的新写法</span></span><br><span class="line">show()&#123;</span><br><span class="line">    alert(<span class="string">'aa'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue按键修饰符</title>
    <url>/2018/07/26/Vue%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>  在监听键盘事件时，我们经常需要监听常见的键值，vue允许v-on在监听键盘事件时添加按键修饰符： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        序号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"idValue"</span>/&gt;</span></span><br><span class="line">        车名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"nameValue"</span> @<span class="attr">keyup.enter</span>=<span class="string">"add()"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">           序号：&#123;&#123;item.id &#125;&#125; , 车名：&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                idValue:<span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">                nameValue:<span class="string">''</span>,</span></span><br><span class="line">                list:[</span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'奥迪'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'宝马'</span>&#125;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                add()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.list.unshift(&#123;</span></span><br><span class="line"><span class="javascript">                        id : <span class="keyword">this</span>.idValue,</span></span><br><span class="line"><span class="javascript">                        name : <span class="keyword">this</span>.nameValue</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p> 这里在车名的input框里添加keyup事件，即键盘按下抬起时触发；后面的“enter”即为按键修饰符，定义哪个按键会触发该事件。所以当光标位于该input框时，按下Enter键抬起就会触发事件执行add方法，并添加新数据展示在页面上。 </p>
<p> 除了enter键以外，vue还定义了以下按键修饰符：tab、delete (捕获“删除”和“退格”键)、esc、space、up、down、left、right；这些是官网提供的修饰符，但是实际进行操作的时候发现，几乎所有的键盘按键都可以用来作为修饰符。</p>
<p> 除了使用以上方法，我们还可以使用keycode（键盘码）来作为修饰符使用。如：f2的键盘码为113，我们可以修改代码为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">车名：&lt;input type=&quot;text&quot; v-model=&quot;nameValue&quot; @keyup.113=&quot;add()&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>这时光标在input框时，我们按下再松开f2时也可以触发事件。</p>
<p>注：不管是使用键盘名称还是使用键盘码都要防止快捷键的冲突，快捷键冲突的时候会不起作用。</p>
<p>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.keyCodes.f2 = 113;</span><br></pre></td></tr></table></figure>
<p>使用自定义的按键修饰符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue实例的生命周期函数</title>
    <url>/2018/08/02/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h2><ul>
<li><p>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</p>
</li>
<li><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p>
</li>
<li><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p>
<h3 id="主要的生命周期函数分类："><a href="#主要的生命周期函数分类：" class="headerlink" title="主要的生命周期函数分类："></a>主要的生命周期函数分类：</h3></li>
</ul><h4 id="创建期间的生命周期函数："><a href="#创建期间的生命周期函数：" class="headerlink" title="创建期间的生命周期函数："></a>创建期间的生命周期函数：</h4><ul>
<li>beforeCreate：刚初始化一个Vue空的实例对象，这个对象上只有一些生命周期函数和默认的事件，此时，还没有初始化好 data 和 methods 的数据</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板（如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作）</li>
<li>beforeMount：开始编辑模板 在内存中生成一个编译好的最终模板字符串，然后渲染为内存中的DOM，此时已经完成了模板的编译，但是还没有挂载到真正的页面中</li>
<li>mounted：此时，表示整个Vue实例已经初始化完毕了，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul><a id="more"></a>

<h4 id="运行期间的生命周期函数："><a href="#运行期间的生命周期函数：" class="headerlink" title="运行期间的生命周期函数："></a>运行期间的生命周期函数：</h4><ul>
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
<h4 id="销毁期间的生命周期函数："><a href="#销毁期间的生命周期函数：" class="headerlink" title="销毁期间的生命周期函数："></a>销毁期间的生命周期函数：</h4><ul>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。实例身上所有的data和所有的methods以及过滤器、指令….都处于可用状态，还没有真正执行销毁的过程</li>
<li>destroyed：Vue 实例销毁后调用。已经完全被销毁，此时实例所有的数据、方法、指令过滤器都不可用了</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue注册局部子组件</title>
    <url>/2018/08/12/Vue%E6%B3%A8%E5%86%8C%E5%B1%80%E9%83%A8%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><p>1、组件实例定义方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components: &#123; </span><br><span class="line">        account: &#123; </span><br><span class="line">          template: &apos;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>2、引用组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">account</span>&gt;</span><span class="tag">&lt;/<span class="name">account</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h3><ol>
<li><p>页面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt;</span><br><span class="line">    &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt;</span><br><span class="line">    &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.Vue实例内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&apos;myCom1&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h3&gt;奔波霸&lt;/h3&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.component(&apos;myCom2&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h3&gt;霸波奔&lt;/h3&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        flag: true</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用-is属性来切换不同的子组件"><a href="#使用-is属性来切换不同的子组件" class="headerlink" title="使用:is属性来切换不同的子组件"></a>使用<code>:is</code>属性来切换不同的子组件</h3><p>1、组件实例定义方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录组件</span></span><br><span class="line">   <span class="keyword">const</span> login = Vue.extend(&#123;</span><br><span class="line">     template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">       &lt;h3&gt;登录组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;`</span></span><br><span class="line">   &#125;);</span><br><span class="line">   Vue.component(<span class="string">'login'</span>, login);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册组件</span></span><br><span class="line">   <span class="keyword">const</span> register = Vue.extend(&#123;</span><br><span class="line">     template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">       &lt;h3&gt;注册组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;`</span></span><br><span class="line">   &#125;);</span><br><span class="line">   Vue.component(<span class="string">'register'</span>, register);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     el: <span class="string">'#app'</span>,</span><br><span class="line">     data: &#123; <span class="attr">comName</span>: <span class="string">'login'</span> &#125;,</span><br><span class="line">     methods: &#123;&#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>2、使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='login'"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='register'"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"comName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue父组件向子组件传值</title>
    <url>/2018/08/14/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>1、组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;这是父组件中的消息&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        son: &#123;</span><br><span class="line">          template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;,</span><br><span class="line">          props: [&apos;finfo&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>2、使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue第四篇指令v-html</title>
    <url>/2018/07/16/Vue%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%8C%87%E4%BB%A4v-html/</url>
    <content><![CDATA[<h3 id="指令v-html"><a href="#指令v-html" class="headerlink" title="指令v-html"></a>指令v-html</h3><p>如果我们展示的数据包含元素标签或者样式，我们想展示标签或样式所定义的属性作用，该怎么进行渲染</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">           el : <span class="string">"#app"</span>,</span></span><br><span class="line">           data : &#123;</span><br><span class="line"><span class="xml">               msg : "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个h1元素内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>"</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>  就可以成功解析标签。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue第五篇指令v-bind</title>
    <url>/2018/07/16/Vue%E7%AC%AC%E4%BA%94%E7%AF%87%E6%8C%87%E4%BB%A4v-bind/</url>
    <content><![CDATA[<p>v-bind：是Vue提供的用于绑定html属性的指令。</p><p>html中常见的属性有：id、class、src、title、style等，他们都是以 名称/值对 的形式出现，如：id=”first”</p><p>本篇的内容主要是介绍使用v-bind指令动态给这些属性赋值。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"path"</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;</span><br><span class="line"><span class="javascript">                path : <span class="string">"img/clock.png"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>



<p>主要分为两个模块：定义了一个Img标签，它的src属性值通过v-bind指令从Vue对象中获取；js代码定义了Vue对象，并声明了data数据。</p>
<p> v-bind的一种简写形式，那就是我们在实际传递属性值数据的时候可以不写“v-bind”只留属性名称前面的冒号:即可。 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue计算属性</title>
    <url>/2018/08/16/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p> 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。 </p>
<p>表达式里面包含了3个操作，有时候可能会更加复杂，这时我们可以使用计算属性。如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;reversedText&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                text: &apos;123,456&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            reversedText: function () &#123;</span><br><span class="line">                //这里的this指向的是当前的vue实例</span><br><span class="line">                return this.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;);  //如果这两的text是后台接受的数据，最好加个判断数据为不为空</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 所有计算属性都以函数的形式写在<code>Vue</code>实例内的<code>computed</code>选项内，最终返回计算后的结果 </p>
<h3 id="计算属性用法"><a href="#计算属性用法" class="headerlink" title="计算属性用法"></a>计算属性用法</h3><p>在一个计算属性里可以完成各种复杂的逻辑，包括逻辑运算、函数调用等，只要最终返回一个结果就可以。除了上面的简单的用法，计算属性还可以依赖多个<code>vue</code>实例的数据，只要其中任意一个数据变化，计算属性就会重新执行，视图也会更新，例如下面的例子展示的是购物车内两个包裹的物品总价 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;prices&quot;&gt;</span><br><span class="line">         总价： &#123;&#123;prices&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">       // &lt;!--购物车总价--&gt;</span><br><span class="line">        var prices = new Vue(&#123;</span><br><span class="line">            el: &quot;#prices&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                package1: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为mate20pro&quot;,</span><br><span class="line">                    price: 4566,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为p30&quot;,</span><br><span class="line">                    price: 4166,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                ],</span><br><span class="line">                package2: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;苹果&quot;,</span><br><span class="line">                    price: 30,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;香蕉&quot;,</span><br><span class="line">                    price: 2,</span><br><span class="line">                    count: 20</span><br><span class="line">                &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                prices: function () &#123;</span><br><span class="line">                    var prices = 0;</span><br><span class="line">                    debugger</span><br><span class="line">                    for (var i = 0; i &lt; this.package1.length; i++) &#123;</span><br><span class="line">                        prices += this.package1[i].price * this.package1[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (var i = 0; i &lt; this.package2.length; i++) &#123;</span><br><span class="line">                        prices += this.package2[i].price * this.package2[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return prices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 当package1或package2中的商品发生变化，比如购买数量变化或者增删商品时，计算属性prices就会自动更新，视图中的总价也会自动变化<br>每个计算属性都包含一个getter和setter，上面的例子都是计算属性默认用法，只是利用了getter来读取。在你需要时，也可以提供一个setter函数，当手动修改计算属性的值就像修改一个普通数据那样，就会触发setter函数，执行一些自定义的操作。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--setter--&gt;</span><br><span class="line">        &lt;div id=&quot;setter&quot;&gt;</span><br><span class="line">         姓名： &#123;&#123;fullName&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> var setter = new Vue(&#123;</span><br><span class="line">            el: &quot;setter&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                firstName: &apos;Jack&apos;,</span><br><span class="line">                lastName:&apos;Green&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                fullName: &#123;</span><br><span class="line">                    //getter,用于读取</span><br><span class="line">                    get: function ()</span><br><span class="line">                    &#123;</span><br><span class="line">                        return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">                    &#125;,</span><br><span class="line">                    //setter，写入时触发</span><br><span class="line">                    set: function (newValue)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var names = newValue.split(&apos; &apos;);</span><br><span class="line">                        this.firstName = names[0];</span><br><span class="line">                        this.lastName = names[1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 当执行 setter.fullName=’Join Doe’时候，setter就会被调用，数据firstName和lastName都会相对更新，视图同样也会更新<br>    绝大多情况下，我们只会使用默认的getter方法来读取一个计算属性，在业务中很少使用到setter，所以在声明一个计算属性的时候，可以直接使用默认的写法，不必将getter和setter都声明<br>   计算属性除啦以上简单的文本插值外，还经常用于动态的设置元素的样式名称class和内联样式style，当使用组件时，计算属性也经常用来动态传递props以后，我会慢慢介绍到<br>计算属性还有两个很使用的小技巧很容易被忽略，一是计算属性可以依赖其他计算属性，二是计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他Vue实例的数据 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;div id=&quot;app2&quot;&gt;</span><br><span class="line">         &#123;&#123;reversedText&#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var app1 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app1&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: &quot;123,456&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var app2 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app2&quot;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                reversedText: function () &#123;</span><br><span class="line">                    //这里是依赖app1实例中的数据text</span><br><span class="line">                    return app1.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 这里我们创建了两个vue实例app1和app2，在app2的计算属性reversedText中，依赖的是app1的数据text，所以当text变化时，实例app2的计算属性也会变化，这样的用法以后用到的也会比较多，尤其是在多人协同开发时很常用，以为你写的组件所用到的数据需要依赖他人的组件提供，以后接触的多了就会慢慢的意识到这一点。 </p>
<h3 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a><strong>计算属性缓存</strong></h3><p> 其实细心的话就会发现，调用methods里的方法也能实现和计算属性一样的效果，甚至有的方法还能接收参数，使用起来更加的灵活，既然使用methods就可以实现，那为什么还需要计算属性呢？原因就是计算属性是基于他的依赖缓存的。一个计算属性所依赖的数据发生变化时，他才会重新取值，<br>所以依赖的text只要不改变。计算属性也就不更新 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed：&#123;</span><br><span class="line">now：function()</span><br><span class="line"> 	&#123;</span><br><span class="line">		return Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里的<code>Date.now()</code>不是响应式依赖，所以计算属性<code>now</code> 不会更新，但是<code>methods</code>则不同，只要重新渲染他就会被调用，因此函数也会被执行。<br>使用计算属性还是<code>methods</code>取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存 </p>
<p><code>methods</code>和计算属性<code>computed</code> 实现的最终效果其实是一样的，然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 数据  没有发生改变，多次访问 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用<code>methods</code>方法将总会再次执行函数。</p>
<p>计算属性的求值结果会被缓存起来，方便下次直接使用，如果计算属性方法中所依赖的任何数据都没有发生过改变，则不会重新对计算属性求值。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue组件的注册</title>
    <url>/2018/08/12/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h3 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h3><p>什么是组件： 组件的出现，就是为了拆分<code>Vue</code>的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul>
<li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li>
<li>组件化： 是从<code>UI</code>界面的角度进行划分的；前端的组件化，方便<code>UI</code>组件的重用；</li>
</ul><a id="more"></a>

<h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><p>1、使用<code>Vue. extend</code>配合<code>Vue.component</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> login=Vue.extend(&#123;</span><br><span class="line">		template:<span class="string">'&lt;h1&gt;登陆组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line">		Vue.component(<span class="string">'login'</span>,login)</span><br></pre></td></tr></table></figure>
<p>2、直接使用<code>Vue.component</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'register'</span>,&#123;</span><br><span class="line">		template:<span class="string">'&lt;h1&gt;注册组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3、将模板字符串，定义到<code>script</code>标签中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>同时需要使用<code>Vue.component</code>来注册组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;,&#123;</span><br><span class="line">		template:&apos;#tmp1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意： 组件中的<code>DOM</code>结构，有且只能有唯一的根元素（<code>Root Element</code>）来进行包裹！</p>
<h3 id="组建中展示数据和响应事件"><a href="#组建中展示数据和响应事件" class="headerlink" title="组建中展示数据和响应事件"></a>组建中展示数据和响应事件</h3><p>1、在组件中，<code>data</code>需要被定义为一个方法</p>
<p> 组件中的<code>data</code>写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份<code>data</code>，就会造成一个变了全都会变的结果。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'account'</span>, &#123;</span><br><span class="line">      template: <span class="string">'#tmpl'</span>,</span><br><span class="line">      data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          msg: <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(<span class="string">'点击了登录按钮'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>2、在子组件中。如果将模板字符串定义到了<code>script</code>标签中了，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue自定义指令</title>
    <url>/2018/07/27/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。</p><p>自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。</p><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><p><strong>bind：</strong>只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。</p><a id="more"></a>



<p><strong>inserted：</strong>被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p><strong>update：</strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
<p><strong>componentUpdated：</strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>
<p><strong>unbind：</strong>只调用一次，指令与元素解绑时调用。</p>
<h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><p>指令钩子函数会被传入以下参数：</p>
<p>el：指令所绑定的元素，可以用来直接操作 DOM 。<br>binding：一个对象，包含以下属性：<br>name：指令名，不包括 v- 前缀。<br>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1”中，表达式为 “1 + 1”。<br>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。<br>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。<br>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue1.0中提供了一个Vue.directive(自定义指令名称，回调函数)来供程序员自定义指令</span></span><br><span class="line"><span class="comment">//注意:在定义指令时不需要加v-前缀但是使用时必须加v-前缀</span></span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 聚焦元素</span></span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个v-color指令</span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素被绑定时</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>) </span>&#123;</span><br><span class="line">        el.style.color = binding.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>使用自定义指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus v-color=&quot;customColor&quot; placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">    el: &apos;#app-4&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">	directives: &#123;</span><br><span class="line">        focus: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            inserted: function(el) &#123;</span><br><span class="line">                el.focus()</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 使用自定义元素 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue过渡、动画</title>
    <url>/2018/08/05/Vue%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p><p> Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 </p><ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ul><a id="more"></a>


<h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><p>HTML结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动起来"</span> @<span class="attr">click</span>=<span class="string">"myAnimate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>VM实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    isshow: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myAnimate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>定义两组类样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义进入和离开时候的过渡状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter-active</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.2s</span> ease;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义进入过渡的开始状态 和 离开过渡的结束状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用第三方CSS动画库"><a href="#使用第三方CSS动画库" class="headerlink" title="使用第三方CSS动画库"></a>使用第三方CSS动画库</h3><p>1、导入动画类库：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./lib/animate.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、定义 transition 及属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">	<span class="attr">enter-active-class</span>=<span class="string">"fadeInRight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">"fadeOutRight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"animated"</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><p>1、定义 transition 组件以及三个钩子函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换动画"</span> @<span class="attr">click</span>=<span class="string">"isshow = !isshow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">before-enter</span>=<span class="string">"beforeEnter"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">after-enter</span>=<span class="string">"afterEnter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"isshow"</span> <span class="attr">class</span>=<span class="string">"show"</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、定义三个 methods 钩子方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        beforeEnter(el) &#123; <span class="comment">// 动画进入之前的回调</span></span><br><span class="line">          el.style.transform = <span class="string">'translateX(500px)'</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        enter(el, done) &#123; <span class="comment">// 动画进入完成时候的回调</span></span><br><span class="line">          el.offsetWidth;</span><br><span class="line">          el.style.transform = <span class="string">'translateX(0px)'</span>;</span><br><span class="line">          done();</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter(el) &#123; <span class="comment">// 动画进入完成之后的回调</span></span><br><span class="line">          <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>3、定义动画过渡时长和样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.4s</span> ease;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>src与href的区别</title>
    <url>/2018/09/10/src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p> src和href都是用于外部资源的引入，像图片、CSS文件、HTML文件、js文件或其他web页面等。 </p><p>引用css文件时：<code>href=&quot;cssfile.css&quot;</code> </p><p>引用js文件时：<code>src=&quot;myscript.js&quot;</code> </p><p>引用图片：<code>src=&quot;mypic.jpg&quot;</code> </p><a id="more"></a>



<p>网站链接：<code>href=&quot;http://www.webpage.com&quot;</code></p>
<p><strong>它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。</strong> </p>
<p> <strong>href (Hypertext Reference) 超文本引用</strong><code>href</code>这个属性指定<code>web</code>资源的位置，从而定义当前元素（如锚点<code>a</code>）或当前文档（如链接）与目标锚点或目标资源之间的联系。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器知道这是个样式表文件，html的解析和渲染不会暂停，css文件的加载是同时进行的，这不同于在style标签里面的内置样式，用@import添加的样式是在页面载入之后再加载，这可能会导致页面因重新渲染而闪烁。所以我们建议使用<code>link</code>而不是<code>@import</code>。</p>
<h3 id="补充：link和-import的区别"><a href="#补充：link和-import的区别" class="headerlink" title="补充：link和@import的区别"></a>补充：<code>link</code>和@<code>import</code>的区别</h3><p>两者都是外部引用<code>CSS</code>的方式，但是存在一定的区别：</p>
<p>1、<code>link</code>是<code>XHTML</code>标签，除了加载<code>CSS</code>外，还可以定义<code>RSS</code>等其他事务；<code>@import</code>属于<code>CSS</code>范畴，只能加载<code>CSS</code>。</p>
<p>2、<code>link</code>引用<code>CSS</code>时，在页面载入时同时加载；@<code>import</code>需要页面网页完全载入以后加载。</p>
<p>3、<code>link</code>是<code>XHTML</code>标签，无兼容问题；@<code>import</code>是在<code>CSS2.1</code>提出的，低版本的浏览器不支持。</p>
<p>4、<code>link</code>支持使用<code>Javascript</code>控制<code>DOM</code>去改变样式；而<code>@import</code>不支持。</p>
<p> <strong>src (Source)源</strong>这个属性是将资源嵌入到当前文档中元素所在的位置。 在请求<code>src</code>资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。 例如当我们写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个<code>js</code>文件。这就像是把<code>js</code>文件里的内容全部注入到这个<code>script</code>标签中，类似于<code>img</code>，<code>img</code>标签是一个空标签，它的内容就是由<code>src</code>这个属性定义，浏览器会暂停加载直到这个图片加载完成。这也是为什么要将<code>js</code>文件的加载放在<code>body</code>最后的原因（在<code>&lt;body&gt;</code>前面）。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>Vue面试题整理</title>
    <url>/2021/06/20/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="什么是-MVVM？"><a href="#什么是-MVVM？" class="headerlink" title="什么是 MVVM？"></a>什么是 MVVM？</h4><p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p><a id="more"></a>
<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h4 id="vue的优点是什么？"><a href="#vue的优点是什么？" class="headerlink" title="vue的优点是什么？"></a>vue的优点是什么？</h4><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p>
<p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h4 id="组件之间的传值？"><a href="#组件之间的传值？" class="headerlink" title="组件之间的传值？"></a>组件之间的传值？</h4><ul>
<li><p>父组件通过标签上<code>:data=data</code>方式定义传值</p>
</li>
<li><p>子组件通过<code>props</code>方法接受数据</p>
</li>
<li><p>子组件通过<code>$emit</code>方法传递参数</p>
</li>
</ul>
<h4 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>vue框架中状态管理。在main.js引入store注入。新建一个目录store 。场景有：单页应用中，组件之间的状态，音乐播放、登录状态、加入购物车等。</p>
<h4 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h4><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module。</p>
<h4 id="vuex的State特性"><a href="#vuex的State特性" class="headerlink" title="vuex的State特性"></a>vuex的State特性</h4><p>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。</p>
<p>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。</p>
<p>通过mapState把全局 state 和 getters 映射到当前组件的 computed 计算属性中。</p>
<h4 id="vuex的Getter特性"><a href="#vuex的Getter特性" class="headerlink" title="vuex的Getter特性"></a>vuex的Getter特性</h4><p>getters 可以对State进行计算操作，它就是Store的计算属性。</p>
<p>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。</p>
<p>如果一个状态只在一个组件内使用，可以不用getters。</p>
<h4 id="vuex的Mutation特性"><a href="#vuex的Mutation特性" class="headerlink" title="vuex的Mutation特性"></a>vuex的Mutation特性</h4><p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p>
<h4 id="不用Vuex会带来什么问题？"><a href="#不用Vuex会带来什么问题？" class="headerlink" title="不用Vuex会带来什么问题？"></a>不用Vuex会带来什么问题？</h4><p>可维护性会下降，想修改数据要维护三个地方；</p>
<p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p>
<p>增加耦合，大量的上传派发，会让耦合性大大增加，Vue用Component本意就是为了减少耦合，现在这么用，和组件化的初衷相背。</p>
<h4 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="headerlink" title="v-show和v-if指令的共同点和不同点"></a>v-show和v-if指令的共同点和不同点</h4><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏；</p>
<p>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果；</p>
<p>使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>
]]></content>
  </entry>
  <entry>
    <title>全局过滤器</title>
    <url>/2018/07/26/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p> Vue.js 允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：插值表达式和 <code>v-bind</code> 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号（“|”）指示。使用方式为： msg | formatMsg，其中msg为要被过滤的文本，formatMsg为过滤器名称。 </p><a id="more"></a>
<p> 过滤器的定义方式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.filter(&apos;formatMsg&apos;,function(msg)&#123;//对data数据进行处理的方法体&#125;);</span><br></pre></td></tr></table></figure>
<p> 这里定义了一个名为formatMsg的过滤器，过滤器的第一个参数为过滤器的名称；第二个参数为过滤方法，方法参数是要被过滤的文本，即管道符号前面的数据。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                msg:<span class="string">'曾经小小少年，有小小的梦，小小的开始，小小的进步，小小的实现'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这里只是在页面简单的展示了msg定义的数据。现在我们要使用过滤器把msg里文本为“小小”的字符串替换为“大大”。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">       &lt;p&gt;&#123;&#123; msg | formatMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p> 页面上调用名字为formatMsg的过滤器 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义过滤器</span><br><span class="line">Vue.filter(&apos;formatMsg&apos;,function(msg)&#123;</span><br><span class="line">       return msg.replace(/小小/g,&apos;大大&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 这里定义了名称为formatMsg的过滤器，过滤器中调用replace方法把“小小”替换为“大大” </p>
<p> 过滤器还可以添加任意多个参数 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg | formatMsg('超级','大大') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这里过滤器有两个参数，那么在定义过滤器时，应该在相对应的过滤方法中展示对应的参数： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.filter('formatMsg',function(msg,arg1,arg2)&#123;</span><br><span class="line">       return msg.replace(/小小/g,arg1 + arg2);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p> 这里过滤方法中的第一个参数为需要过滤的文本，后面的参数为过滤器调用时带的参数。</p>
<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue常见面试题总结</title>
    <url>/2020/01/13/vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、什么是MVVM？"><a href="#一、什么是MVVM？" class="headerlink" title="一、什么是MVVM？"></a><strong>一、什么是MVVM？</strong></h1><p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p><a id="more"></a>
<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h1 id="二、vue的优点是什么？"><a href="#二、vue的优点是什么？" class="headerlink" title="二、vue的优点是什么？"></a>二、vue的优点是什么？</h1><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p>
<p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h1 id="三、组件之间的传值？"><a href="#三、组件之间的传值？" class="headerlink" title="三、组件之间的传值？"></a>三、组件之间的传值？</h1><ul>
<li><p>父组件通过标签上<code>:data=data</code>方式定义传值</p>
</li>
<li><p>子组件通过<code>props</code>方法接受数据</p>
</li>
<li><p>子组件通过<code>$emit</code>方法传递参数</p>
<!-- more !-->
</li>
</ul>
<h1 id="四、vuex面试相关"><a href="#四、vuex面试相关" class="headerlink" title="四、vuex面试相关"></a>四、vuex面试相关</h1><p>（1）vuex是什么？怎么使用？哪种功能场景使用它？</p>
<p>vue框架中状态管理。在main.js引入store注入。新建一个目录store 。场景有：单页应用中，组件之间的状态，音乐播放、登录状态、加入购物车等。</p>
<h2 id="（2）vuex有哪几种属性？"><a href="#（2）vuex有哪几种属性？" class="headerlink" title="（2）vuex有哪几种属性？"></a>（2）vuex有哪几种属性？</h2><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module。</p>
<h2 id="（3）-vuex的State特性"><a href="#（3）-vuex的State特性" class="headerlink" title="（3） vuex的State特性"></a>（3） vuex的State特性</h2><p>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。</p>
<p>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。</p>
<p>通过mapState把全局 state 和 getters 映射到当前组件的 computed 计算属性中。</p>
<h2 id="（4）vuex的Getter特性"><a href="#（4）vuex的Getter特性" class="headerlink" title="（4）vuex的Getter特性"></a>（4）vuex的Getter特性</h2><p>getters 可以对State进行计算操作，它就是Store的计算属性。</p>
<p>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。</p>
<p>如果一个状态只在一个组件内使用，可以不用getters。</p>
<h2 id="（5）vuex的Mutation特性"><a href="#（5）vuex的Mutation特性" class="headerlink" title="（5）vuex的Mutation特性"></a>（5）vuex的Mutation特性</h2><p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p>
<h2 id="（6）不用Vuex会带来什么问题？"><a href="#（6）不用Vuex会带来什么问题？" class="headerlink" title="（6）不用Vuex会带来什么问题？"></a>（6）不用Vuex会带来什么问题？</h2><p>可维护性会下降，想修改数据要维护三个地方；</p>
<p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p>
<p>增加耦合，大量的上传派发，会让耦合性大大增加，Vue用Component本意就是为了减少耦合，现在这么用，和组件化的初衷相背。</p>
<h1 id="五、v-show和v-if指令的共同点和不同点"><a href="#五、v-show和v-if指令的共同点和不同点" class="headerlink" title="五、v-show和v-if指令的共同点和不同点"></a>五、v-show和v-if指令的共同点和不同点</h1><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏；</p>
<p>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果；</p>
<p>使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>
<h1 id="六、请列举出3个Vue中常用的生命周期钩子函数"><a href="#六、请列举出3个Vue中常用的生命周期钩子函数" class="headerlink" title="六、请列举出3个Vue中常用的生命周期钩子函数"></a>六、请列举出3个Vue中常用的生命周期钩子函数</h1><p>created: 实例创建完成之后调用，在这一步，实例已经完成数据观测、 属性和方法的运算、watch/event事件回调。然而，挂载阶段还没有开始, $el属性目前还不可见。</p>
<p><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p>activated: keep-alive组件激活时调用。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>关于position的六种属性</title>
    <url>/2018/05/29/%E5%85%B3%E4%BA%8Eposition%E7%9A%84%E5%85%AD%E7%A7%8D%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="position的定位属性"><a href="#position的定位属性" class="headerlink" title="position的定位属性"></a>position的定位属性</h2><h4 id="1、position：static（默认值）无特殊定位。"><a href="#1、position：static（默认值）无特殊定位。" class="headerlink" title="1、position：static（默认值）无特殊定位。"></a>1、position：static（默认值）无特殊定位。</h4><p>（1）元素出现在正常的流中（忽略top、bottom、left、right或者z-index的声明）<br>（2）当没有为元素指定方式时，默认为static，也就是按照文档的流式（flow）定位，将元素放到一个合适的地方。</p><h4 id="2、position：inherit-规定从父元素继承position的属性值。"><a href="#2、position：inherit-规定从父元素继承position的属性值。" class="headerlink" title="2、position：inherit 规定从父元素继承position的属性值。"></a>2、position：inherit 规定从父元素继承position的属性值。</h4><a id="more"></a>
<h4 id="3、position：relative-相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。"><a href="#3、position：relative-相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。" class="headerlink" title="3、position：relative 相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。"></a>3、position：relative 相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。</h4><p>（1）相对于定位元素来说仍然在文档流中，依然占据他本来的位置空间。<br>（2）由于其不脱离文档流，所以在相对定位中区分块级元素/行内元素/行内块元素。<br>（3）由于其不脱离文档流，并且相对定位元素会占用标准流中的位置，所以给相对定位元素设置magin/padding等属性会影响到标准流中的布局。<br>（4）提升层级，用z-index的样式可以改变一个元素的层级关系，从而改变覆盖关系，值大者在上面。<br>（注意：1.在没有脱离文档流的情况下，后渲染的元素会覆盖先渲染的元素。2.改变margin-left和在positon：relative的基础上改变left的效果类似）</p>
<h4 id="4、position：absolute-绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）"><a href="#4、position：absolute-绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）" class="headerlink" title="4、position：absolute 绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）"></a>4、position：absolute 绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）</h4><p>（1）绝对定位元素脱离文档流，不占空间。<br>（2）绝对定位元素使行内元素在设置宽高时支持宽高，区块元素在设置宽度时由内容撑开宽度。<br>（3）相对于static以外的第一个祖先元素进行定位。（其父元素没有定位则逐层上找，直到document），元素位置通过偏移值（top、bottom、left、right）进行定位。<br>（4）用z-index可以提升层级关系，改变元素的覆盖关系。</p>
<h4 id="5、position：fixed-固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。"><a href="#5、position：fixed-固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。" class="headerlink" title="5、position：fixed 固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。"></a>5、position：fixed 固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。</h4><p>（1）固定定位的元素是脱离文档流的，不占据标准流的空间。<br>（2）定位效果类似于固定背景，元素与视窗始终相对静止，元素位置通过偏移值来规定。<br>（3）Fixed定位的元素会和其他元素重叠。<br>（4）用z-index可以提升层级关系，改变元素的覆盖关系。</p>
<h4 id="6、position：sticky-粘性定位"><a href="#6、position：sticky-粘性定位" class="headerlink" title="6、position：sticky 粘性定位"></a>6、position：sticky 粘性定位</h4><p>元素按照普通文档流定位，然后相对于该元素在流中flow root（BFC）和containing block（最近的块级祖先元素）定位。而后，元素定位表现在跨越特定阈值前为相对定位，之后为固定定位。<br>（1）不脱离文档流，不会影响其他元素的正常显示。<br>（2）可以理解为是position：relative和position：fixed的结合体。即当元素在屏幕内时，表现为relative；就要滚出显示器屏幕的时候，表现为fixed。<br>（3）sticky元素的效果完全受制于父级元素们。<br>注意：<br>a.父级元素不能有任何overflow:visible以外的overflow设置，否则没有粘滞效果。<br>b.父级元素设置和粘性定位元素等高的固定的height高度值，或者高度计算值和粘性定位元素高度一样，也没有粘滞效果。<br>c.同一个父容器中的sticky元素，如果定位值相等，则会重叠;<br>d.sticky定位，不仅可以设置top，基于滚动容器上边缘定位；还可以设置bottom，相对底部粘滞。如果是水平滚动，也可以设置left和right值。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>前端面试题整理(HTML篇)</title>
    <url>/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h4 id="doctype-⽂档类型-的作用是什么？"><a href="#doctype-⽂档类型-的作用是什么？" class="headerlink" title="doctype(⽂档类型)的作用是什么？"></a><code>doctype</code>(⽂档类型)的作用是什么？</h4><p>位于文档第一行，告知浏览器文档使用哪种 HTML 规范。告诉浏览器按照何种规范解析页面 </p><h4 id="常用的浏览器以及内核都是什么"><a href="#常用的浏览器以及内核都是什么" class="headerlink" title="常用的浏览器以及内核都是什么"></a>常用的浏览器以及内核都是什么</h4><p>IE: trident</p><p>Firefox：gecko  </p><p>Safari:webkit </p><p>Opera: Blink </p><p>Chrome:Blink</p><h4 id="img标签的title和alt有什么区别？"><a href="#img标签的title和alt有什么区别？" class="headerlink" title="img标签的title和alt有什么区别？"></a><code>img</code>标签的<code>title</code>和<code>alt</code>有什么区别？</h4><a id="more"></a>





<p><code>title</code>属性是对图片的描述与进一步说明，会在鼠标移到元素上时显示一段提示文本 </p>
<p> <code>alt</code>属性是当图片无法显示的时候的替代文本</p>
<h4 id="描述一下渐进增强和优雅降级之间的不同"><a href="#描述一下渐进增强和优雅降级之间的不同" class="headerlink" title="描述一下渐进增强和优雅降级之间的不同 ?"></a>描述一下渐进增强和优雅降级之间的不同 ?</h4><p> 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 </p>
<p>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 。</p>
<h4 id="谈一下你对网页标准和标准制定机构重要性的理解"><a href="#谈一下你对网页标准和标准制定机构重要性的理解" class="headerlink" title="谈一下你对网页标准和标准制定机构重要性的理解"></a>谈一下你对网页标准和标准制定机构重要性的理解</h4><p>网页标准和标准制定机构都是为了能让<code>web</code>发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO 也会更好做不会因为滥用代码导致各种<code>BUG</code>、安全问题， 最终提高网站易用性 </p>
<h4 id="描述一下cookies，sessionStorage和-localStorage的区别"><a href="#描述一下cookies，sessionStorage和-localStorage的区别" class="headerlink" title="描述一下cookies，sessionStorage和 localStorage的区别"></a>描述一下<code>cookies</code>，<code>sessionStorage</code>和 <code>localStorage</code>的区别</h4><p><code>sessionStorage</code>中的数据， 数据在当前浏览器窗⼝关闭后⾃动删除</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</p>
<p><code>sessionStorage</code>和<code>localStorage</code>不会⾃动把数据发给服务器，仅在本地保存 </p>
<p><code>cookie</code>数据⼤⼩不能超过<code>4k</code> </p>
<p><code>sessionStorage</code>和<code>localStorage</code> 虽然也有存储⼤⼩的限制，但⽐<code>cookie</code>⼤得 多，可以达到<code>5M</code>或更⼤ </p>
<h4 id="src与href的区别？"><a href="#src与href的区别？" class="headerlink" title="src与href的区别？"></a><code>src</code>与<code>href</code>的区别？</h4><p><code>src</code>用于替代这个元素，而<code>href</code>用于建立这个标签与外部资源之间的关系。</p>
<p> <strong>src (Source)源</strong>这个属性是将资源嵌入到当前文档中元素所在的位置。 在请求<code>src</code>资源时会将其指向的资源下载并应用到当前文档中 </p>
<p> <strong>href</strong>这个属性指定<code>web</code>资源的位置，从而定义当前元素或当前文档与目标资源之间的联系。 </p>
<h4 id="一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验?"></a>一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验?</h4><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p>
<p> 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先 下载。 </p>
<p>使用 CSSsprite，Iconfont技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图， 以提高用户体验。 </p>
<h4 id="语义化的理解"><a href="#语义化的理解" class="headerlink" title="语义化的理解"></a>语义化的理解</h4><p>就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式 CSS 情况下也以⼀种⽂档格式显示，容易阅读。 搜索引擎的爬⾍依赖于标记来确定上下⽂和各个关键字的权重，利于 SEO 。 </p>
<h4 id="HTML块元素标签、行内元素标签都有哪些？"><a href="#HTML块元素标签、行内元素标签都有哪些？" class="headerlink" title="HTML块元素标签、行内元素标签都有哪些？"></a><code>HTML</code>块元素标签、行内元素标签都有哪些？</h4><p>块级元素 div  p  ul  li  table  h1 h2 h3 … h6  form 等  可以设置宽高  独占一行</p>
<p>行内元素 span  a  i  label  img  input  button  textarea select 等   不能设置宽高 不独占一行</p>
<p>行内块元素  综合了行内元素和块状元素的特性   就是不独占一行的块级元素 </p>
<h4 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h4><ul>
<li><p>用于绘画的 canvas 元素</p>
</li>
<li><p>用于媒介回放的 video 和 audio 元素</p>
</li>
<li>对本地离线存储的更好的支持</li>
<li>新的特殊内容元素，比如 article、footer、header、nav、section</li>
<li>新的表单控件，比如 calendar、date、time、email、url、search</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>坚持学习，坚持写博客，记录学习的点点滴滴！</title>
    <url>/2018/07/10/%E5%9D%9A%E6%8C%81%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%9D%9A%E6%8C%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%81/</url>
    <content><![CDATA[<p>还是太懒了，没有规划，没有目标，缺乏毅力！</p><p>长话短说，想成为一个优秀的程序员，还是需要不断的努力，不断的锤炼，不能懈怠！</p><p>从现在开始坚持学习，坚持写博客，记录学习的点点滴滴！</p>]]></content>
  </entry>
  <entry>
    <title>前端面试题整理（CSS篇）</title>
    <url>/2018/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88CSS%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h4 id="介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同"><a href="#介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同" class="headerlink" title="介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同"></a>介绍一下标准的<code>css</code>的盒子模型？低版本IE的盒子模型有什么不同</h4><p> 一个基本的盒模型，包括<code>content(width/height)</code>，<code>padding</code>，<code>border</code>，<code>margin</code> </p><p> 有两种盒子模型，<code>IE</code>盒模型和<code>W3C</code>标准盒模型，</p><p>两者的区别：<code>W3C</code>标准盒模型，宽高是只有内容<code>content</code>，没有<code>padding</code>和<code>border</code>的， 而<code>IE</code>盒模型，宽高不光有<code>content</code>，还包含了<code>padding</code>和<code>border</code></p><a id="more"></a>


<p>怎么设置<code>w3c</code>盒模型和<code>ie</code>盒模型？           </p>
<p><code>box-sizing</code>用来控制元素的盒子模型的解析模式 </p>
<p><code>box-sizing: content-box</code>;　　// <code>W3C</code>标准盒模型（默认情况下）</p>
<p><code>box-sizing: border-box</code>;　　// <code>IE</code>盒模型</p>
<p>（这个也比较好记，标准的就是只有内容，就是<code>content</code>，而<code>IE</code>就是有<code>border</code>的）</p>
<h4 id="display-none与visibility-hidden的区别？"><a href="#display-none与visibility-hidden的区别？" class="headerlink" title="display:none与visibility:hidden的区别？"></a><code>display:none</code>与<code>visibility:hidden</code>的区别？</h4><p><code>display</code>: 隐藏对应的元素但不挤占该元素原来的空间。 </p>
<p><code>visibility</code>: 隐藏对应的元素并且挤占该元素原来的空间。 </p>
<h4 id="为什么要初始化样式-？"><a href="#为什么要初始化样式-？" class="headerlink" title="为什么要初始化样式 ？"></a>为什么要初始化样式 ？</h4><p> 由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异但是初始化<code>CSS</code>会对搜索引擎优化造成小影响。</p>
<h4 id="CSS选择符有哪些？"><a href="#CSS选择符有哪些？" class="headerlink" title="CSS选择符有哪些？"></a>CSS选择符有哪些？</h4><ul>
<li><code>id</code>选择器(<code>#myid</code>)</li>
<li>类选择器(<code>.myclassName</code>)</li>
<li>标签选择器(<code>div,h1,p</code>)</li>
<li>子代选择器(<code>ul&gt;li</code>)</li>
<li>后代选择器(<code>li a</code>)</li>
<li>多元素选择器(<code>div,p</code>)同时选择多种元素</li>
<li>相邻选择器(<code>div+p</code>) 选择相邻兄弟的第一个元素</li>
<li>兄弟选择器(<code>div~p</code>)选择相邻的所有兄弟<code>p</code>元素</li>
<li>通配符选择器(<code>*</code>)</li>
<li>属性选择器(<code>a[rel=&quot;external&quot;]</code>)</li>
<li>伪类选择器(<code>a:hover,li:nth-child</code>)</li>
</ul>
<h4 id="为什么需要清浮动？清浮动的方式"><a href="#为什么需要清浮动？清浮动的方式" class="headerlink" title="为什么需要清浮动？清浮动的方式"></a>为什么需要清浮动？清浮动的方式</h4><p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，就需要在该元素中清除浮动，准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong>。</p>
<p>清浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使页面后面的布局不能正常显示</p>
<ul>
<li>父级<code>div</code>定义<code>height</code></li>
<li>在浮动元素后面添加<code>class</code>为<code>clear</code>的空<code>div</code>元素，给这个div设置样式<code>.clear{clear:both}</code></li>
<li>给父容器添加<code>overflow:hidden</code>或者<code>auto</code>样式</li>
<li>给父容器添加<code>clearfix</code>的<code>class</code>，用伪类<code>clearfix:after</code>；来这个样式。清除浮动</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    <span class="attribute">zoom</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'.'</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是外边距合并"><a href="#什么是外边距合并" class="headerlink" title="什么是外边距合并"></a>什么是外边距合并</h4><p>外边距合并指的是，当两个垂直外边距相遇时，他们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中较大者 </p>
<h4 id="如何获取盒子的宽高？"><a href="#如何获取盒子的宽高？" class="headerlink" title="如何获取盒子的宽高？"></a>如何获取盒子的宽高？</h4><p> 我们用得最多的就是<code>dom.offsetWidth  dom.offsetHeight</code>，这个包含了<code>width/height</code>，<code>padding</code>和<code>border</code>，是项目中最常用的，兼容性也最好，记住这个就行了 </p>
<h4 id="列举一些常用的伪类或伪元素？"><a href="#列举一些常用的伪类或伪元素？" class="headerlink" title="列举一些常用的伪类或伪元素？"></a>列举一些常用的伪类或伪元素？</h4><p><strong>伪类</strong>：（大部分都是<code>CSS3</code>里新增的）</p>
<p>: <code>hover</code> 鼠标hover</p>
<p>: <code>nth-child(n)</code>  选中父元素下的第<code>n</code>个子元素</p>
<p>: <code>not()</code>  不是什么什么</p>
<p>: <code>first-child</code>  第一个子元素</p>
<p>: <code>last-child</code>  最后一个子元素</p>
<p>: <code>checked</code>  单选框或复选框被选中的</p>
<p><strong>伪元素</strong>：</p>
<p>:: <code>before</code></p>
<p>:: <code>after</code></p>
<h4 id="选择器权重计算比较？"><a href="#选择器权重计算比较？" class="headerlink" title="选择器权重计算比较？"></a>选择器权重计算比较？</h4><p>一般讨论四种选择器：</p>
<p>元素或伪元素(::)  （x，x，x，0）</p>
<p>class选择符或伪类(:)   （x，x，0，x）</p>
<p>id选择符  （x，0，x，x）</p>
<p>标签内选择符  （0，x，x，x）</p>
<p>通常计算方法就是每出现一个，就在对应的权位上加<code>1</code>，不可进位，两个选择器比较权重就是从首位开始比较，数字相同的话就比较下一个。</p>
<p><code>!important</code>权位最高，不在讨论范围内，可以理解为  （1，x，x，x，x）</p>
<p>相同都有<code>!important</code>，就看谁在后面</p>
<h4 id="如何居中一个div？"><a href="#如何居中一个div？" class="headerlink" title="如何居中一个div？"></a>如何居中一个div？</h4><p><strong>水平居中：利用margin属性</strong></p>
<p> 给 <code>div</code> 设置一个宽高，然后添加 <code>margin:0 auto</code> 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; </span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>; </span><br><span class="line"><span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">margin:0 auto;//上下为0 左右自适应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>水平垂直居中</strong></p>
<p>让left和top都是50%，这在水平方向上让div的最左与屏幕的最左相距50%，垂直方向上一样，所以再用transform向左（上）平移它自己宽度（高度）的50%，也就达到居中效果了 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>:-<span class="number">100px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">150px</span>;<span class="comment">/*或者下面一样效果*/</span></span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用flex弹性盒子</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>; <span class="comment">/*垂直方向居中*/</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;  <span class="comment">/*水平方向居中*/</span></span><br></pre></td></tr></table></figure>
<h4 id="CSS中定位的方式有哪些？position属性的值有哪些？"><a href="#CSS中定位的方式有哪些？position属性的值有哪些？" class="headerlink" title="CSS中定位的方式有哪些？position属性的值有哪些？"></a>CSS中定位的方式有哪些？position属性的值有哪些？</h4><ul>
<li>默认值：initial（浏览器默认值）</li>
<li>继承父级元素的定位机制：inherit</li>
<li>默认：static</li>
<li>相对定位：relative</li>
<li>绝对定位：absolute（注意<code>z-index</code>）</li>
<li>固定定位：fixed</li>
<li><p>粘性定位：sticky该定位基于用户滚动的位置。</p>
</li>
<li><p><strong>initial</strong>：设置该属性为浏览器默认值</p>
</li>
<li><p><strong>inherit</strong> ：规定应该从父元素继承 position 属性的值。</p>
</li>
</ul>
<ul>
<li><p>static</p>
<p> ：默认值。</p>
<ul>
<li>没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 </li>
</ul>
</li>
<li><p>relative</p>
<p> ：生成相对定位的元素，相对于其正常位置进行定位。</p>
<ul>
<li>因此，“left:20” 会向元素的 LEFT 位置添加 20 像素。</li>
</ul>
</li>
<li><p>absolute</p>
<p>： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p>
<ul>
<li>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li>
</ul>
</li>
<li><p>fixed</p>
<p> ：生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
<ul>
<li>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed旧版本IE不支持</li>
</ul>
</li>
<li><p>sticky</p>
<ul>
<li>粘性定位，该定位基于用户滚动的位置。（特定阈值指的是 top, right, bottom 或 left 之一）<ul>
<li>它的行为就像 position:relative; 而当页面滚动超出目标区域时，</li>
<li>它的表现就像 position:fixed;，它会固定在目标位置。</li>
<li>注意: Internet Explorer, Edge 15 及更早 IE 版本不支</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="display有哪些值？说明他们的作用"><a href="#display有哪些值？说明他们的作用" class="headerlink" title="display有哪些值？说明他们的作用"></a>display有哪些值？说明他们的作用</h4><p><strong>display 显示状态有:</strong></p>
<p><strong>none</strong> 隐藏，此元素不会被显示。</p>
<p><strong>block</strong> 块显示；此元素将显示为块级元素，此元素前后会带有换行符。</p>
<p><strong>inline</strong> 内嵌 ，默认。此元素会被显示为内联元素，元素前后没有换行符。</p>
<p><strong>table</strong> 表格显示，此元素会作为块级表格来显示（类似 <code></code>），表格前后带有换行符。</p>
<p><strong>inline-block</strong>：元素既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。</p>
<p><strong>list-item</strong>:象块类型元素一样显示，并添加样式列表标记。</p>
<p><strong>inherit</strong> 规定应该从父元素继承 display 属性的值</p>
<h4 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h4><ul>
<li>CSS3实现圆角（border-radius），阴影（box-shadow），</li>
<li>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li>
<li>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</li>
<li>增加了更多的CSS选择器  多背景 rgba </li>
<li>在CSS3中唯一引入的伪元素是 <code>::selection</code>.</li>
<li>媒体查询，多栏布局</li>
<li>border-image</li>
</ul>
<h4 id="CSS3新增伪类有哪些？"><a href="#CSS3新增伪类有哪些？" class="headerlink" title="CSS3新增伪类有哪些？"></a>CSS3新增伪类有哪些？</h4><p>CSS3新增伪类举例：</p>
<ul>
<li>p:first-of-type 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素。</li>
<li>p:last-of-type 选择属于其父元素的最后<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素。</li>
<li>p:only-of-type 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li>
<li>p:only-child  选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li>
<li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li>
<li>:enabled、:disabled 控制表单控件的禁用状态。</li>
<li>:checked，单选框或复选框被选中。</li>
<li>:after 在元素之前添加内容,也可以用来做清除浮动。</li>
<li>:before 在元素之后添加内容</li>
<li>:enabled</li>
<li>:disabled 控制表单控件的禁用状态。</li>
<li>:checked 单选框或复选框被选中。</li>
</ul>
<h4 id="margin的上下左右四个数值？"><a href="#margin的上下左右四个数值？" class="headerlink" title="margin的上下左右四个数值？"></a>margin的上下左右四个数值？</h4><p>margin属性的四个值                                                   <strong>上  右  下  左</strong></p>
<p>如果有三个值，那左右相同（左取的是第二个值）   <strong>上     左右     下</strong></p>
<p>如果有两个值，那上下相同，左右相同                      <strong>上下   左右</strong></p>
<p>如果有一个值，那四面相同                                          <strong>上右下左</strong></p>
<h4 id="对line-height是如何理解的？"><a href="#对line-height是如何理解的？" class="headerlink" title="对line-height是如何理解的？"></a>对line-height是如何理解的？</h4><p>基线位置是由字体确定的，css的line-height指的是一行字的高度，包含了字间距，实际上就是下一行的基线到上一行的基线距离。</p>
<p>line-height的值跟height的值一样，字体就会垂直居中;</p>
<h4 id="解释下CSS-sprites是什么？"><a href="#解释下CSS-sprites是什么？" class="headerlink" title="解释下CSS sprites是什么？"></a>解释下CSS sprites是什么？</h4><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中， 将多个⼩图⽚拼接到⼀个图⽚中。通过 background-position 和元素尺⼨调节需要显示的背景图案。 </p>
<p>再利用 CSS 的”background-image”，“background-repeat”，“background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。</p>
<p>这样可以减少很多图片请求的开销，因为请求耗时比较长；</p>
<h4 id="抽离样式模块怎么写，说出思路，有无实践经验？"><a href="#抽离样式模块怎么写，说出思路，有无实践经验？" class="headerlink" title="抽离样式模块怎么写，说出思路，有无实践经验？"></a>抽离样式模块怎么写，说出思路，有无实践经验？</h4><p>首一个成熟的网站需要有统一的风格，一致的用户体验，比如：网站的配色，字体的大小，交互行为一致等应该在设计之初就得到确定，而不是由个体开发者来自由的定义。</p>
<p>网站同时应存在可以提取出来公用的样式部分。那么我们就可以把网站的字体大小，公共控制，共用模块的样式都抽离出来，作为单独的模块来处理。</p>
<p>这样，团队中的每个人如果需要这样的样式，都可以用这种公共样式，以此提高代码的重用率。</p>
<p>我认为一个项目的CSS可以拆分成2部分：公共CSS和业务CSS。</p>
<p>我们在项目中抽出的这部分可以模块化的CSS就可以归类为公共CSS。</p>
<p>这部分的代码命名不应涉及到具体的业务，只应对其在模块中负责的具体逻辑负责。</p>
<p>对于业务CSS，我们需要有统一的命名。如一个网站中有如下几个栏目：文件，社区，社交关系等，在项目规划时，就需要把这块模块的名称定好，</p>
<p>比如 文件-files,社区-cmty(community简写)，这样开发人员在写样式时，就可以使用公用的前缀，.cmty-cmtydetail，而不会根据各自的想法，</p>
<p>写成.community或是.commu，这一点对于统一风格是尽为重要的，也方便备用人员接手工作。</p>
<h4 id="base64有什么好处，base64有什么缺点？"><a href="#base64有什么好处，base64有什么缺点？" class="headerlink" title="base64有什么好处，base64有什么缺点？"></a>base64有什么好处，base64有什么缺点？</h4><p>什么时候用，一般移动端的大的背景图会用base64，而且图片体积比较大的时候才会用base64；</p>
<p>如果图片比较小，那么base64编码后的字符串会比图片本身还大，只有图片打到几百K的时候，</p>
<p>用base64编码会大大缩小图片的体积；</p>
<p><strong>优点</strong>：能够减小大图片的尺寸，同时还能够减少HTTP请求数量；HTTP请求是非常耗费服务器资源的；</p>
<h4 id="JS为什么会放在下面，CSS为什么放在上面"><a href="#JS为什么会放在下面，CSS为什么放在上面" class="headerlink" title="JS为什么会放在下面，CSS为什么放在上面"></a>JS为什么会放在下面，CSS为什么放在上面</h4><p>浏览器从上到下依次解析html文档。</p>
<p>将 css 文件放到头部， css 文件可以先加载。避免先加载 body 内容，导致页面一开始样式错乱，然后闪烁。</p>
<p>将 javascript 文件放到底部是因为：若</p>
<p>将 javascript 文件放到 head 里面，就意味着必须等到所有的 javascript 代码都被 下载、解析和执行完成 之后才开始呈现页面内容。</p>
<p>这样就会造成呈现页面时出现明显的延迟，窗口一片空白。</p>
<p>为避免这样的问题一般将全部 javascript 文件放到 body 元素中页面内容的后面。</p>
<h4 id="rgba-和opacity的透明效果有什么不同？"><a href="#rgba-和opacity的透明效果有什么不同？" class="headerlink" title="rgba()和opacity的透明效果有什么不同？"></a>rgba()和opacity的透明效果有什么不同？</h4><ul>
<li>rgba() 和 opacity 都能实现透明效果，但最⼤的不同是 opacity 作⽤于元素，以及元素内的所有内容的透明度，</li>
<li>⽽ rgba() 只作⽤于元素的颜⾊或其背景⾊。（设置 rgba 透明的元素的⼦元素不会继承透明效果！</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>清除浮动的方式</title>
    <url>/2018/06/02/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="为什么要清除浮动？怎么清除浮动？"><a href="#为什么要清除浮动？怎么清除浮动？" class="headerlink" title="为什么要清除浮动？怎么清除浮动？"></a>为什么要清除浮动？怎么清除浮动？</h1><p><strong>产生原因</strong>：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生<strong>高度塌陷</strong>的情况。</p><p><strong>带来的负作用</strong>：</p><ol>
<li><strong>背景</strong>不能显示</li>
<li><strong>边框</strong>不能撑开</li>
<li><strong>margin和padding值</strong>不能正确显示</li>
</ol><p><strong>清除浮动的方法</strong>：</p><ol>
<li><p>给<strong>父盒子</strong>设置合适的<strong>高度、border、padding</strong>；</p>
</li>
<li><p>【推荐】给<strong>父盒子添加样式 <code>overflow:hidden/auto;</code></strong></p>
<p>（这个属性相当于触发BFC，让父级紧贴内容，包括使用了浮动的盒子）</p>
<p>（为了去除兼容性问题，会添加<code>zoom:1;</code>）</p>
</li>
<li><p>在父盒子里面的子盒子后面<strong>添加一个子盒子</strong>，如div，<strong>添加样式 <code>.clear{ clear:both; }</code>；</strong></p>
</li>
<li><p>采用<strong>伪元素，给父元素追加<code>:after</code></strong>，给父元素添加一个类<code>.clearfix{content:&quot;&quot;;clear:both;}</code></p>
</li>
</ol><a id="more"></a>




<p><strong>BFC块级格式化上下文的特征</strong>：</p>
<ul>
<li><p>内部的Box会在<strong>垂直方向</strong>，从顶部开始<strong>一个接一个</strong>地放置；</p>
</li>
<li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个<strong>相邻Box的margin会发生叠加</strong>。</p>
</li>
<li><p>每个元素的margin box的左边， <strong>与包含块</strong>border box的<strong>左边相接触</strong>，即使存在浮动也是如此。</p>
</li>
<li><p>BFC的区域不会与float box叠加。</p>
</li>
<li><p>BFC就是页面上的一个<strong>隔离的独立容器</strong>，容器里面的子元素<strong>不会影响到外面的元素</strong>，反之亦然。</p>
</li>
<li><p>计算BFC的高度时，<strong>浮动元素也参与计算</strong>。</p>
</li>
</ul>
<p>注意：块格式化上下文<strong>包含创建它的元素内部的所有内容</strong>；<strong>创建块级格式化上下文</strong>：</p>
<ul>
<li><strong>浮动</strong> (元素的 float不为 none）</li>
<li><strong>绝对定位元素</strong> (元素的 position为 absolute 或 fixed)</li>
<li><strong>行内块</strong> inline-blocks (元素的 display: inline-block)</li>
<li><strong>表格单元格</strong> (元素的 display: table-cell，HTML表格单元格默认属性)</li>
<li><strong>表格标题</strong> (元素的 display: table-caption，HTML表格标题默认属性)</li>
<li><strong>overflow的值不为 visible的元素</strong>(元素的 overflow: hidden，overflow: auto)</li>
<li><strong>弹性盒</strong>子 flex boxes (元素的 display: flex 或 inline-flex)</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>前端面试题整理（js篇）</title>
    <url>/2021/06/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88js%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h4 id="JavaScript-中有几种数据类型"><a href="#JavaScript-中有几种数据类型" class="headerlink" title="JavaScript 中有几种数据类型"></a>JavaScript 中有几种数据类型</h4><p><strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><p> 基本数据类型 ：<code>String</code>、<code>Number</code>、<code>Boolean</code> 、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code> ; </p><p> 引用数据类型：<code>Object</code>; </p><p><strong>不同类型的数据储存原理</strong></p><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</p><a id="more"></a>




<p>堆：引用数据类型（对象、数组和函数）</p>
<p><strong>两种类型的区别是：存储位置不同</strong></p>
<p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
<p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</p>
<p>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<h4 id="JavaScript-什么叫全局变量-什么叫局部变量了-是如何定义出来的"><a href="#JavaScript-什么叫全局变量-什么叫局部变量了-是如何定义出来的" class="headerlink" title="JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?"></a>JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?</h4><p>全局变量是在函数外部定义的变量,在JS中全局变量属于window对象</p>
<p>局部变量是相对与全局变量而言的,在特定过程或函数中可以访问的变量,作用域较小,当函数运行结束释放局部变量</p>
<h4 id="var-和-let-const-的区别"><a href="#var-和-let-const-的区别" class="headerlink" title="var 和 let const 的区别"></a>var 和 let const 的区别</h4><ul>
<li>var 是 ES5 语法， let const 是 ES6 语法； var 有变量提升  ; let 、const存在一个暂时性死区（暂时性死区：创建了变量但是没有初始化，没法使用变量，“Cannot access ‘value’ before initialization”），  let在变量声明之前就访问变量的话，会直接提示 ReferenceError，而不像 var 那样使用默认值 undefined: </li>
<li>var 和 let 是变量，可修改；const 是常量，不可修改</li>
<li>let const 有块级作用域（ES6），var 没有</li>
<li>var 可以重复声明同一个变量，let、const不能</li>
<li>var声明的变量会挂载在window上，而let和const声明的变量不会  </li>
</ul>
<h4 id="typeof-返回哪些类型"><a href="#typeof-返回哪些类型" class="headerlink" title="typeof 返回哪些类型"></a>typeof 返回哪些类型</h4><ul>
<li>值类型：<code>undefined</code> <code>string</code> <code>number</code> <code>boolean</code> <code>symbol</code></li>
<li>引用类型：<code>object</code> (注意： typeof null === ‘object’)</li>
<li>函数类型：<code>function</code></li>
</ul>
<h4 id="列举强制类型转换和隐式类型转换"><a href="#列举强制类型转换和隐式类型转换" class="headerlink" title="列举强制类型转换和隐式类型转换"></a>列举强制类型转换和隐式类型转换</h4><ul>
<li>强制：<code>parseInt</code> <code>parseFloat</code> <code>toString</code> 等</li>
<li>隐式：<code>if</code> <code>逻辑运算</code> <code>==</code> <code>+拼接字符串</code></li>
</ul>
<h4 id="split-和-join-的区别？"><a href="#split-和-join-的区别？" class="headerlink" title="split() 和 join() 的区别？"></a>split() 和 join() 的区别？</h4><p>split()方法用于把一个字符串分割成字符串数组</p>
<p>join() 方法用于把数组中的所有元素放入一个字符串</p>
<p><strong>String.split() 执行的操作与 Array.join() 执行的操作是相反的</strong></p>
<h4 id="数组的-pop-push-unshift-shift-分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？"><a href="#数组的-pop-push-unshift-shift-分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？" class="headerlink" title="数组的 pop push unshift shift 分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？"></a>数组的 pop push unshift shift 分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？</h4><p><strong>pop</strong></p>
<ul>
<li>删除数组末尾元素</li>
<li>返回删除元素</li>
<li>改变原数组</li>
</ul>
<p><strong>push</strong></p>
<ul>
<li>向数组末尾添加元素</li>
<li>返回数组长度</li>
<li>改变原数组</li>
</ul>
<p><strong>shift</strong></p>
<ul>
<li>删除数组首个元素</li>
<li>返回被删除元素</li>
<li>改变原数组</li>
</ul>
<p><strong>unshift</strong></p>
<ul>
<li>向数组首位添加元素</li>
<li>返回数组长度</li>
<li>改变原数组</li>
</ul>
<h4 id="数组的API-有哪些是纯函数？-（不对外界产生副作用的函数就叫纯函数）"><a href="#数组的API-有哪些是纯函数？-（不对外界产生副作用的函数就叫纯函数）" class="headerlink" title="数组的API,有哪些是纯函数？  （不对外界产生副作用的函数就叫纯函数）"></a><strong>数组的API,有哪些是纯函数？</strong>  （不对外界产生副作用的函数就叫纯函数）</h4><p><code>concat</code> <code>map</code> <code>filter</code> <code>slice</code> 就是纯函数，它们具有以下特点：</p>
<p>不改变源数组（没有副作用）；返回一个数组</p>
<p>concat()把当前的数组和另一个数组合并为一个新的数组 </p>
<p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 </p>
<p>filter()  过滤数组，返回符合条件的值 </p>
<p>slice() 拷贝数组从start到end(不包括end)的值，返回一个新数组，不会对源数组进行改变 </p>
<h4 id="数组-slice-和-splice-区别"><a href="#数组-slice-和-splice-区别" class="headerlink" title="数组 slice 和 splice 区别"></a>数组 slice 和 splice 区别</h4><p>slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。 （该方法不会改变原数组） </p>
<p>splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法会改变原数组） </p>
<p>splice（index,howmany,item1,…itemX）</p>
<ul>
<li>index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。</li>
<li>howmany参数：必须，要删除的数量，如果为0，则不删除项目。</li>
<li>tem1,…itemX参数：可选，向数组添加的新项目。</li>
</ul>
<h4 id="call-apply-bind-作用和区别"><a href="#call-apply-bind-作用和区别" class="headerlink" title="call() apply() bind() 作用和区别"></a>call() apply() bind() 作用和区别</h4><p><strong>相同点</strong></p>
<ul>
<li>改变对象的执行上下文(总的来说，就是改变this的指向)。<br>this关键字，就是所谓的执行上下文。this关键字在函数中，表示的是一个指向，this的指向永远是一个对象。</li>
<li>都可以指定调用实参。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>call()和bind()的参数是直接连续传递，而apply传递参数是以一个数组传递。</li>
<li>bind()会返回一个方法。</li>
</ul>
<h4 id="事件代理（委托）是什么？"><a href="#事件代理（委托）是什么？" class="headerlink" title="事件代理（委托）是什么？"></a>事件代理（委托）是什么？</h4><p>事件代理就是，本来加在子元素身上的事件，加在了其父级身上 </p>
<p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素 </p>
<p>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p>
<ul>
<li>减少整个页面所需的内存，提升整体性能</li>
<li>动态绑定，减少重复工作</li>
</ul>
<p>效率高，比如，不用for循环为子元素添加事件了     </p>
<p>js新生成的子元素也不用新为其添加事件了，程序逻辑上比较方便</p>
<p><strong>使用事件委托注意事项</strong></p>
<p>使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。</p>
<h4 id="闭包是什么？有什么特性？有什么负面影响？"><a href="#闭包是什么？有什么特性？有什么负面影响？" class="headerlink" title="闭包是什么？有什么特性？有什么负面影响？"></a>闭包是什么？有什么特性？有什么负面影响？</h4><p> 闭包就是能够读取其他函数内部变量的函数。 </p>
<p> 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁 </p>
<p>子函数可以一层一层读取到父元素的变量，反之不行。但假如我们需要得到函数内的局部变量，正常操作是：在函数的内部再定义一个函数，该函数称之为闭包,通过闭包，向上去读取父函数的局部变量。闭包的作用：读取局部变量；让局部变量的值始终保存在内存中。 </p>
<p><strong>由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</strong></p>
<p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 </p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 </p>
<h4 id="如何阻止事件冒泡和默认事件？"><a href="#如何阻止事件冒泡和默认事件？" class="headerlink" title="如何阻止事件冒泡和默认事件？"></a>如何阻止事件冒泡和默认事件？</h4><p>阻止事件冒泡</p>
<p>e. stopPropagation()   <strong>事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转</strong></p>
<p>阻止默认事件</p>
<p>return false      <strong>事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转） </strong></p>
<p>e.preventDefault()    <strong>事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） </strong></p>
<h4 id="查找，添加，删除，移动DOM节点的方法"><a href="#查找，添加，删除，移动DOM节点的方法" class="headerlink" title="查找，添加，删除，移动DOM节点的方法"></a>查找，添加，删除，移动DOM节点的方法</h4><p><strong>在HTML当中，一切都是节点</strong>：（非常重要）</p>
<ul>
<li><strong>元素节点</strong>：HMTL标签。</li>
<li><strong>文本节点</strong>：标签中的文字（比如标签之间的空格、换行）</li>
<li><strong>属性节点</strong>：：标签的属性。</li>
</ul>
<p>整个html文档就是一个文档节点。所有的节点都是Object。</p>
<p><strong>访问/获取节点</strong></p>
<p>document.getElementById(id);　　　　　　　　 　　//返回对拥有指定id的第一个对象进行访问</p>
<p>document.getElementsByName(name);　　　　　　//返回带有指定名称的节点集合　　 注意拼写:Elements</p>
<p>document.getElementsByTagName(tagname); 　　//返回带有指定标签名的对象集合　 注意拼写：Elements</p>
<p>document.getElementsByClassName(classname); //返回带有指定class名称的对象集合 注意拼写：Elements</p>
<p><strong>创建节点/属性</strong></p>
<p>document.createElement(eName);　　//创建一个节点</p>
<p>document.createAttribute(attrName); //对某个节点创建属性</p>
<p>document.createTextNode(text);　　　//创建文本节点</p>
<p><strong>添加节点</strong></p>
<p> document .insertBefore(新的子节点,参考节点);</p>
<p>解释：</p>
<ul>
<li><p>在参考节点前插入一个新的节点。</p>
</li>
<li><p>如果参考节点为null，那么他将在父节点最后插入一个子节点。</p>
</li>
</ul>
<p>父节点.appendChild(新的子节点);　　　　　// 解释：父节点的最后插入一个新的子节点。 </p>
<p><strong>复制节点</strong></p>
<p>cloneNode(true | false);　　//复制某个节点  参数：是否复制原节点的所有属性</p>
<p><strong>删除节点</strong></p>
<p>父节点.removeChild(node);　　//删除某个节点的子节点 node是要删除的节点</p>
<p>注意：为了保证兼容性，要判断元素节点的节点类型(nodeType)，若nodeType==1，再执行删除操作。通过这个方法，就可以在 IE和 Mozilla 完成正确的操作。</p>
<p>nodeType 属性可返回节点的类型.最重要的节点类型是：</p>
<table>
<thead>
<tr>
<th>元素类型</th>
<th>节点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素element</td>
<td>1</td>
</tr>
<tr>
<td>属性attr</td>
<td>2</td>
</tr>
<tr>
<td>文本text</td>
<td>3</td>
</tr>
<tr>
<td>注释comments</td>
<td>8</td>
</tr>
<tr>
<td>文档document</td>
<td>9</td>
</tr>
</tbody>
</table>
<p><strong>属性操作</strong></p>
<p>getAttribute(name)　　　　//通过属性名称获取某个节点属性的值</p>
<p>setAttribute(name,value); //修改某个节点属性的值</p>
<p>removeAttribute(name);　 //删除某个属性</p>
<p><strong>查找节点</strong></p>
<p>parentObj.firstChild;　　//如果节点为已知节点的第一个子节点就可以使用这个方法。此方法可以递归进行使用 parentObj.firstChild.firstChild…..</p>
<p>parentObj.lastChild;　　//获得一个节点的最后一个节点，与firstChild一样也可以进行递归使用 parentObj.lastChild.lastChild…..</p>
<p>parentObj.childNodes;  //获得节点的所有子节点，然后通过循环和索引找到目标节点 </p>
<p><strong>获取相邻的节点</strong></p>
<p>curtNode.previousSibling; //获取已知节点的相邻的上一个节点</p>
<p>curtNode.nextSlbling;　　 // 获取已知节点的下一个节点</p>
<p><strong>获取父节点</strong></p>
<p>childNode.parentNode;　　//得到已知节点的父节点</p>
<p><strong>替换节点</strong></p>
<p>replace(newNode,oldNode);</p>
<h4 id="document-load-和-ready-的区别"><a href="#document-load-和-ready-的区别" class="headerlink" title="document load 和 ready 的区别"></a>document load 和 ready 的区别</h4><p>load 是当前页面所有资源加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行的一个函数，<br>问题： 如果图片资源较多，加载时间较长，onload 后等待执行的函数需要等待较长时间，所以一些效果可能受到影响。<br>$(document).ready() 是当DOM 文档树加载完成后执行的一个函数（不包含图片，css 等），所以会比load 较快执行。<br>在原生的js 中不包括ready() 这个方法，只有load 方法就是onload 事件。</p>
<h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 === 的区别"></a><code>==</code> 和 <code>===</code> 的区别</h4><p>简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， </p>
<p>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.</p>
<p>操作数1 == 操作数2， 操作数1 === 操作数2</p>
<p>比较过程：</p>
<p>　　双等号==： </p>
<p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p>
<p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p>
<p>　　　　1）如果一个是null，一个是undefined，那么相等</p>
<p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</p>
<p>　　三等号===:</p>
<p>　　（1）如果类型不同，就一定不相等</p>
<p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）</p>
<p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p>
<p>　　（4）如果两个值都是true，或是false，那么相等</p>
<p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p>
<p>　　（6）如果两个值都是null，或是undefined，那么相等</p>
<h4 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h4><p>function xxx(){}表示函数声明，可以放在代码的任何位置，也可以在任何地方成功调用；</p>
<p>var xxx = function(){};表示函数表达式，即将一个匿名函数赋值给一个变量，实现通过变量来调用这个匿名函数，但它需要在声明过后才能进行调用，如果调用在声明之前就会报如上红色字体的错误。而这在函数声明中不会出现这样的错误。</p>
<ul>
<li>将变量声明提升，只提升变量，不提升所赋的值；</li>
<li><p>将函数声明及函数内容提升，既提升函数声明，又提升函数内容，可以理解为将整个function内容提升；</p>
<p>函数声明和函数表达式相比，函数声明使用可以更加自由，可以放在随意的位置，因为它能够整体的变量提升； </p>
<p>而函数表达式使用就相对没有那么自由了，调用必须在声明的后面，因为变量提前只是将表达式的变量提前，并没有将表达式的内容提前。 </p>
</li>
</ul>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p><strong>首选ES6 提供新数据结构 Set</strong>   </p>
<p>var arr1=Array.from(new Set(arr))</p>
<p>var arr1 =[… new Set(arr)]</p>
<h4 id="JavaScript-创建对象的几种方式？"><a href="#JavaScript-创建对象的几种方式？" class="headerlink" title="JavaScript 创建对象的几种方式？"></a>JavaScript 创建对象的几种方式？</h4><p><strong>1、使用对象字面量创建</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person = &#123;</span><br><span class="line">  name:&apos;小白&apos;,</span><br><span class="line">  age:23,</span><br><span class="line">  say: function() &#123;</span><br><span class="line">    console.log(&apos;我是：&apos; + this.name); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say();  // 我是：小白</span><br></pre></td></tr></table></figure>
<p>使用同一个接口创建很多对象，会产生大量的重复代码。比如我想再创建一个Person2对象，我就得把上面的代码再重新写一遍，改变不同的属性值</p>
<p><strong>2、使用工厂模式创建对象</strong> </p>
<p>工厂模式抽象了创建具体对象的过程。由于在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age, job) &#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.say = function() &#123;</span><br><span class="line">    console.log(&apos;say&apos; )</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createPerson(&apos;name&apos;,29)</span><br><span class="line">person1.say();</span><br></pre></td></tr></table></figure>
<p>函数createPerson()能够根据接受到的参数来构建一个包含所有必要信息的Person对象。可以无数次的调用这个函数，而每次它都会返回一个包含三个属性和一个方法的对象。<br>缺点：工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）</p>
<p>创建createPerson的时候，返回的是一个对象，那么我们就无法判断返回的对象究竟是一个什么样的类型。于是出现了使用构造函数创建对象。 </p>
<p><strong>3、使用构造函数创建对象</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.say = function() &#123;</span><br><span class="line">  console.log(this.name + &apos;:&apos; + this.age + &apos;岁&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;小白&apos;, &apos;12&apos;);</span><br><span class="line">person1.say();     // 小白:12岁</span><br><span class="line">var person2 =  new Person(&apos;小花&apos;, &apos;11&apos;);</span><br><span class="line">person2.say();     // 小花:11岁</span><br></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。而这正是构造函数模式胜过工厂模式的地方。<br>然而，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在上面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例，创建两个完成同样任务的Function实例的确没有必要<br><strong>4、原型模式</strong></p>
<p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有的对象实例共享他所包含的属性和方法。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;zhang&apos;;</span><br><span class="line">Person.prototype.age = &apos;22&apos;;</span><br><span class="line">Person.prototype.job = &apos;html5&apos;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br></pre></td></tr></table></figure>
<p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由共享的本性所导致的。<br>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说的过去，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然后，对于包含引用类型的属性来说，问题就比较突出了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype  = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    name:&apos;zhang&apos;,</span><br><span class="line">    age :&apos;22&apos;,</span><br><span class="line">    job :&apos;html5&apos;,</span><br><span class="line">    friends:[&apos;wang&apos;,&apos;li&apos;],</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(&apos;zhao&apos;);</span><br><span class="line">alert(person1.friends);  //&apos;wang,li,zhao&apos;</span><br><span class="line">alert(person2.friends); //&apos;wang,li,zhao&apos;</span><br><span class="line">alert(person1.friends === person2.friends);  //true</span><br></pre></td></tr></table></figure>
<p>从上面的打印的结果我们就可以知道为什么很少人单独使用原型模式了，实例一般都是要有属于自己的全部属性的。</p>
<p><strong>5、组合使用构造函数模式和原型模式</strong></p>
<p>组合使用构造函数模式和原型模式，是创建自定义类型的最常见方式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name= name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&apos;wang&apos;,&apos;li&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;zhang&apos;,26,&apos;java&apos;,);</span><br><span class="line">var person2 = new Person(&apos;sun&apos;,25,&apos;php&apos;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&apos;zhao&apos;);</span><br><span class="line">alert(person1.friends);  //&apos;wang,li,zhao&apos;</span><br><span class="line">alert(person2.friends); //&apos;wang,li&apos;</span><br><span class="line">alert(person1.friends === person2.friends);  //false</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法satName()则是在原型中定义的。而修改了person1.friends(向其中添加一个新字符串)，并不会影响到person2.friends，因为他们分别引用了不同的数组。</p>
<h4 id="document-write-和innerHTML的区别"><a href="#document-write-和innerHTML的区别" class="headerlink" title="document.write()和innerHTML的区别"></a>document.write()和innerHTML的区别</h4><p>主要区别：document.write是直接将内容写入页面的内容流，会导致页面全部重绘，</p>
<p>innerHTML将内容写入某个DOM节点，不会导致页面全部重绘 </p>
<h4 id="js原型和原型链都是什么？"><a href="#js原型和原型链都是什么？" class="headerlink" title="js原型和原型链都是什么？"></a>js原型和原型链都是什么？</h4><p> <strong>实例的构造函数属性（constructor）=&gt; 指向构造函数。</strong> </p>
<p><strong>实例的隐式原型指向它构造函数的显式原型，指向的意思是恒等于</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例.__proto__ === 构造函数.prototype</span><br></pre></td></tr></table></figure>
<p><strong>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的<strong>proto</strong>属性中调用查找，也就是它构造函数的prototype中调用查找</strong>。 </p>
<p><strong>什么是原型链？</strong></p>
<p>原型链的核心就是依赖对象的<strong><strong> proto </strong></strong>的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有<strong> proto </strong>指向了。</p>
<p><strong>如何分析原型链?</strong></p>
<p>因为<strong>_ _proto </strong>实质找的是prototype，所以我们只要找这个链条上的构造函数的prototype。其中Object.prototype是没有 <strong> proto </strong> 属性的，等于null。</p>
<ul>
<li>所有引用类型都有一个<code>__proto__</code>(隐式原型)属性，属性值是一个普通的对象</li>
<li>所有函数都有一个prototype(原型)属性，属性值是一个普通的对象</li>
<li>所有引用类型的<code>__proto__</code>属性指向它构造函数的prototype</li>
</ul>
<p>函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址<br>函数的原型对象<strong>proto</strong>：所有对象都有<strong>proto</strong>属性， 当用构造函数实例化（new）一个对象时，会将新对象的<strong>proto</strong>属性指向 构造函数的prototype</p>
<p>原型链：原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<strong>proto</strong>隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的<strong>proto</strong>中查找，这样一层一层向上查找就会形成一个链式结构</p>
<p><strong>原型与原型链的常见面试题</strong></p>
<p><strong>谈谈你对原型的理解</strong>？<br>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法</p>
<p>什么是原型链？原型链解决的是什么问题？<br>1）原型链解决的主要是继承问题<br>2）每个对象拥有一个原型对象，通过 prototype 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.<strong> proto </strong>指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法<br>3）构造函数 Parent、原型对象Parent.prototype 和 实例 p 的关系如下:(p. _ proto __ === Parent.prototype)</p>
<h4 id="js实现继承的方式"><a href="#js实现继承的方式" class="headerlink" title="js实现继承的方式"></a>js实现继承的方式</h4><p><strong>原型链继承</strong></p>
<p>我们只要把子类的prototype设置为父类的实例，就完成了继承，也就是js里面的原型链继承 </p>
<p>子类.prototype = new 父类(); </p>
<p>但是原型链继承有一个缺点，就是如果属性是引用类型的话，会共享引用类型 </p>
<p>当我们改变实例1的引用类型的属性时，实例2对应的属性也会跟着更改，这就是原型链继承的缺点—引用属性会被所有实例共享。 </p>
<p><strong>借用构造函数继承</strong></p>
<p> 这里跟原型链继承有个比较明显的区别是并没有使用prototype继承，而是在子类里面执行父类的构造函数。相当于把父类的代码复制到子类里面执行一遍，这样做的另一个好处就是可以给父类传参。 </p>
<p>构造函数解决了引用类型被所有实例共享的问题，但正是因为解决了这个问题，导致一个很矛盾的问题出现了—函数也是引用类型，也没办法共享了。也就是说，每个实例里面的函数，虽然功能一样，但是却不是一个函数，就相当于我们每实例化一个子类，就复制了一遍函数代码。 </p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>继承的核心代码</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>原型继承</td>
<td>Student.prototype = new Person()</td>
<td>实例的引用类型共享</td>
</tr>
<tr>
<td>构造函数继承</td>
<td>在子类(Student)里执行Person.call(this)</td>
<td>实例的引用类型不共享</td>
</tr>
</tbody>
</table>
<p><strong>组合继承</strong></p>
<p>普通属性使用构造函数继承，函数使用原型链继承 </p>
<p>这样我们就既能实现属性的独立，又能做到函数的共享。<br>至此，我们就把js里面的常用继承了解完了，总结一下：</p>
<p>1、原型链继承，会共享引用属性<br>2、构造函数继承，会独享所有属性，包括引用属性（重点是函数）<br>3、组合继承，利用原型链继承要共享的属性，利用构造函数继承要独享的属性，实现相对完美的继承<br>继承还有其他方式，比如原型式继承、寄生式继承、寄生组合继承等。</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise的出现改变了JS的异步编程，现在基本上异步请求都是使用Promise实现。</p>
<p>Promise的出现主要是为了解决回调地狱的问题。</p>
<p>回调地狱就是多层嵌套的问题。 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性，需要多次异步请求的话，就会显得代码跳跃且乱。</p>
<p>具体的使用的话：</p>
<p>Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。</p>
<p>一个 Promise 实例有三种状态，分别是 pending、fulfilled 和 rejected，分别代表了进行中、成功和失败。实例的状态只能由进行中转变成功或者进行中转失败，并且状态一经改变，就无法再被改变了。</p>
<p>状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。</p>
<p>Promise的原型上定义了一个 then 方法， 分别是成功和失败的回调。我们可以使用这个 then 方法可以为两个状态的改变注册回调函数。</p>
]]></content>
  </entry>
  <entry>
    <title>插值表达式和v-text的区别</title>
    <url>/2018/07/16/%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cv-text%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。"><a href="#页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。" class="headerlink" title="页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。"></a>页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。</h4><p>对于这个问题Vue给予了解决办法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p v-cloak&gt; &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p> 节点中我们定义了 Vue 的内置属性 “v-cloak” </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">      <span class="selector-attr">[v-cloak]</span>&#123;</span><br><span class="line">          <span class="attribute">display</span>:none;</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了样式：包含属性“v-cloak”的节点默认隐藏</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el : <span class="string">"#app"</span>,</span><br><span class="line">            data : &#123;</span><br><span class="line">                msg : <span class="string">"Hello Vue"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建Vue对象，并与id为“app”的节点绑定。</p>
<p>这时如果再在页面访问发现：如果页面加载很慢的时候，不会再出现源代码，直接是一片空白，当Vue数据传递完成时，会正确显示数据。</p>
<p> Vue在页面数据传递时，如果一开始插值表达式获取不到数据，那么包含“v-cloak”属性的节点就会执行“display:none”样式，导致页面什么也看不到，当插值表达式获取到数据之后，就会在节点中自动移除“v-cloak”属性，这时样式也就不起作用了，展示了正常的数据。这时估计有人就会抱怨尤大神了，能一下都解决了吗？ </p>
<h4 id="指令：v-text"><a href="#指令：v-text" class="headerlink" title="指令：v-text"></a>指令：v-text</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p v-cloak&gt; &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p v-text="msg"&gt;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果完全一样，页面元素也一样。但是这时候你把网速调的很慢会发现，“v-text”这个属性在页面数据加载没完成的时候不会出现源代码。那为什么有这个了为什么还要用插值表达式？ </p>
<p>因为 v-text替换元素中所有的文本，插值表达式只替换自己，不清空元素内容 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span>----&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   //waynelee</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>----&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>          //----waynelee</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>1、如果要同时展示用户前台数据，那么就需要用插值表达式，但是不要添加“v-cloak”属性。</p>
<p>2、如果只是单独展示Vue对象里的数据，建议使用“v-text”指令。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>子盒子在父盒子中水平垂直居中的方法</title>
    <url>/2018/05/30/%E5%AD%90%E7%9B%92%E5%AD%90%E5%9C%A8%E7%88%B6%E7%9B%92%E5%AD%90%E4%B8%AD%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="子盒子在父盒子中水平垂直居中有几种方法？"><a href="#子盒子在父盒子中水平垂直居中有几种方法？" class="headerlink" title="子盒子在父盒子中水平垂直居中有几种方法？"></a>子盒子在父盒子中水平垂直居中有几种方法？</h1><h4 id="（定位、弹性盒子）"><a href="#（定位、弹性盒子）" class="headerlink" title="（定位、弹性盒子）"></a>（定位、弹性盒子）</h4><p>水平垂直居中：</p><h5 id="1-定位position-margin外边距（需要知道子盒子的宽高）"><a href="#1-定位position-margin外边距（需要知道子盒子的宽高）" class="headerlink" title="1.定位position+margin外边距（需要知道子盒子的宽高）"></a>1.定位position+margin外边距（需要知道子盒子的宽高）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父盒子*/</span><br><span class="line">position: relative;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*子盒子*/</span><br><span class="line">position: absolute;            </span><br><span class="line">top: 50%;            </span><br><span class="line">left: 50%;            </span><br><span class="line">margin-top: -50px;            </span><br><span class="line">margin-left: -50px;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h5 id="2-定位position-transform（不需要知道宽高）"><a href="#2-定位position-transform（不需要知道宽高）" class="headerlink" title="2.定位position+transform（不需要知道宽高）"></a>2.定位position+transform<strong>（不需要知道宽高）</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父盒子*/</span><br><span class="line">position: relative;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*子盒子*/</span><br><span class="line">position: absolute;            </span><br><span class="line">top: 50%;            </span><br><span class="line">left: 50%;            </span><br><span class="line">transform: translate(-50%,-50%);</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：1. 内容可变高度 2. 代码量少</p>
<p>缺点： 1. IE8不支持 2. 属性需要写浏览器厂商前缀 3. 可能干扰其他transform效果 4. 某些情形下会出现文本或元素边界渲染模糊的现象</p>
<h5 id="3-使用弹性盒子flex布局（不需要知道宽高）"><a href="#3-使用弹性盒子flex布局（不需要知道宽高）" class="headerlink" title="3.使用弹性盒子flex布局（不需要知道宽高）"></a>3.使用弹性盒子flex布局（不需要知道宽高）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父盒子*/ </span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center; </span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>
<h5 id="4-margin：auto（不需要知道宽高）"><a href="#4-margin：auto（不需要知道宽高）" class="headerlink" title="4.margin：auto（不需要知道宽高）"></a>4.margin：auto（不需要知道宽高）</h5><p>父盒子本身需要宽度；</p>
<p>设置margin自动适应，然后设置定位的上下左右都为0，就如四边均衡受力从而实现盒子的居中；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: absolute;        </span><br><span class="line"> left:0;        </span><br><span class="line"> right:0;        </span><br><span class="line"> top: 0;        </span><br><span class="line"> bottom: 0;       </span><br><span class="line"> margin: auto;</span><br></pre></td></tr></table></figure>
<p> 如果父子元素都有设置宽高：<code>margin: 150px auto;</code> </p>
<h5 id="5-table-cell"><a href="#5-table-cell" class="headerlink" title="5.table-cell"></a>5.table-cell</h5><p>将父盒子设置为table-cell(能够使元素呈单元格的样式显示)，并设置text-align: center(使内容水平居中)；vertical-align: middle(使内容垂直居中);。子盒子设置为inline-block可以使其内容变为文本格式，也可设置宽高；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father&#123;    </span><br><span class="line">	display: table-cell;    </span><br><span class="line">	width: 400px;    </span><br><span class="line">	height: 400px;    </span><br><span class="line">	vertical-align: middle;     </span><br><span class="line">	text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;    </span><br><span class="line">	display: inline-block;    </span><br><span class="line">	vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>盒模型有那些</title>
    <url>/2018/05/31/%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%9C%89%E9%82%A3%E4%BA%9B/</url>
    <content><![CDATA[<h1 id="盒模型有哪些？有什么区别？"><a href="#盒模型有哪些？有什么区别？" class="headerlink" title="盒模型有哪些？有什么区别？"></a>盒模型有哪些？有什么区别？</h1><p>盒模型分为IE盒模型和W3C标准盒模型。</p><ol>
<li><strong>W3C 标准盒模型content-box</strong>：属性width,height只包含内容content，不包含border和padding。</li>
<li><strong>IE 盒模型border-box</strong>：属性width,height包含border和padding，指的是content+padding+border。</li>
</ol><a id="more"></a>

<p><strong>box-sizing</strong>控制，默认值为<strong>content-box，即标准盒模型</strong>；<strong>border-box则用的是IE盒模型</strong></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>文字简单跑马灯效果</title>
    <url>/2018/07/17/%E6%96%87%E5%AD%97%E7%AE%80%E5%8D%95%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跑马灯效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>　　<span class="comment">&lt;!-- 页面部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"go()"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"stop()"</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!-- JS部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;</span><br><span class="line"><span class="javascript">                msg : <span class="string">'好好努力，加油加油每一天'</span>,<span class="comment">//跑马灯文字</span></span></span><br><span class="line"><span class="javascript">                interObj : <span class="literal">null</span>  <span class="comment">//定时器对象</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">               </span><br><span class="line">                go()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(<span class="keyword">this</span>.interObj == <span class="literal">null</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        _this = <span class="keyword">this</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.interObj = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        　　<span class="keyword">let</span> start = _this.msg.substring(<span class="number">0</span>,<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                        　　<span class="keyword">let</span> end = _this.msg.substring(<span class="number">1</span>);</span></span><br><span class="line">                        　　_this.msg = end + start;</span><br><span class="line">                    　　&#125;,1000);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;,</span><br><span class="line">                stop()&#123;</span><br><span class="line"><span class="javascript">                    clearInterval(<span class="keyword">this</span>.interObj);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.interObj = <span class="literal">null</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>
<p>代码分析：</p>
<p>页面上定义两个按钮，分别用来触发跑马灯效果和停止跑马灯效果。js部分分别定义了两个对象以及对应的方法。</p>
<p>1、go方法主要是使用定时器，每次把msg文本分成两个部分start和end，start为msg下标为0的字符串，end为msg下标为1至结尾的字符串，然后把end和start拼接为一个新的字符串赋值给msg，从而实现类似于跑马灯的效果。</p>
<p>2、stop方法用来清除定时器，终止跑马灯效果。</p>
<p>3、methods方法里想要使用data里的数据，需要使用关键字：this，但是这里要注意this作用域的范围。</p>
<p>4、可以看到每次改变msg文本内容的时候都会立刻反应在页面上，从侧面可以看出Vue响应式的特点。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>简单计算器实现</title>
    <url>/2018/07/19/%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p> 需要掌握JavaScript的eval()函数，其主要是用来计算某个字符串，并执行其中的 JavaScript 代码。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>计算器功能简单模拟<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"n1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"opt"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>+<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>*<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>/<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"n2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"equal"</span>&gt;</span>=<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"result"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- js代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                n1:0,</span><br><span class="line">                n2:0,</span><br><span class="line"><span class="javascript">                opt:<span class="string">'-'</span>,</span></span><br><span class="line">                result:0</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                equal()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> optStr = <span class="string">'parseInt(this.n1)'</span> + <span class="keyword">this</span>.opt + <span class="string">'parseInt(this.n2)'</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.result = <span class="built_in">eval</span>(optStr);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p> 功能很简单，核心是利用双向数据绑定的原理，实现数据实时计算。n1和n2是参与计算的变量，result是计算结果，一开始都被初始化为0，操作符被初始化为减号，通过点击等于号button触发计算方法，计算的结果会被实时显示出来。计算方法中为了实现简单使用了eval()函数，其会把字符串解析出来，按照正常的计算逻辑计算结果。 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>DAY1-2_分支结构</title>
    <url>/2021/09/27/DAY1-2/</url>
    <content><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><ul>
<li>我们的 js 代码都是顺序执行的（从上到下）</li>
<li>逻辑分支就是根据我们设定好的条件来决定要不要执行某些代码</li>
</ul><h2 id="IF-条件分支结构"><a href="#IF-条件分支结构" class="headerlink" title="IF 条件分支结构"></a>IF 条件分支结构</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><ul>
<li><p>通过一个 if 语句来决定代码执行与否</p>
</li>
<li><p>语法： <code>if (条件) { 要执行的代码 }</code></p>
</li>
<li><p>通过 <code>()</code> 里面的条件是否成立来决定 <code>{}</code> 里面的代码是否执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件为 true 的时候执行 &#123;&#125; 里面的代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  alert(<span class="string">'因为条件是 true，我会执行'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件为 false 的时候不执行 &#123;&#125; 里面的代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">	alert(<span class="string">'因为条件是 false，我不会执行'</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul><a id="more"></a>

<h3 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h3><ul>
<li><p>通过 if 条件来决定，执行哪一个 <code>{}</code> 里面的代码</p>
</li>
<li><p>语法： <code>if (条件) { 条件为 true 的时候执行 } else { 条件为 false 的时候执行 }</code></p>
</li>
<li><p>两个 <code>{}</code> 内的代码一定有一个会执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件为 true 的时候，会执行 if 后面的 &#123;&#125; </span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  alert(<span class="string">'因为条件是 true，我会执行'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'因为条件是 true，我不会执行'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件为 false 的时候，会执行 else 后面的 &#123;&#125;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  alert(<span class="string">'因为条件为 false，我不会执行'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'因为条件为 false，我会执行'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="if-else-if-…-语句"><a href="#if-else-if-…-语句" class="headerlink" title="if else if … 语句"></a>if else if … 语句</h3><ul>
<li><p>可以通过 if 和 else if 来设置多个条件进行判断</p>
</li>
<li><p>语法：<code>if (条件1) { 条件1为 true 的时候执行 } else if (条件2) { 条件2为 true 的时候执行 }</code></p>
</li>
<li><p>会从头开始依次判断条件</p>
<ul>
<li>如果第一个条件为 true 了，那么就会执行后面的 <code>{}</code> 里面的内容</li>
<li>如果第一个条件为 false，那么就会判断第二个条件，依次类推</li>
</ul>
</li>
<li><p>多个 <code>{}</code> ，只会有一个被执行，一旦有一个条件为 true 了，后面的就不在判断了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个条件为 true，第二个条件为 false，最终会打印 “我是代码段1”</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段1'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">	alert(<span class="string">'我是代码段2'</span>)           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个条件为 true，第二个条件为 true，最终会打印 “我是代码段1”</span></span><br><span class="line"><span class="comment">// 因为只要前面有一个条件满足了，就不会继续判断了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段1'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个条件为 false，第二个条件为 true，最终会打印 “我是代码段2”</span></span><br><span class="line"><span class="comment">// 只有前一个条件为 false 的时候才会继续向后判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段1'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个条件为 false，第二个条件为 false，最终什么也不会发生</span></span><br><span class="line"><span class="comment">// 因为当所有条件都为 false 的时候，两个 &#123;&#125; 里面的代码都不会执行</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段1'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="if-else-if-…-else-语句"><a href="#if-else-if-…-else-语句" class="headerlink" title="if else if … else 语句"></a>if else if … else 语句</h3><ul>
<li><p>和之前的 <code>if else if ...</code> 基本一致，只不过是在所有条件都不满足的时候，执行最后 else 后面的 <code>{}</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个条件为 false，第二个条件为 false，最终会打印 “我是代码段3”</span></span><br><span class="line"><span class="comment">// 只有前面所有的条件都不满足的时候会执行 else 后面的 &#123;&#125; 里面的代码</span></span><br><span class="line"><span class="comment">// 只要前面有一个条件满足了，那么后面的就都不会执行了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段1'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段2'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'我是代码段3'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="SWITCH-条件分支结构"><a href="#SWITCH-条件分支结构" class="headerlink" title="SWITCH 条件分支结构"></a>SWITCH 条件分支结构</h2><ul>
<li><p>也是条件判断语句的一种</p>
</li>
<li><p>是对于某一个变量的判断</p>
</li>
<li><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (要判断的变量) &#123;</span><br><span class="line">  <span class="keyword">case</span> 情况<span class="number">1</span>:</span><br><span class="line">    情况<span class="number">1</span>要执行的代码</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 情况<span class="number">2</span>:</span><br><span class="line">    情况<span class="number">2</span>要执行的代码</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 情况<span class="number">3</span>:</span><br><span class="line">    情况<span class="number">3</span>要执行的代码</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    上述情况都不满足的时候执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要判断某一个变量 等于 某一个值得时候使用</li>
</ul>
</li>
<li><p>例子🌰： 根据变量给出的数字显示是星期几</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> week = <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    alert(<span class="string">'星期一'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    alert(<span class="string">'星期二'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    alert(<span class="string">'星期三'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    alert(<span class="string">'星期四'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    alert(<span class="string">'星期五'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    alert(<span class="string">'星期六'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    alert(<span class="string">'星期日'</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">'请输入一个 1 ～ 7 之间的数字'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三元运算（扩展）"><a href="#三元运算（扩展）" class="headerlink" title="三元运算（扩展）"></a>三元运算（扩展）</h2><ul>
<li><p>三元运算，就是用 <strong>两个符号</strong> 组成一个语句</p>
</li>
<li><p>三元运算只是对 <strong>if else</strong> 语句的一个简写形式</p>
</li>
<li><p>语法： <code>条件 ? 条件为 true 的时候执行 : 条件为 false 的时候执行</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">age &gt;= <span class="number">18</span> ? alert(<span class="string">'已经成年'</span>) : alert(<span class="string">'没有成年'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>千锋</category>
      </categories>
  </entry>
</search>
